{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/lodash.merge/index.js","webpack:///../node_modules/objection/lib/model/AjvValidator.js","webpack:///../node_modules/objection/lib/model/Model.js","webpack:///../node_modules/objection/lib/model/ModifierNotFoundError.js","webpack:///../node_modules/objection/lib/model/NotFoundError.js","webpack:///../node_modules/objection/lib/model/RelationDoesNotExistError.js","webpack:///../node_modules/objection/lib/model/ValidationError.js","webpack:///../node_modules/objection/lib/model/Validator.js","webpack:///../node_modules/objection/lib/model/graph/ModelGraph.js","webpack:///../node_modules/objection/lib/model/graph/ModelGraphBuilder.js","webpack:///../node_modules/objection/lib/model/graph/ModelGraphEdge.js","webpack:///../node_modules/objection/lib/model/graph/ModelGraphNode.js","webpack:///../node_modules/objection/lib/model/inheritModel.js","webpack:///../node_modules/objection/lib/model/modelBindKnex.js","webpack:///../node_modules/objection/lib/model/modelClone.js","webpack:///../node_modules/objection/lib/model/modelColPropMap.js","webpack:///../node_modules/objection/lib/model/modelFilter.js","webpack:///../node_modules/objection/lib/model/modelId.js","webpack:///../node_modules/objection/lib/model/modelJsonAttributes.js","webpack:///../node_modules/objection/lib/model/modelParseRelations.js","webpack:///../node_modules/objection/lib/model/modelQueryProps.js","webpack:///../node_modules/objection/lib/model/modelSet.js","webpack:///../node_modules/objection/lib/model/modelTableMetadata.js","webpack:///../node_modules/objection/lib/model/modelToJson.js","webpack:///../node_modules/objection/lib/model/modelUtils.js","webpack:///../node_modules/objection/lib/model/modelValidate.js","webpack:///../node_modules/objection/lib/model/modelValues.js","webpack:///../node_modules/objection/lib/model/modelVisitor.js","webpack:///../node_modules/objection/lib/objection.js","webpack:///../node_modules/objection/lib/queryBuilder/InternalOptions.js","webpack:///../node_modules/objection/lib/queryBuilder/JoinBuilder.js","webpack:///../node_modules/objection/lib/queryBuilder/LiteralBuilder.js","webpack:///../node_modules/objection/lib/queryBuilder/QueryBuilder.js","webpack:///../node_modules/objection/lib/queryBuilder/QueryBuilderBase.js","webpack:///../node_modules/objection/lib/queryBuilder/QueryBuilderContext.js","webpack:///../node_modules/objection/lib/queryBuilder/QueryBuilderContextBase.js","webpack:///../node_modules/objection/lib/queryBuilder/QueryBuilderOperationSupport.js","webpack:///../node_modules/objection/lib/queryBuilder/QueryBuilderUserContext.js","webpack:///../node_modules/objection/lib/queryBuilder/RawBuilder.js","webpack:///../node_modules/objection/lib/queryBuilder/ReferenceBuilder.js","webpack:///../node_modules/objection/lib/queryBuilder/RelationExpression.js","webpack:///../node_modules/objection/lib/queryBuilder/StaticHookArguments.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/GraphAction.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/GraphOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/GraphOptions.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/GraphUpsert.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/delete/GraphDelete.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/delete/GraphDeleteAction.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/insert/GraphInsert.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/insert/GraphInsertAction.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/insert/JoinRowGraphInsertAction.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/patch/GraphPatch.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/patch/GraphPatchAction.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/recursiveUpsert/GraphRecursiveUpsert.js","webpack:///../node_modules/objection/lib/queryBuilder/graph/recursiveUpsert/GraphRecursiveUpsertAction.js","webpack:///../node_modules/objection/lib/queryBuilder/join/JoinResultColumn.js","webpack:///../node_modules/objection/lib/queryBuilder/join/JoinResultParser.js","webpack:///../node_modules/objection/lib/queryBuilder/join/RelationJoiner.js","webpack:///../node_modules/objection/lib/queryBuilder/join/TableNode.js","webpack:///../node_modules/objection/lib/queryBuilder/join/TableTree.js","webpack:///../node_modules/objection/lib/queryBuilder/join/utils.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/DelegateOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/DeleteOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/FindByIdOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/FindByIdsOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/FindOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/FirstOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/FromOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InsertAndFetchOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InsertGraphAndFetchOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InsertGraphOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InsertOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InstanceDeleteOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InstanceFindOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InstanceInsertOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/InstanceUpdateOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/JoinRelationOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/KnexOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/ObjectionToKnexConvertingOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/OnBuildKnexOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/OnBuildOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/OnErrorOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/QueryBuilderOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/RangeOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/RelateOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/ReturningOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/RunAfterOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/RunBeforeOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/UnrelateOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/UpdateAndFetchOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/UpdateOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/UpsertGraphAndFetchOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/UpsertGraphOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/WhereCompositeOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/eager/EagerOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/eager/JoinEagerOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/eager/NaiveEagerOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/eager/WhereInEagerOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonHasPostgresOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonNotObjectPostgresOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/jsonApi/WhereJsonPostgresOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/jsonApi/postgresJsonApi.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/select/SelectOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/select/Selection.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeMsSqlOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/operations/whereInComposite/WhereInCompositeSqliteOperation.js","webpack:///../node_modules/objection/lib/queryBuilder/parsers/jsonFieldExpressionParser.js","webpack:///../node_modules/objection/lib/queryBuilder/parsers/relationExpressionParser.js","webpack:///../node_modules/objection/lib/relations/Relation.js","webpack:///../node_modules/objection/lib/relations/RelationDeleteOperation.js","webpack:///../node_modules/objection/lib/relations/RelationFindOperation.js","webpack:///../node_modules/objection/lib/relations/RelationInsertOperation.js","webpack:///../node_modules/objection/lib/relations/RelationProperty.js","webpack:///../node_modules/objection/lib/relations/RelationSubqueryOperation.js","webpack:///../node_modules/objection/lib/relations/RelationUpdateOperation.js","webpack:///../node_modules/objection/lib/relations/belongsToOne/BelongsToOneDeleteOperation.js","webpack:///../node_modules/objection/lib/relations/belongsToOne/BelongsToOneInsertOperation.js","webpack:///../node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelateOperation.js","webpack:///../node_modules/objection/lib/relations/belongsToOne/BelongsToOneRelation.js","webpack:///../node_modules/objection/lib/relations/belongsToOne/BelongsToOneUnrelateOperation.js","webpack:///../node_modules/objection/lib/relations/hasMany/HasManyInsertOperation.js","webpack:///../node_modules/objection/lib/relations/hasMany/HasManyRelateOperation.js","webpack:///../node_modules/objection/lib/relations/hasMany/HasManyRelation.js","webpack:///../node_modules/objection/lib/relations/hasMany/HasManyUnrelateOperation.js","webpack:///../node_modules/objection/lib/relations/hasOne/HasOneRelation.js","webpack:///../node_modules/objection/lib/relations/hasOneThrough/HasOneThroughRelation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/ManyToManyModifyMixin.js","webpack:///../node_modules/objection/lib/relations/manyToMany/ManyToManyMySqlModifyMixin.js","webpack:///../node_modules/objection/lib/relations/manyToMany/ManyToManyRelation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/ManyToManySqliteModifyMixin.js","webpack:///../node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteMySqlOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteOperationBase.js","webpack:///../node_modules/objection/lib/relations/manyToMany/delete/ManyToManyDeleteSqliteOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/find/ManyToManyFindOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/insert/ManyToManyInsertOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/relate/ManyToManyRelateOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateMySqlOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateOperationBase.js","webpack:///../node_modules/objection/lib/relations/manyToMany/unrelate/ManyToManyUnrelateSqliteOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateMySqlOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperation.js","webpack:///../node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateOperationBase.js","webpack:///../node_modules/objection/lib/relations/manyToMany/update/ManyToManyUpdateSqliteOperation.js","webpack:///../node_modules/objection/lib/transaction.js","webpack:///../node_modules/objection/lib/utils sync ^.*$","webpack:///../node_modules/objection/lib/utils/assert.js","webpack:///../node_modules/objection/lib/utils/buildUtils.js","webpack:///../node_modules/objection/lib/utils/classUtils.js","webpack:///../node_modules/objection/lib/utils/clone.js","webpack:///../node_modules/objection/lib/utils/createModifier.js","webpack:///../node_modules/objection/lib/utils/deprecate.js","webpack:///../node_modules/objection/lib/utils/identifierMapping.js","webpack:///../node_modules/objection/lib/utils/internalPropUtils.js","webpack:///../node_modules/objection/lib/utils/knexUtils.js","webpack:///../node_modules/objection/lib/utils/mixin.js","webpack:///../node_modules/objection/lib/utils/normalizeIds.js","webpack:///../node_modules/objection/lib/utils/objectUtils.js","webpack:///../node_modules/objection/lib/utils/parseFieldExpression.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/after.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/afterReturn.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/index.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/isPromise.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/map.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/mapAfterAllReturn.js","webpack:///../node_modules/objection/lib/utils/promiseUtils/try.js","webpack:///../node_modules/objection/lib/utils/resolveModel.js","webpack:///../node_modules/objection/lib/utils/tmpColumnUtils.js","webpack:///./constants/user.js","webpack:///./handler.js","webpack:///./models/user.js","webpack:///(webpack)/buildin/module.js","webpack:///./playground/index.js","webpack:///./playground/user.js","webpack:///./resolvers/index.js","webpack:///./resolvers/user.js","webpack:///./typeDefs/index.js","webpack:///./typeDefs/user.js","webpack:///./util/password.js","webpack:///external \"ajv\"","webpack:///external \"apollo-server-lambda\"","webpack:///external \"bluebird\"","webpack:///external \"crypto\"","webpack:///external \"dotenv\"","webpack:///external \"graphql\"","webpack:///external \"graphql/language\"","webpack:///external \"knex\"","webpack:///external \"lodash\"","webpack:///external \"path\"","webpack:///external \"source-map-support/register\""],"names":["Login","User","require","config","db","Knex","client","connection","host","process","env","DB_HOST","user","DB_USER","password","DB_PASSWORD","database","ADVITO_DB_DATABASE","Model","knex","server","ApolloServer","typeDefs","resolvers","context","event","sessionToken","headers","sessiontoken","playground","graphqlHandler","createHandler","cors","origin","credentials","AdvitoUser","tableName","fullName","name_first","name_last","relationMappings","advito_user_role_link","relation","HasManyRelation","modelClass","AdvitoUserRoleLink","join","from","to","advito_user_session","AdvitoUserSession","tabs","Query","Mutation","name","endpoint","query","merge","Date","GraphQLScalarType","description","parseValue","value","serialize","getTime","parseLiteral","ast","kind","Kind","INT","parseInt","getUser","_","__","findById","login","username","where","first","AuthenticationError","is_enabled","pwd","dbPassword","user_salt","userSalt","passwordHashed","saltHash","roleIds","$relatedQuery","map","role","advito_role_id","session","crypto","randomBytes","toString","expirationDate","setHours","getHours","patch","session_end","insert","advito_user_id","id","session_token","session_start","session_duration_sec","session_type","session_expiration","session_note","created","modified","displayName","clientId","client_id","profilePicturePath","profile_picture_path","logout","gql","salt","saltHashed","createHash","update","digest"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,KAA0B;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,MAAM;AACjB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO,WAAW;AAC7B,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6BAA6B,kBAAkB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB,EAAE;AAClE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,UAAU;AACV;AACA,aAAa,SAAS;AACtB,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,YAAY,SAAS,GAAG,SAAS;AACjC;AACA;AACA;AACA,YAAY,SAAS,GAAG,SAAS;AACjC;AACA;AACA;AACA,UAAU,QAAQ,iBAAiB,GAAG,iBAAiB;AACvD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,SAAS;AACtB;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,WAAW,SAAS,GAAG,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;ACx7Da;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,qEAAa;AAC3C,OAAO,sBAAsB,GAAG,mBAAO,CAAC,wFAA0B;AAClE,OAAO,mDAAmD,GAAG,mBAAO,CAAC,gFAAsB;;AAE3F;AACA;AACA,WAAW,mBAAO,CAAC,gBAAK;AACxB,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,qCAAqC,4BAA4B;AACjE;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAY,4BAA4B;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB,EAAE,eAAe;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Ra;;AAEb,OAAO,QAAQ,GAAG,mBAAO,CAAC,uEAAc;AACxC,OAAO,WAAW,GAAG,mBAAO,CAAC,6EAAiB;AAC9C,OAAO,WAAW,GAAG,mBAAO,CAAC,6EAAiB;AAC9C,OAAO,UAAU,GAAG,mBAAO,CAAC,4EAAoB;AAChD,OAAO,aAAa,GAAG,mBAAO,CAAC,yEAAe;AAC9C,OAAO,cAAc,GAAG,mBAAO,CAAC,2EAAgB;AAChD,OAAO,kBAAkB,GAAG,mBAAO,CAAC,iEAAW;AAC/C,OAAO,kBAAkB,GAAG,mBAAO,CAAC,wFAAuB;AAC3D,OAAO,yBAAyB,GAAG,mBAAO,CAAC,yEAAe;AAC1D,OAAO,4BAA4B,GAAG,mBAAO,CAAC,yEAAe;AAC7D,OAAO,8BAA8B,GAAG,mBAAO,CAAC,uEAAc;AAC9D,OAAO,mCAAmC,GAAG,mBAAO,CAAC,yFAAuB;AAC5E,OAAO,oCAAoC,GAAG,mBAAO,CAAC,uFAAsB;AAC5E,OAAO,0CAA0C,GAAG,mBAAO,CAAC,gFAAsB;AAClF,OAAO,+DAA+D,GAAG,mBAAO,CAAC,mEAAY;AAC7F;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,yFAAuB;AACnC,OAAO,qDAAqD,GAAG,mBAAO,CAAC,iFAAmB;;AAE1F,OAAO,MAAM,GAAG,mBAAO,CAAC,4FAA4B;AACpD,OAAO,MAAM,GAAG,mBAAO,CAAC,wGAAkC;;AAE1D,OAAO,eAAe,GAAG,mBAAO,CAAC,2EAAgB;AACjD,OAAO,eAAe,GAAG,mBAAO,CAAC,gGAA8B;AAC/D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,6EAAiB;AACnD,OAAO,kBAAkB,GAAG,mBAAO,CAAC,iFAAmB;AACvD,OAAO,wBAAwB,GAAG,mBAAO,CAAC,6FAAyB;AACnE,OAAO,mBAAmB,GAAG,mBAAO,CAAC,kGAA+B;;AAEpE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4GAAoC;AACvE,OAAO,kBAAkB,GAAG,mBAAO,CAAC,gHAAsC;AAC1E,OAAO,qBAAqB,GAAG,mBAAO,CAAC,4HAA4C;AACnF,OAAO,uBAAuB,GAAG,mBAAO,CAAC,oIAAgD;AACzF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,wIAAkD;;AAE5F,OAAO,wBAAwB,GAAG,mBAAO,CAAC,wIAAkD;AAC5F,OAAO,0BAA0B,GAAG,mBAAO,CAAC,4IAAoD;AAChG,OAAO,0BAA0B,GAAG,mBAAO,CAAC,4IAAoD;AAChG,OAAO,0BAA0B,GAAG,mBAAO,CAAC,4IAAoD;;AAEhG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,iBAAiB;AACnE,OAAO;AACP;AACA,sDAAsD,iBAAiB;AACvE,OAAO;AACP;AACA,sDAAsD,iBAAiB;AACvE,OAAO;AACP;AACA;AACA;AACA,yBAAyB;AACzB,SAAS;AACT,OAAO;AACP;AACA,sDAAsD,iBAAiB;AACvE,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,UAAU;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oBAAoB,GAAG,UAAU;AACjD,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,UAAU,yBAAyB,KAAK;AAC/E;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;;AAEA;AACA,WAAW,uCAAuC;;AAElD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,WAAW,uCAAuC;;AAElD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,2CAA2C,gDAAgD;AAC3F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc,IAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6CAA6C,EAAE;AAC1F,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,0BAA0B,GAAG,MAAM;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC31Ba;;AAEb;AACA;AACA,uEAAuE,aAAa;AACpF;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACXa;;AAEb;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACda;;AAEb;AACA;AACA,+BAA+B,aAAa;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,gFAAsB;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,yBAAyB,oBAAoB;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,IAAI,IAAI;AACnB;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AClDa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzBa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,2FAAqB;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Ea;;AAEb,OAAO,wCAAwC,GAAG,mBAAO,CAAC,mFAAyB;AACnF,OAAO,sBAAsB,GAAG,mBAAO,CAAC,2FAA6B;AACrE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,qFAAkB;AACrD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,qFAAkB;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,MAAM,yBAAyB,gBAAgB;AAC/E,GAAG;AACH;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpOa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnDa;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,qFAAkB;AACrD,OAAO,WAAW,GAAG,mBAAO,CAAC,mFAAyB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,IAAI,GAAG,GAAG;AAC5B,OAAO;AACP,wBAAwB,IAAI,GAAG,GAAG;AAClC;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjPa;;AAEb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Ba;;AAEb,OAAO,eAAe,GAAG,mBAAO,CAAC,2EAAgB;AACjD,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uEAAc;AACpD,OAAO,8BAA8B,GAAG,mBAAO,CAAC,uEAAc;;AAE9D;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClFa;;AAEb,OAAO,sBAAsB,GAAG,mBAAO,CAAC,gFAAsB;AAC9D,OAAO,cAAc,GAAG,mBAAO,CAAC,uEAAc;AAC9C,OAAO,8BAA8B,GAAG,mBAAO,CAAC,uEAAc;AAC9D,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4FAA4B;;AAE/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,OAAO;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClHa;;AAEb,OAAO,aAAa,GAAG,mBAAO,CAAC,gFAAsB;;AAErD;AACA;AACA,4DAA4D;;AAE5D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4DAA4D;;AAE5D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,gFAAsB;AACnD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4FAA4B;;AAE/D;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACtGa;;AAEb;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Da;;AAEb,OAAO,uCAAuC,GAAG,mBAAO,CAAC,gFAAsB;;AAE/E;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Fa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,gFAAsB;;AAEnD,mEAAmE;AACnE;AACA,8BAA8B;AAC9B;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjFa;;AAEb,OAAO,uBAAuB,GAAG,mBAAO,CAAC,gFAAsB;AAC/D,OAAO,8BAA8B,GAAG,mBAAO,CAAC,uEAAc;AAC9D,OAAO,gCAAgC,GAAG,mBAAO,CAAC,4EAAoB;;AAEtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AClJa;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4FAA4B;AAC/D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,iFAAmB;AACvD,OAAO,uBAAuB,GAAG,mBAAO,CAAC,gFAAsB;AAC/D,OAAO,mCAAmC,GAAG,mBAAO,CAAC,yFAAuB;;AAE5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClIa;;AAEb,OAAO,8BAA8B,GAAG,mBAAO,CAAC,uEAAc;AAC9D,OAAO,YAAY,GAAG,mBAAO,CAAC,wFAAuB;;AAErD;;AAEA;AACA;AACA,GAAG,iEAAiE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,QAAQ;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ,KAAK;AACjD;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC9Ea;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4FAA4B;AAC/D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,iFAAmB;AACvD,OAAO,kCAAkC,GAAG,mBAAO,CAAC,gFAAsB;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1La;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9Ca;;AAEb,OAAO,QAAQ,GAAG,mBAAO,CAAC,uEAAc;;AAExC,2CAA2C;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,gBAAgB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Ca;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,gFAAsB;;AAEnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH,cAAc,MAAM;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Ha;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxCa;;AAEb,OAAO,qBAAqB,GAAG,mBAAO,CAAC,mEAAe;AACtD,OAAO,mCAAmC,GAAG,mBAAO,CAAC,+FAA6B;AAClF,OAAO,mBAAmB,GAAG,mBAAO,CAAC,uGAAiC;AACtE,OAAO,wBAAwB,GAAG,mBAAO,CAAC,uIAAiD;AAC3F,OAAO,qBAAqB,GAAG,mBAAO,CAAC,2GAAmC;AAC1E,OAAO,kBAAkB,GAAG,mBAAO,CAAC,uFAAyB;AAC7D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,mFAAuB;AACzD,OAAO,mCAAmC,GAAG,mBAAO,CAAC,iFAAsB;AAC3E,OAAO,6BAA6B,GAAG,mBAAO,CAAC,2EAAmB;AAClE,OAAO,WAAW,GAAG,mBAAO,CAAC,iFAAsB;AACnD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,2GAAmC;AACtE,OAAO,kBAAkB,GAAG,mBAAO,CAAC,+GAAqC;AACzE,OAAO,uBAAuB,GAAG,mBAAO,CAAC,mIAA+C;AACxF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,uIAAiD;AAC3F,OAAO,qBAAqB,GAAG,mBAAO,CAAC,2HAA2C;AAClF,OAAO,cAAc,GAAG,mBAAO,CAAC,mEAAe;;AAE/C;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,2FAA2B;AACvC,OAAO,iBAAiB,GAAG,mBAAO,CAAC,mEAAe;AAClD,OAAO,MAAM,GAAG,mBAAO,CAAC,uGAAiC;AACzD,OAAO,MAAM,GAAG,mBAAO,CAAC,mGAA+B;AACvD,OAAO,MAAM,GAAG,mBAAO,CAAC,2FAA2B;;AAEnD,OAAO,UAAU,GAAG,mBAAO,CAAC,kFAAyB;AACrD,OAAO,YAAY,GAAG,mBAAO,CAAC,gFAAwB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,0BAAU;AAC/B;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA,CAAC;;;;;;;;;;;;;AC/GY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxBa;;AAEb,OAAO,+BAA+B,GAAG,mBAAO,CAAC,kHAAgC;AACjF,OAAO,gBAAgB,GAAG,mBAAO,CAAC,0GAA4B;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzIa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,gFAAsB;AAC5D,OAAO,WAAW,GAAG,mBAAO,CAAC,8EAAqB;AAClD,OAAO,YAAY,GAAG,mBAAO,CAAC,4EAAoB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,mCAAmC;AACxD,KAAK;AACL;AACA;AACA;;AAEA;AACA,oBAAoB,IAAI,MAAM,WAAW;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ga;;AAEb,iBAAiB,mBAAO,CAAC,0BAAU;;AAEnC,OAAO,MAAM,GAAG,mBAAO,CAAC,8EAAc;AACtC,OAAO,YAAY,GAAG,mBAAO,CAAC,4EAAoB;AAClD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,sFAAyB;AAC5D,OAAO,sBAAsB,GAAG,mBAAO,CAAC,wFAA0B;AAClE,OAAO,uCAAuC,GAAG,mBAAO,CAAC,gFAAsB;AAC/E,OAAO,6CAA6C,GAAG,mBAAO,CAAC,8FAAsB;AACrF,OAAO,YAAY,GAAG,mBAAO,CAAC,gHAA+B;;AAE7D,OAAO,sBAAsB,GAAG,mBAAO,CAAC,gGAAuB;AAC/D,OAAO,mBAAmB,GAAG,mBAAO,CAAC,0FAAoB;;AAEzD,OAAO,gBAAgB,GAAG,mBAAO,CAAC,0GAA4B;AAC9D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,8GAA8B;AAClE,OAAO,kBAAkB,GAAG,mBAAO,CAAC,8GAA8B;AAClE,OAAO,kBAAkB,GAAG,mBAAO,CAAC,8GAA8B;AAClE,OAAO,kBAAkB,GAAG,mBAAO,CAAC,8GAA8B;AAClE,OAAO,oBAAoB,GAAG,mBAAO,CAAC,kHAAgC;;AAEtE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,gIAAuC;AAC9E,OAAO,sBAAsB,GAAG,mBAAO,CAAC,kIAAwC;AAChF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,sIAA0C;;AAEpF,OAAO,+BAA+B,GAAG,mBAAO,CAAC,wIAA2C;AAC5F,OAAO,+BAA+B,GAAG,mBAAO,CAAC,wIAA2C;AAC5F,OAAO,0BAA0B,GAAG,mBAAO,CAAC,8HAAsC;AAClF,OAAO,0BAA0B,GAAG,mBAAO,CAAC,8HAAsC;AAClF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,0HAAoC;AAC9E,OAAO,uBAAuB,GAAG,mBAAO,CAAC,wHAAmC;AAC5E,OAAO,uBAAuB,GAAG,mBAAO,CAAC,wHAAmC;AAC5E,OAAO,uBAAuB,GAAG,mBAAO,CAAC,wHAAmC;AAC5E,OAAO,qBAAqB,GAAG,mBAAO,CAAC,oHAAiC;AACxE,OAAO,oBAAoB,GAAG,mBAAO,CAAC,kHAAgC;AACtE,OAAO,oBAAoB,GAAG,mBAAO,CAAC,kHAAgC;AACtE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,oHAAiC;AACxE,OAAO,mBAAmB,GAAG,mBAAO,CAAC,gHAA+B;AACpE,OAAO,mBAAmB,GAAG,mBAAO,CAAC,gHAA+B;AACpE,OAAO,kBAAkB,GAAG,mBAAO,CAAC,4HAAqC;AACzE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,wHAAmC;AACtE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4GAA6B;AAChE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4GAA6B;AAChE,OAAO,gBAAgB,GAAG,mBAAO,CAAC,0GAA4B;AAC9D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,0GAA4B;;AAE9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAoC,UAAU,GAAG,IAAI;AACrD,KAAK;AACL,gBAAgB,UAAU,GAAG,SAAS;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;AAC7B,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+DAA+D;AAC/D,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;;AAET;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;;AAET;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,cAAc,eAAe,KAAK;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS,4BAA4B,IAAI;AACzC,OAAO;AACP,KAAK;AACL;AACA;AACA,iDAAiD,IAAI;AACrD,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,yBAAyB,MAAM,MAAM,SAAS;AAC9C;AACA;;AAEA;AACA;;AAEA,wBAAwB,SAAS;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,GAAG;AACH;;AAEA;AACA,yCAAyC;AACzC;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/9Ca;;AAEb,OAAO,+BAA+B,GAAG,mBAAO,CAAC,kHAAgC;AACjF,OAAO,oBAAoB,GAAG,mBAAO,CAAC,4EAAoB;;AAE1D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,0GAA4B;AAC9D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,4HAAqC;AACzE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,oHAAiC;AACxE,OAAO,0BAA0B,GAAG,mBAAO,CAAC,8HAAsC;AAClF,OAAO,6BAA6B,GAAG,mBAAO,CAAC,oJAAiD;;AAEhG;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,oKAAyD;AACrE;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,gLAA+D;AAC3E;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,8KAA8D;AAC1E;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,0JAAoD;AAChE;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sKAA0D;;AAEtE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8EAA8E,gBAAgB;AAC9F,KAAK;AACL,6EAA6E,gBAAgB;AAC7F,KAAK;AACL,wEAAwE,gBAAgB;AACxF;;AAEA;AACA;;AAEA;AACA;AACA,6DAA6D,8BAA8B;AAC3F;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,6BAA6B;AAC5F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,8BAA8B;AACzF;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,6BAA6B;AAC1F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,8BAA8B;AAC1F;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,6BAA6B;AAC3F;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,8BAA8B;AAC1F;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,6BAA6B;AAC3F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;;AAEA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;AC7qBa;;AAEb,OAAO,0BAA0B,GAAG,mBAAO,CAAC,wGAA2B;;AAEvE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1Ba;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,wFAAmB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClCa;;AAEb,qBAAqB,mBAAO,CAAC,wFAAuB;;AAEpD,OAAO,eAAe,GAAG,mBAAO,CAAC,8EAAqB;AACtD,OAAO,uCAAuC,GAAG,mBAAO,CAAC,gFAAsB;AAC/E,OAAO,wBAAwB,GAAG,mBAAO,CAAC,0HAAoC;AAC9E,OAAO,0BAA0B,GAAG,mBAAO,CAAC,wGAA2B;AACvE,OAAO,0BAA0B,GAAG,mBAAO,CAAC,wGAA2B;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB,KAAK;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uCAAuC;AACtD;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjea;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9Ba;;AAEb,OAAO,gBAAgB,GAAG,mBAAO,CAAC,gFAAsB;AACxD,OAAO,WAAW,GAAG,mBAAO,CAAC,8EAAqB;;AAElD;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;AACA,GAAG;AACH;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFa;;AAEb,OAAO,uBAAuB,GAAG,mBAAO,CAAC,kGAA+B;AACxE,OAAO,WAAW,GAAG,mBAAO,CAAC,gFAAsB;AACnD,OAAO,YAAY,GAAG,mBAAO,CAAC,4EAAoB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,MAAM,GAAG,YAAY;AACrC,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,UAAU,EAAE,EAAE,cAAc;AAC9C,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,IAAI,MAAM,WAAW;AAC1C,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,IAAI;AAC7B,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpQa;;AAEb,eAAe,mBAAO,CAAC,0HAAoC;AAC3D,OAAO,sCAAsC,GAAG,mBAAO,CAAC,gFAAsB;AAC9E,OAAO,4BAA4B,GAAG,mBAAO,CAAC,4GAAoC;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,oBAAoB,qBAAqB;AACzC,GAAG;AACH;AACA;;AAEA;AACA,eAAe,wBAAwB;AACvC;;AAEA;AACA,kBAAkB,WAAW;AAC7B;;AAEA;AACA;AACA,gBAAgB,IAAI,GAAG,UAAU;AACjC,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ya;;AAEb,OAAO,UAAU,GAAG,mBAAO,CAAC,gFAAsB;;AAElD;;AAEA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnIa;;AAEb,OAAO,aAAa,GAAG,mBAAO,CAAC,+EAAuB;;AAEtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChDa;;AAEb,OAAO,mBAAmB,GAAG,mBAAO,CAAC,mFAAyB;AAC9D,OAAO,aAAa,GAAG,mBAAO,CAAC,6FAA8B;AAC7D,OAAO,gBAAgB,GAAG,mBAAO,CAAC,wFAAgB;AAClD,OAAO,qBAAqB,GAAG,mBAAO,CAAC,+FAAuB;;AAE9D;AACA,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;;AAEA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,6CAA6C,GAAG,mBAAmB;AACnF;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,qCAAqC,GAAG,OAAO;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ma;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,SAAS;AACpD;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC7La;;AAEb,OAAO,aAAa,GAAG,mBAAO,CAAC,6FAA8B;AAC7D,OAAO,sBAAsB,GAAG,mBAAO,CAAC,2GAAqC;AAC7E,OAAO,iBAAiB,GAAG,mBAAO,CAAC,mGAAyB;AAC5D,OAAO,cAAc,GAAG,mBAAO,CAAC,2GAA6B;AAC7D,OAAO,aAAa,GAAG,mBAAO,CAAC,uGAA2B;AAC1D,OAAO,cAAc,GAAG,mBAAO,CAAC,2GAA6B;AAC7D,OAAO,uBAAuB,GAAG,mBAAO,CAAC,+IAA+C;AACxF,OAAO,eAAe,GAAG,mBAAO,CAAC,+FAAuB;AACxD,OAAO,sBAAsB,GAAG,mBAAO,CAAC,2FAA6B;AACrE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,+FAAuB;AAC9D,OAAO,4BAA4B,GAAG,mBAAO,CAAC,mFAAyB;;AAEvE;AACA,eAAe,yCAAyC;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,+BAA+B;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe;AACpD;AACA,SAAS;AACT,OAAO;AACP;AACA,gCAAgC,eAAe,gCAAgC,0BAA0B;AACzG;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,oCAAoC;AAC3E;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Oa;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,6FAAmB;AACtD,OAAO,oBAAoB,GAAG,mBAAO,CAAC,yGAAqB;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtBa;;AAEb,OAAO,cAAc,GAAG,mBAAO,CAAC,uFAAgB;AAChD,OAAO,UAAU,GAAG,mBAAO,CAAC,sFAA4B;AACxD,qBAAqB,mBAAO,CAAC,8FAA6B;;AAE1D;AACA,eAAe,6BAA6B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ea;;AAEb,OAAO,2BAA2B,GAAG,mBAAO,CAAC,uHAA4B;AACzE,OAAO,oBAAoB,GAAG,mBAAO,CAAC,yGAAqB;AAC3D,OAAO,iBAAiB,GAAG,mBAAO,CAAC,6FAAmB;AACtD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,wGAAqC;;AAExE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrJa;;AAEb,OAAO,cAAc,GAAG,mBAAO,CAAC,uFAAgB;AAChD,OAAO,2BAA2B,GAAG,mBAAO,CAAC,sFAA4B;AACzE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,wGAAqC;AACxE,qBAAqB,mBAAO,CAAC,8FAA6B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAkD;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kFAAkF,cAAc;AAChG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,OAAO;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,aAAa;;AAEzB;AACA;AACA,KAAK;;AAEL;AACA;AACA,gCAAgC,6BAA6B;AAC7D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClOa;;AAEb,OAAO,cAAc,GAAG,mBAAO,CAAC,uFAAgB;AAChD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,sFAA4B;AAC/D,qBAAqB,mBAAO,CAAC,8FAA6B;;AAE1D;AACA,eAAe,oCAAoC;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kFAAkF,cAAc;AAChG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,WAAW,yBAAyB;AACpC,WAAW,WAAW;;AAEtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9Fa;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,6FAAmB;AACtD,OAAO,mBAAmB,GAAG,mBAAO,CAAC,sGAAoB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvBa;;AAEb,OAAO,cAAc,GAAG,mBAAO,CAAC,uFAAgB;AAChD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,kGAAkC;AACrE,OAAO,0CAA0C,GAAG,mBAAO,CAAC,sFAA4B;AACxF,qBAAqB,mBAAO,CAAC,8FAA6B;;AAE1D;AACA,eAAe,2CAA2C;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,+BAA+B;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;;AAE1B,oDAAoD,OAAO;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;;AAE1B,oDAAoD,OAAO;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrNa;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,6FAAmB;AACtD,OAAO,6BAA6B,GAAG,mBAAO,CAAC,oIAA8B;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjCa;;AAEb,OAAO,cAAc,GAAG,mBAAO,CAAC,uFAAgB;AAChD,OAAO,UAAU,GAAG,mBAAO,CAAC,sFAA4B;AACxD,qBAAqB,mBAAO,CAAC,8FAA6B;;AAE1D;AACA,eAAe,6BAA6B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Da;;AAEb;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtBa;;AAEb,OAAO,mBAAmB,GAAG,mBAAO,CAAC,+FAAoB;AACzD,OAAO,UAAU,GAAG,mBAAO,CAAC,mFAAyB;;AAErD;AACA,eAAe,oCAAoC;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,yCAAyC;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,UAAU,GAAG,2BAA2B,GAAG,GAAG;AAC5D,GAAG;AACH,eAAe,GAAG;AAClB;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtHa;;AAEb,OAAO,SAAS,GAAG,mBAAO,CAAC,mFAAyB;AACpD,OAAO,YAAY,GAAG,mBAAO,CAAC,iHAAgC;AAC9D,OAAO,iBAAiB,GAAG,mBAAO,CAAC,yFAA4B;AAC/D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,2FAA0B;AAC9D,OAAO,sBAAsB,GAAG,mBAAO,CAAC,2FAA6B;;AAErE,OAAO,YAAY,GAAG,mBAAO,CAAC,iFAAa;AAC3C,OAAO,mBAAmB,GAAG,mBAAO,CAAC,+FAAoB;AACzD,OAAO,kBAAkB,GAAG,mBAAO,CAAC,yEAAS;;AAE7C;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,wCAAwC;AACvE;;AAEA;AACA,0BAA0B,uDAAuD;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,sBAAsB,wCAAwC;AAC9D;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA,+BAA+B,mDAAmD;AAClF;AACA;;AAEA,iBAAiB,wCAAwC;AACzD,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,gCAAgC;AAC/D,SAAS,mCAAmC;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+CAA+C,aAAa,kBAAkB,cAAc;AAC5F,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,qBAAqB;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS,GAAG,IAAI;;AAEnC;AACA;;AAEA,+BAA+B,wCAAwC;AACvE;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,4BAA4B;;AAEvF;AACA,kEAAkE,YAAY;AAC9E;AACA;AACA;;AAEA;AACA,+DAA+D,qBAAqB;AACpF;AACA,GAAG;AACH,iDAAiD,YAAY;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,mDAAmD;;AAEjG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,4BAA4B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,wCAAwC,qBAAqB;AAC7D;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,yBAAyB,gBAAgB,GAAG,iBAAiB;AAC7D,cAAc,UAAU,MAAM,gBAAgB;AAC9C,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,MAAM,WAAW,gBAAgB;AAC9D,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ua;;AAEb;AACA,eAAe,wEAAwE;AACvF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,WAAW,GAAG,OAAO;AACnC;;AAEA;AACA;AACA,gBAAgB,WAAW,EAAE,uBAAuB,EAAE,OAAO;AAC7D,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,+BAA+B;AACnD,OAAO;AACP,kBAAkB,sBAAsB,EAAE,uBAAuB,EAAE,MAAM;AACzE,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,GAAG;AACjB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,IAAI,GAAG,IAAI;AACzB;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,OAAO;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Ja;;AAEb,OAAO,yBAAyB,GAAG,mBAAO,CAAC,yEAAS;AACpD,OAAO,YAAY,GAAG,mBAAO,CAAC,iFAAa;;AAE3C;AACA,eAAe,sDAAsD;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yCAAyC;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,yBAAyB;AACzC,2CAA2C,yBAAyB;AACpE,4BAA4B,+CAA+C;;AAE3E;AACA;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpFa;;AAEb,OAAO,sBAAsB,GAAG,mBAAO,CAAC,2FAA6B;;AAErE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACxBa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ha;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,2FAA0B;AACjE,OAAO,sBAAsB,GAAG,mBAAO,CAAC,iGAAwB;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,kBAAkB;AAC7D;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjDa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,sBAAsB,GAAG,mBAAO,CAAC,iGAAwB;AAChE,OAAO,gCAAgC,GAAG,mBAAO,CAAC,2FAA0B;AAC5E,OAAO,WAAW,GAAG,mBAAO,CAAC,mFAAyB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,kBAAkB;AAC7D;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrKa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxBa;;AAEb,OAAO,qCAAqC,GAAG,mBAAO,CAAC,yIAAsC;AAC7F,OAAO,0BAA0B,GAAG,mBAAO,CAAC,mFAAyB;;AAErE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,oBAAoB;AAChD;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpGa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,mGAAmB;AACvD,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uGAAqB;AAC3D,OAAO,aAAa,GAAG,mBAAO,CAAC,iFAAwB;AACvD,OAAO,UAAU,GAAG,mBAAO,CAAC,mFAAyB;AACrD,OAAO,QAAQ,GAAG,mBAAO,CAAC,2FAA0B;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChDa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uGAAqB;AAC3D,OAAO,uBAAuB,GAAG,mBAAO,CAAC,6GAAwB;AACjE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,+FAAuB;;AAE9D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ca;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uGAAqB;AAC3D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,mGAAmB;AACvD,OAAO,cAAc,GAAG,mBAAO,CAAC,6FAAsB;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Fa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,sBAAsB,GAAG,mBAAO,CAAC,iGAAwB;AAChE,OAAO,wCAAwC,GAAG,mBAAO,CAAC,2FAA0B;AACpF,OAAO,gCAAgC,GAAG,mBAAO,CAAC,+EAAuB;AACzE,OAAO,WAAW,GAAG,mBAAO,CAAC,mFAAyB;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,6BAA6B;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,KAAK;AACL;AACA,6CAA6C,OAAO;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,kBAAkB;AAC7D;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;;;;;;;AChIa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,mGAAmB;AACvD,OAAO,cAAc,GAAG,mBAAO,CAAC,yEAAoB;AACpD,OAAO,qBAAqB,GAAG,mBAAO,CAAC,2FAA0B;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtCa;;AAEb,OAAO,gBAAgB,GAAG,mBAAO,CAAC,+FAAiB;AACnD,OAAO,cAAc,GAAG,mBAAO,CAAC,yEAAoB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnBa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,mGAAmB;;AAEvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvBa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,mGAAmB;AACvD,OAAO,cAAc,GAAG,mBAAO,CAAC,yEAAoB;AACpD,OAAO,WAAW,GAAG,mBAAO,CAAC,mFAAyB;AACtD,OAAO,QAAQ,GAAG,mBAAO,CAAC,2FAA0B;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtDa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,+FAAuB;AAC9D,OAAO,iBAAiB,GAAG,mBAAO,CAAC,iGAAwB;AAC3D,OAAO,WAAW,GAAG,mBAAO,CAAC,mFAAyB;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL,uBAAuB,gBAAgB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrGa;;AAEb,OAAO,qCAAqC,GAAG,mBAAO,CAAC,yIAAsC;;AAE7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,4CAA4C,GAAG,mBAAO,CAAC,mFAAyB;AACvF,OAAO,wCAAwC,GAAG,mBAAO,CAAC,+EAAuB;AACjF,kCAAkC,mBAAO,CAAC,iFAAgB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,2CAA2C,EAAE,QAAQ,OAAO;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,EAAE,QAAQ,OAAO;AACvE;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,EAAE,QAAQ,OAAO;AAC1E;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnLa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChQa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC9Ca;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1Ba;;AAEb,OAAO,UAAU,GAAG,mBAAO,CAAC,mFAAyB;AACrD,OAAO,qCAAqC,GAAG,mBAAO,CAAC,yIAAsC;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtBa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uGAAqB;AAC3D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,mGAAmB;AACvD,OAAO,cAAc,GAAG,mBAAO,CAAC,2FAA0B;;AAE1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvEa;;AAEb,OAAO,MAAM,GAAG,mBAAO,CAAC,2GAAqC;AAC7D,OAAO,UAAU,GAAG,mBAAO,CAAC,mFAAyB;AACrD,OAAO,qBAAqB,GAAG,mBAAO,CAAC,2FAA0B;AACjE,OAAO,gCAAgC,GAAG,mBAAO,CAAC,+EAAuB;AACzE,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,sBAAsB,GAAG,mBAAO,CAAC,iGAAwB;;AAEhE;AACA;AACA;;AAEA;AACA,wCAAwC,6BAA6B;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,KAAK,uBAAuB,IAAI;;AAE3E;AACA,yBAAyB,6DAA6D;AACtF;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,4BAA4B,SAAS,KAAK,iBAAiB;AAC3D;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,kBAAkB;AAC7D;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjIa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uGAAqB;AAC3D,OAAO,uBAAuB,GAAG,mBAAO,CAAC,6GAAwB;AACjE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,+FAAuB;;AAE9D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ca;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,+GAAyB;AACnE,OAAO,cAAc,GAAG,mBAAO,CAAC,6FAAsB;;AAEtD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtDa;;AAEb,OAAO,qCAAqC,GAAG,mBAAO,CAAC,yIAAsC;AAC7F,OAAO,WAAW,GAAG,mBAAO,CAAC,mFAAyB;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,qDAAqD,YAAY;AACjE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxDa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,gHAA0B;AACpE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,kGAA0B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,MAAM;AACpB;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Da;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,uGAAkB;AACrD,OAAO,iBAAiB,GAAG,mBAAO,CAAC,oGAA2B;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,4BAA4B;;AAErD;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClDa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,qHAAyB;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACZa;;AAEb,qBAAqB,mBAAO,CAAC,8FAA6B;;AAE1D,OAAO,iBAAiB,GAAG,mBAAO,CAAC,uGAAkB;AACrD,OAAO,oBAAoB,GAAG,mBAAO,CAAC,kFAA0B;AAChE,OAAO,0BAA0B,GAAG,mBAAO,CAAC,sFAA4B;AACxE,OAAO,sBAAsB,GAAG,mBAAO,CAAC,8FAAgC;AACxE,OAAO,iBAAiB,GAAG,mBAAO,CAAC,4FAA+B;AAClE,OAAO,4BAA4B,GAAG,mBAAO,CAAC,kHAA0C;;AAExF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iCAAiC;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,OAAO;AAC/C;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,iDAAiD,aAAa,kBAAkB,cAAc;AAC9F,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ma;;AAEb,gBAAgB,mBAAO,CAAC,2GAAmB;AAC3C,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;;AAE9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1Ba;;AAEb,gBAAgB,mBAAO,CAAC,2GAAmB;AAC3C,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;;AAE9F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjCa;;AAEb,gBAAgB,mBAAO,CAAC,2GAAmB;AAC3C,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;;AAE9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1Ba;;AAEb,eAAe,mBAAO,CAAC,wGAAqC;AAC5D,OAAO,8BAA8B,GAAG,mBAAO,CAAC,sFAA4B;;AAE5E;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,WAAW,qCAAqC,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,yBAAyB,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA,kEAAkE,oCAAoC;AACtG,uDAAuD,yCAAyC;AAChG;AACA;AACA,eAAe,8EAA8E;AAC7F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB,GAAG,UAAU,EAAE,EAAE,UAAU;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,YAAY,eAAe,GAAG,6BAA6B,GAAG,oBAAoB;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,aAAa,eAAe,GAAG,KAAK,GAAG,mBAAmB,GAAG,aAAa;AAC1E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClKa;;AAEb,OAAO,UAAU,GAAG,mBAAO,CAAC,sFAA4B;AACxD,OAAO,YAAY,GAAG,mBAAO,CAAC,8FAAa;AAC3C,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;;AAE9F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjEa;;AAEb,OAAO,qBAAqB,GAAG,mBAAO,CAAC,sFAA4B;;AAEnE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1Ha;;AAEb,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;AAC9F,OAAO,+BAA+B,GAAG,mBAAO,CAAC,sFAA4B;AAC7E,OAAO,gBAAgB,GAAG,mBAAO,CAAC,4FAA+B;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,4BAA4B,8BAA8B;AAC1D,qBAAqB,SAAS,uCAAuC;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjHa;;AAEb,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;AAC9F,OAAO,qBAAqB,GAAG,mBAAO,CAAC,sFAA4B;AACnE,OAAO,qBAAqB,GAAG,mBAAO,CAAC,kFAA0B;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,eAAe;;AAEf;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Fa;;AAEb,OAAO,qCAAqC,GAAG,mBAAO,CAAC,0IAAuC;AAC9F,OAAO,qBAAqB,GAAG,mBAAO,CAAC,kFAA0B;AACjE,OAAO,WAAW,GAAG,mBAAO,CAAC,sFAA4B;;AAEzD;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;;AAE1B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvGa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,qBAAqB;AACpC;AACA;;AAEA;;AAEA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB;AACrB,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA,cAAc;AACd,KAAK;AACL;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACx3BA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,qBAAqB;AACpC;AACA;;AAEA;;AAEA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB;AACrB,8BAA8B,wBAAwB;AACtD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACthCa;;AAEb,OAAO,mBAAmB,GAAG,mBAAO,CAAC,uFAAoB;AACzD,uBAAuB,mBAAO,CAAC,oEAAgB;;AAE/C,OAAO,wBAAwB,GAAG,mBAAO,CAAC,iGAAyB;AACnE,OAAO,0BAA0B,GAAG,mBAAO,CAAC,qGAA2B;AACvE,OAAO,0BAA0B,GAAG,mBAAO,CAAC,qGAA2B;AACvE,OAAO,4BAA4B,GAAG,mBAAO,CAAC,yGAA6B;;AAE3E,OAAO,MAAM,GAAG,mBAAO,CAAC,wGAAkC;AAC1D,OAAO,eAAe,GAAG,mBAAO,CAAC,8EAAqB;AACtD,OAAO,eAAe,GAAG,mBAAO,CAAC,kFAAuB;AACxD,OAAO,kBAAkB,GAAG,mBAAO,CAAC,gFAAsB;AAC1D,OAAO,oBAAoB,GAAG,mBAAO,CAAC,wFAAuB;AAC7D,OAAO,iBAAiB,GAAG,mBAAO,CAAC,sFAAyB;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,0BAA0B,oBAAoB,UAAU,IAAI,QAAQ;AAC9F,KAAK;AACL,0BAA0B,sBAAsB,IAAI,QAAQ;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,6BAA6B,oBAAoB;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kGAAkG,uDAAuD;AACzJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B,yBAAyB;AACtD;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,WAAW,SAAS;AACpB;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,6BAA6B,SAAS;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,6BAA6B,eAAe;AAC5C;;AAEA;AACA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,cAAc,UAAU,MAAM,MAAM;AACpC;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACraa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,4HAA4C;;AAEhF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvBa;;AAEb,OAAO,gBAAgB,GAAG,mBAAO,CAAC,wHAA0C;AAC5E,OAAO,SAAS,GAAG,mBAAO,CAAC,gFAAsB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtJa;;AAEb,OAAO,QAAQ,GAAG,mBAAO,CAAC,wFAAuB;AACjD,OAAO,kBAAkB,GAAG,mBAAO,CAAC,4HAA4C;;AAEhF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClCa;;AAEb,OAAO,sCAAsC,GAAG,mBAAO,CAAC,gFAAsB;AAC9E,OAAO,iBAAiB,GAAG,mBAAO,CAAC,wGAAkC;AACrE,OAAO,6BAA6B,GAAG,mBAAO,CAAC,gFAAsB;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChPa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,wIAAkD;;AAE5F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClCa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,4HAA4C;;AAEhF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvBa;;AAEb,OAAO,0BAA0B,GAAG,mBAAO,CAAC,sGAA4B;;AAExE;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClBa;;AAEb,OAAO,0BAA0B,GAAG,mBAAO,CAAC,sGAA4B;AACxE,OAAO,QAAQ,GAAG,mBAAO,CAAC,2FAA0B;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yCAAyC,OAAO;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChDa;;AAEb,OAAO,eAAe,GAAG,mBAAO,CAAC,qFAA0B;AAC3D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,+HAA+C;;AAEnF;AACA;AACA;AACA,iEAAiE,oBAAoB;;AAErF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxCa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,wEAAa;AAC1C,OAAO,8BAA8B,GAAG,mBAAO,CAAC,0HAA+B;AAC/E,OAAO,8BAA8B,GAAG,mBAAO,CAAC,0HAA+B;AAC/E,OAAO,8BAA8B,GAAG,mBAAO,CAAC,0HAA+B;AAC/E,OAAO,gCAAgC,GAAG,mBAAO,CAAC,8HAAiC;;AAEnF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;ACpDa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,mIAAiD;;AAEvF;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvCa;;AAEb,OAAO,0BAA0B,GAAG,mBAAO,CAAC,sGAA4B;AACxE,OAAO,QAAQ,GAAG,mBAAO,CAAC,2FAA0B;;AAEpD;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD;;AAEA,4CAA4C,QAAQ;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtCa;;AAEb,OAAO,eAAe,GAAG,mBAAO,CAAC,qFAA0B;AAC3D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,+HAA+C;;AAEnF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpCa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,wEAAa;AAC1C,OAAO,yBAAyB,GAAG,mBAAO,CAAC,2GAA0B;AACrE,OAAO,yBAAyB,GAAG,mBAAO,CAAC,2GAA0B;AACrE,OAAO,2BAA2B,GAAG,mBAAO,CAAC,+GAA4B;;AAEzE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;AChDa;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,mIAAiD;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7Ba;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,sGAA4B;;AAEhE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACZa;;AAEb,OAAO,qBAAqB,GAAG,mBAAO,CAAC,kHAAkC;;AAEzE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACZa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qDAAqD,WAAW;;AAEhE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChGa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,4GAAyB;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,uBAAuB,mBAAO,CAAC,uEAAmB;AAClD,OAAO,WAAW,GAAG,mBAAO,CAAC,wEAAa;AAC1C,OAAO,mBAAmB,GAAG,mBAAO,CAAC,wFAAqB;;AAE1D,OAAO,MAAM,GAAG,mBAAO,CAAC,2GAAqC;AAC7D,OAAO,oBAAoB,GAAG,mBAAO,CAAC,+EAAuB;AAC7D,OAAO,eAAe,GAAG,mBAAO,CAAC,qFAA0B;AAC3D,OAAO,eAAe,GAAG,mBAAO,CAAC,qFAA0B;AAC3D,OAAO,oBAAoB,GAAG,mBAAO,CAAC,2FAA0B;AAChE,OAAO,uBAAuB,GAAG,mBAAO,CAAC,mFAAyB;;AAElE,OAAO,0BAA0B,GAAG,mBAAO,CAAC,0HAAgC;AAC5E,OAAO,4BAA4B,GAAG,mBAAO,CAAC,kIAAoC;AAClF,OAAO,4BAA4B,GAAG,mBAAO,CAAC,kIAAoC;;AAElF,OAAO,8BAA8B,GAAG,mBAAO,CAAC,0IAAwC;AACxF,OAAO,mCAAmC,GAAG,mBAAO,CAAC,oJAA6C;AAClG;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,sJAA8C;;AAE1D,OAAO,4BAA4B,GAAG,mBAAO,CAAC,kIAAoC;AAClF,OAAO,iCAAiC,GAAG,mBAAO,CAAC,4IAAyC;AAC5F,OAAO,kCAAkC,GAAG,mBAAO,CAAC,8IAA0C;;AAE9F,OAAO,4BAA4B,GAAG,mBAAO,CAAC,kIAAoC;AAClF,OAAO,iCAAiC,GAAG,mBAAO,CAAC,4IAAyC;AAC5F,OAAO,kCAAkC,GAAG,mBAAO,CAAC,8IAA0C;;AAE9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,OAAO;AACvD;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,uBAAuB,cAAc;AACrC;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sDAAsD,QAAQ;AAC9D;AACA;;AAEA,wDAAwD,QAAQ;AAChE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,cAAc,UAAU,MAAM,MAAM;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mFAAmF,sDAAsD;AACzI;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,6BAA6B,sBAAsB;AACnD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,WAAW,cAAc;AACzB;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,6BAA6B,kBAAkB;AAC/C;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,6BAA6B,wBAAwB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtgBa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,4GAAyB;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS,GAAG,sBAAsB;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,SAAS,GAAG,sBAAsB;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnCa;;AAEb,OAAO,gCAAgC,GAAG,mBAAO,CAAC,mIAAiC;AACnF,OAAO,6BAA6B,GAAG,mBAAO,CAAC,uHAA+B;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACXa;;AAEb,OAAO,gCAAgC,GAAG,mBAAO,CAAC,mIAAiC;AACnF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,6GAA0B;;AAEpE;;AAEA;AACA;AACA;;;;;;;;;;;;;ACTa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,kIAAkD;;AAEtF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzBa;;AAEb,OAAO,gCAAgC,GAAG,mBAAO,CAAC,mIAAiC;AACnF,OAAO,8BAA8B,GAAG,mBAAO,CAAC,yHAAgC;;AAEhF;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACXa;;AAEb,OAAO,wBAAwB,GAAG,mBAAO,CAAC,qGAA6B;AACvE,OAAO,gBAAgB,GAAG,mBAAO,CAAC,4FAA+B;AACjE,OAAO,SAAS,GAAG,mBAAO,CAAC,sFAA4B;;AAEvD;AACA;AACA;;AAEA;;AAEA,yDAAyD,OAAO;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,wBAAwB,MAAM;;AAE9B;AACA;AACA;AACA,0BAA0B,UAAU,GAAG,mBAAmB,MAAM,eAAe;AAC/E;AACA;;AAEA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,OAAO;AACpD;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxGa;;AAEb,OAAO,0BAA0B,GAAG,mBAAO,CAAC,yGAA+B;AAC3E,OAAO,QAAQ,GAAG,mBAAO,CAAC,8FAA6B;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpDa;;AAEb,OAAO,eAAe,GAAG,mBAAO,CAAC,wFAA6B;AAC9D,OAAO,kBAAkB,GAAG,mBAAO,CAAC,kIAAkD;;AAEtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxCa;;AAEb,OAAO,kCAAkC,GAAG,mBAAO,CAAC,yIAAmC;AACvF,OAAO,6BAA6B,GAAG,mBAAO,CAAC,uHAA+B;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACfa;;AAEb,OAAO,kCAAkC,GAAG,mBAAO,CAAC,yIAAmC;AACvF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,6GAA0B;;AAEpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,OAAO,oBAAoB,GAAG,mBAAO,CAAC,sIAAoD;;AAE1F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,kCAAkC,GAAG,mBAAO,CAAC,yIAAmC;AACvF,OAAO,8BAA8B,GAAG,mBAAO,CAAC,yHAAgC;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACfa;;AAEb,OAAO,gCAAgC,GAAG,mBAAO,CAAC,mIAAiC;AACnF,OAAO,6BAA6B,GAAG,mBAAO,CAAC,uHAA+B;;AAE9E;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACXa;;AAEb,OAAO,gCAAgC,GAAG,mBAAO,CAAC,mIAAiC;AACnF,OAAO,wBAAwB,GAAG,mBAAO,CAAC,6GAA0B;;AAEpE;;AAEA;AACA;AACA;;;;;;;;;;;;;ACTa;;AAEb,OAAO,kBAAkB,GAAG,mBAAO,CAAC,kIAAkD;;AAEtF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Ea;;AAEb,OAAO,gCAAgC,GAAG,mBAAO,CAAC,mIAAiC;AACnF,OAAO,8BAA8B,GAAG,mBAAO,CAAC,yHAAgC;;AAEhF;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACXa;;AAEb,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,OAAO,QAAQ,GAAG,mBAAO,CAAC,mEAAe;AACzC,qBAAqB,mBAAO,CAAC,uFAAsB;AACnD,OAAO,eAAe,GAAG,mBAAO,CAAC,6EAAoB;AACrD,OAAO,aAAa,GAAG,mBAAO,CAAC,+EAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8E;;;;;;;;;;;;ACnEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACjBa;;AAEb,OAAO,uBAAuB,GAAG,mBAAO,CAAC,yEAAe;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACpBa;;AAEb,OAAO,aAAa,GAAG,mBAAO,CAAC,yEAAe;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC/BA,8CAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,KAA0B;;AAE9C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,MAAM;AACnB,aAAa,OAAO,WAAW;AAC/B,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,WAAW;AAC/B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO,WAAW;AAC/B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,EAAE;AACjB;AACA;AACA;AACA,qBAAqB,SAAS,GAAG,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,EAAE;AACjB;AACA;AACA;AACA,qBAAqB,SAAS,GAAG,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA,+BAA+B,kBAAkB,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AChwEY;;AAEb,OAAO,+CAA+C,GAAG,mBAAO,CAAC,yEAAe;;AAEhF,yBAAyB,wCAAwC;AACjE;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,6BAA6B,kCAAkC;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvCa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACda;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,yEAAe;;AAE5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,oDAAoD,KAAK;AAClF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,oBAAoB,KAAK;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mCAAmC,KAAK;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,0CAA0C,OAAO;AACjD;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;;AAEP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtNa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,OAAO,uBAAuB,GAAG,mBAAO,CAAC,gFAAsB;;AAE/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvEa;;AAEb,OAAO,UAAU,GAAG,mBAAO,CAAC,yEAAe;;AAE3C;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,gFAAsB;;AAEnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,YAAY,qBAAqB,GAAG,qBAAqB;AACzD;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,OAAO;AACP;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,+CAA+C,oBAAoB;AACnE;AACA,GAAG;AACH;AACA;AACA;AACA,WAAW;AACX;AACA,YAAY,MAAM,GAAG,UAAU,GAAG,MAAM;AACxC;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA,OAAO;AACP;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,oBAAoB;AACjE;;AAEA;AACA,4CAA4C,oBAAoB,eAAe,UAAU;AACzF;;AAEA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,oBAAoB;AACjE;AACA;;AAEA;AACA,iCAAiC,OAAO;AACxC;;AAEA,mCAAmC,QAAQ;AAC3C;;AAEA;AACA;AACA,yBAAyB,oBAAoB,oBAAoB,wBAAwB;AACzF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC/Ia;;AAEb,OAAO,mBAAmB,GAAG,mBAAO,CAAC,6DAAS;AAC9C;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,OAAO;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClYa;;AAEb,kCAAkC,mBAAO,CAAC,0IAAmD;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClDa;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,kFAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChBa;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,kFAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AChBa;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,kFAAa;AAC3C,OAAO,QAAQ,GAAG,mBAAO,CAAC,0EAAS;AACnC,OAAO,cAAc,GAAG,mBAAO,CAAC,sFAAe;AAC/C,OAAO,oBAAoB,GAAG,mBAAO,CAAC,kGAAqB;AAC3D,OAAO,aAAa,GAAG,mBAAO,CAAC,sEAAO;AACtC,OAAO,aAAa,GAAG,mBAAO,CAAC,sEAAO;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBa;;AAEb,OAAO,uBAAuB,GAAG,mBAAO,CAAC,0EAAgB;;AAEzD;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,kFAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3Ga;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,kFAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5Ba;;AAEb,OAAO,YAAY,GAAG,mBAAO,CAAC,kFAAa;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrBa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,OAAO,6BAA6B,GAAG,mBAAO,CAAC,gFAAsB;AACrE,OAAO,eAAe,GAAG,mBAAO,CAAC,8EAAqB;;AAEtD,4BAA4B,mBAAO,CAAC,oEAAgB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,yBAAyB,YAAY,IAAI,YAAY;AACrD,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,gDAAgD,SAAS;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+EAAQ,CAAC,EAAE,wBAAwB,CAAC,CAAC;AACjD;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA,8BAA8B,UAAU;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxGa;;AAEb;;AAEA;AACA,YAAY,+BAA+B,EAAE,MAAM;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACfO,MAAMA,KAAK,GAAI;;;;gBAAf;AAMA,MAAMC,IAAI,GAAI;;;;;;;;;;;;;;;;;;;iBAAd,C;;;;;;;;;;;;;;;;;;;;;;;;;;ACNP;AACA;AACA;AACA;AACA;AACA;;AACAC,mBAAO,CAAC,sBAAD,CAAP,CAAkBC,MAAlB;;AAEA,MAAMC,EAAE,GAAGC,2CAAI,CAAC;AACdC,QAAM,EAAE,IADM;AAEdC,YAAU,EAAE;AACVC,QAAI,EAAEC,OAAO,CAACC,GAAR,CAAYC,OADR;AAEVC,QAAI,EAAEH,OAAO,CAACC,GAAR,CAAYG,OAFR;AAGVC,YAAQ,EAAEL,OAAO,CAACC,GAAR,CAAYK,WAHZ;AAIVC,YAAQ,EAAEP,OAAO,CAACC,GAAR,CAAYO;AAJZ;AAFE,CAAD,CAAf;AASAC,+CAAK,CAACC,IAAN,CAAWf,EAAX;AAEA,MAAMgB,MAAM,GAAG,IAAIC,iEAAJ,CAAiB;AAC9BC,6DAD8B;AAE9BC,+DAF8B;AAG9BC,SAAO,EAAE,OAAO;AAAEC;AAAF,GAAP,KAAqB;AAC5B,UAAMC,YAAY,GAAGD,KAAK,CAACE,OAAN,CAAcC,YAAd,IAA8B,EAAnD;AACA,WAAO;AAAExB,QAAF,CACP;AACA;;AAFO,KAAP;AAGD,GAR6B;AAS9B;AACA;AACA;AACAyB,iEAAUA;AAZoB,CAAjB,CAAf;AAeO,MAAMC,cAAc,GAAGV,MAAM,CAACW,aAAP,CAAqB;AACjDC,MAAI,EAAE;AACJC,UAAM,EAAE,IADJ;AAEJC,eAAW,EAAE;AAFT;AAD2C,CAArB,CAAvB,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClCP;AAEO,MAAMC,UAAN,SAAyBjB,+CAAzB,CAA+B;AACpC,aAAWkB,SAAX,GAAwB;AACtB,WAAO,aAAP;AACD;;AAEDC,UAAQ,GAAI;AACV,WAAO,KAAKC,UAAL,GAAkB,GAAlB,GAAwB,KAAKC,SAApC;AACD;;AAED,aAAWC,gBAAX,GAA+B;AAC7B,WAAO;AAAEC,2BAAqB,EAAE;AAC9BC,gBAAQ,EAAExB,+CAAK,CAACyB,eADc;AAE9BC,kBAAU,EAAEC,kBAFkB;AAG9BC,YAAI,EAAE;AACJC,cAAI,EAAE,gBADF;AAEJC,YAAE,EAAE;AAFA;AAHwB,OAAzB;AAQPC,yBAAmB,EAAE;AACnBP,gBAAQ,EAAExB,+CAAK,CAACyB,eADG;AAEnBC,kBAAU,EAAEM,iBAFO;AAGnBJ,YAAI,EAAE;AACJC,cAAI,EAAE,gBADF;AAEJC,YAAE,EAAE;AAFA;AAHa;AARd,KAAP;AAgBD;;AA1BmC;AA6B/B,MAAMH,kBAAN,SAAiC3B,+CAAjC,CAAuC;AAC5C,aAAWkB,SAAX,GAAwB;AACtB,WAAO,uBAAP;AACD;;AAH2C;AAMvC,MAAMc,iBAAN,SAAgChC,+CAAhC,CAAsC;AAC3C,aAAWkB,SAAX,GAAwB;AACtB,WAAO,qBAAP;AACD;;AAH0C,C;;;;;;;;;;;ACrC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrBA;AAEe;AACbe,MAAI,EAAE,CACJvC,6CAAI,CAACwC,KADD,EAEJxC,6CAAI,CAACyC,QAFD;AADO,CAAf,E;;;;;;;;;;;;;;;;;ACFA;AACe;AACbD,OAAK,EAAE;AACLE,QAAI,EAAE,cADD;AAELC,YAAQ,EAAE,EAFL;AAGL5B,WAAO,EAAE;AAAEC,kBAAY,EAAE;AAAhB,KAHJ;AAIL4B,SAAK,EAAG;;;UAGFvD,+CAAK;;;AAPN,GADM;AAYboD,UAAQ,EAAE;AACRC,QAAI,EAAE,gBADE;AAERC,YAAQ,EAAE,EAFF;AAGR5B,WAAO,EAAE;AAAEC,kBAAY,EAAE;AAAhB,KAHD;AAIR4B,SAAK,EAAG;;;UAGFxD,gDAAM;;;;AAPJ;AAZG,CAAf,E;;;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AAEe,iEACb,GAAGyD,mDAAK,CACN7C,6CADM,CADK;AAIb8C,MAAI,EAAE,IAAIC,yDAAJ,CAAsB;AAC1BL,QAAI,EAAE,MADoB;AAE1BM,eAAW,EAAE,yBAFa;;AAG1BC,cAAU,CAAEC,KAAF,EAAS;AACjB,aAAO,IAAIJ,IAAJ,CAASI,KAAT,CAAP;AACD,KALyB;;AAM1BC,aAAS,CAAED,KAAF,EAAS;AAChB,aAAO,IAAIJ,IAAJ,CAASI,KAAT,EAAgBE,OAAhB,EAAP;AACD,KARyB;;AAS1BC,gBAAY,CAAEC,GAAF,EAAO;AACjB,UAAIA,GAAG,CAACC,IAAJ,KAAaC,qDAAI,CAACC,GAAtB,EAA2B;AACzB,eAAOC,QAAQ,CAACJ,GAAG,CAACJ,KAAL,EAAY,EAAZ,CAAf;AACD;;AACD,aAAO,IAAP;AACD;;AAdyB,GAAtB;AAJO,CAAf,E;;;;;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AAEe;AACbV,OAAK,EAAE;AACLmB,WAAO,EAAE,OAAOC,CAAP,EAAUC,EAAV,KAAiBtC,kDAAU,CAACqB,KAAX,GAAmBkB,QAAnB,CAA4B,GAA5B;AADrB,GADM;AAIbrB,UAAQ,EAAE;AACRsB,SAAK,EAAE,OAAOH,CAAP,EAAU;AAAEI,cAAF;AAAY9D;AAAZ,KAAV,KAAqC;AAC1C,YAAMF,IAAI,GAAG,MAAMuB,kDAAU,CAACqB,KAAX,GAAmBqB,KAAnB,CAAyB,UAAzB,EAAqCD,QAArC,EAA+CE,KAA/C,EAAnB;AACA,UAAI,CAAClE,IAAL,EAAW,MAAM,IAAImE,wEAAJ,CAAwB,gBAAxB,CAAN;AACX,UAAI,CAACnE,IAAI,CAACoE,UAAV,EAAsB,MAAM,IAAID,wEAAJ,CAAwB,qBAAxB,CAAN;AACtB,YAAM;AAAEE,WAAG,EAAEC,UAAP;AAAmBC,iBAAS,EAAEC;AAA9B,UAA2CxE,IAAjD;AACA,YAAM;AAAEyE;AAAF,UAAqBC,sDAAQ,CAACxE,QAAD,EAAWsE,QAAX,CAAnC;AACA,UAAIF,UAAU,KAAKG,cAAnB,EAAmC,MAAM,IAAIN,wEAAJ,CAAwB,wBAAxB,CAAN;AAEnC,YAAMQ,OAAO,GAAG,MAAM3E,IAAI,CAAC4E,aAAL,CAAmB,uBAAnB,EAA4CC,GAA5C,CAAgDC,IAAI,IAAIA,IAAI,CAACC,cAA7D,CAAtB;AAEA,YAAMC,OAAO,GAAG,MAAMhF,IAAI,CAAC4E,aAAL,CAAmB,qBAAnB,EAA0CX,KAA1C,CAAgD,aAAhD,EAA+D,IAA/D,EAAqEC,KAArE,EAAtB;AACA,YAAMpD,YAAY,GAAGmE,6CAAM,CAACC,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,QAAhC,CAArB;AACA,YAAMC,cAAc,GAAG,IAAItC,IAAJ,EAAvB;AACAsC,oBAAc,CAACC,QAAf,CAAwBD,cAAc,CAACE,QAAf,KAA4B,CAApD;AACA,UAAIN,OAAJ,EAAa,MAAMhF,IAAI,CAAC4E,aAAL,CAAmB,qBAAnB,EAA0CW,KAA1C,CAAgD;AAAEC,mBAAW,EAAE,IAAI1C,IAAJ;AAAf,OAAhD,EAA6EmB,KAA7E,CAAmF,aAAnF,EAAkG,IAAlG,CAAN;AACb,YAAMjE,IAAI,CAAC4E,aAAL,CAAmB,qBAAnB,EAA0Ca,MAA1C,CAAiD;AACrDC,sBAAc,EAAE1F,IAAI,CAAC2F,EADgC;AAErDC,qBAAa,EAAE9E,YAFsC;AAGrD+E,qBAAa,EAAE,IAAI/C,IAAJ,EAHsC;AAIrD0C,mBAAW,EAAE,IAJwC;AAKrDM,4BAAoB,EAAE,IAL+B;AAMrDC,oBAAY,EAAE,IANuC;AAOrDC,0BAAkB,EAAE,IAAIlD,IAAJ,CAASsC,cAAT,CAPiC;AAQrDa,oBAAY,EAAE,IARuC;AASrDC,eAAO,EAAE,IAAIpD,IAAJ,EAT4C;AAUrDqD,gBAAQ,EAAE,IAAIrD,IAAJ;AAV2C,OAAjD,CAAN;AAaA,aAAO;AACLsD,mBAAW,EAAEpG,IAAI,CAACyB,QAAL,EADR;AAEL4E,gBAAQ,EAAErG,IAAI,CAACsG,SAFV;AAGLC,0BAAkB,EAAEvG,IAAI,CAACwG,oBAHpB;AAIL1F,oBAJK;AAKL6D;AALK,OAAP;AAOD,KApCO;AAqCR8B,UAAM,EAAE,OAAO7C,CAAP,EAAU;AAAE9C;AAAF,KAAV,KAA+B;AACrC,YAAMkE,OAAO,GAAG,MAAM1C,yDAAiB,CAACM,KAAlB,GAA0BqB,KAA1B,CAAgC,eAAhC,EAAiDnD,YAAjD,EAA+DmD,KAA/D,CAAqE,aAArE,EAAoF,IAApF,EAA0FC,KAA1F,EAAtB;AACA,UAAI,CAACc,OAAL,EAAc,MAAM,IAAIb,wEAAJ,CAAwB,wBAAxB,CAAN;AACd,YAAM7B,yDAAiB,CAACM,KAAlB,GAA0B2C,KAA1B,CAAgC;AAAEC,mBAAW,EAAE,IAAI1C,IAAJ;AAAf,OAAhC,EAA6DmB,KAA7D,CAAmE,eAAnE,EAAoFnD,YAApF,EAAkGmD,KAAlG,CAAwG,aAAxG,EAAuH,IAAvH,CAAN;AACD;AAzCO;AAJG,CAAf,E;;;;;;;;;;;;;;;;;;;ACLA;AACA;AAEeyC,uHAAI;;IAEf1G,6CAAK;;;;;;;CAFT,E;;;;;;;;;;;;;;;;ACHgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAhB,E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEO,MAAM0E,QAAQ,GAAG,CAACxE,QAAD,EAAWyG,IAAI,GAAG,IAAlB,KAA2B;AACjD,QAAMC,UAAU,GAAGD,IAAI,IAAI1B,6CAAM,CAACC,WAAP,CAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,QAAhC,CAA3B;AACA,QAAMV,cAAc,GAAGQ,6CAAM,CAAC4B,UAAP,CAAkB,QAAlB,EACpBC,MADoB,CACb5G,QADa,EAEpB4G,MAFoB,CAEbF,UAFa,EAED,QAFC,EAGpBG,MAHoB,CAGb,QAHa,CAAvB;AAIA,SAAO;AACLH,cADK;AAELnC;AAFK,GAAP;AAID,CAVM,C;;;;;;;;;;;ACFP,gC;;;;;;;;;;;ACAA,iD;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,6C;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,wD","file":"handler.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./handler.js\");\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = merge;\n","'use strict';\n\nconst { Validator } = require('./Validator');\nconst { ValidationErrorType } = require('../model/ValidationError');\nconst { isObject, once, cloneDeep: lodashCloneDeep, omit } = require('../utils/objectUtils');\n\nconst getAjv = once(() => {\n  try {\n    return require('ajv');\n  } catch (err) {\n    throw new Error('Optional ajv dependency not installed. Please run `npm install ajv --save`');\n  }\n});\n\nclass AjvValidator extends Validator {\n  static init(self, conf) {\n    super.init(self, conf);\n\n    self.ajvOptions = Object.assign({ errorDataPath: 'property' }, conf.options, {\n      allErrors: true\n    });\n\n    // Create a normal Ajv instance.\n    self.ajv = new getAjv()(\n      Object.assign(\n        {\n          useDefaults: true\n        },\n        self.ajvOptions\n      )\n    );\n\n    // Create an instance that doesn't set default values. We need this one\n    // to validate `patch` objects (objects that have a subset of properties).\n    self.ajvNoDefaults = new getAjv()(\n      Object.assign({}, self.ajvOptions, {\n        useDefaults: false\n      })\n    );\n\n    // A cache for the compiled validator functions.\n    self.cache = new Map();\n\n    conf.onCreateAjv(self.ajv);\n    conf.onCreateAjv(self.ajvNoDefaults);\n  }\n\n  beforeValidate({ json, model, options, ctx }) {\n    ctx.jsonSchema = model.constructor.getJsonSchema();\n\n    // Objection model's have a `$beforeValidate` hook that is allowed to modify the schema.\n    // We need to clone the schema in case the function modifies it. We only do this in the\n    // rare case that the given model has implemented the hook.\n    if (model.$beforeValidate !== model.$objectionModelClass.prototype.$beforeValidate) {\n      ctx.jsonSchema = cloneDeep(ctx.jsonSchema);\n      const ret = model.$beforeValidate(ctx.jsonSchema, json, options);\n\n      if (ret !== undefined) {\n        ctx.jsonSchema = ret;\n      }\n    }\n  }\n\n  validate({ json, model, options, ctx }) {\n    if (!ctx.jsonSchema) {\n      return json;\n    }\n\n    const modelClass = model.constructor;\n    const validator = this.getValidator(modelClass, ctx.jsonSchema, !!options.patch);\n\n    // We need to clone the input json if we are about to set default values.\n    if (!options.mutable && !options.patch && setsDefaultValues(ctx.jsonSchema)) {\n      json = cloneDeep(json);\n    }\n\n    validator.call(model, json);\n    const error = parseValidationError(validator.errors, modelClass, options);\n\n    if (error) {\n      throw error;\n    }\n\n    return json;\n  }\n\n  getValidator(modelClass, jsonSchema, isPatchObject) {\n    // Use the AJV custom serializer if provided.\n    const createCacheKey = this.ajvOptions.serialize || JSON.stringify;\n\n    // Optimization for the common case where jsonSchema is never modified.\n    // In that case we don't need to call the costly createCacheKey function.\n    const cacheKey =\n      jsonSchema === modelClass.getJsonSchema()\n        ? modelClass.uniqueTag()\n        : createCacheKey(jsonSchema);\n\n    let validators = this.cache.get(cacheKey);\n    let validator = null;\n\n    if (!validators) {\n      validators = {\n        // Validator created for the schema object without `required` properties\n        // using the AJV instance that doesn't set default values.\n        patchValidator: null,\n\n        // Validator created for the unmodified schema.\n        normalValidator: null\n      };\n\n      this.cache.set(cacheKey, validators);\n    }\n\n    if (isPatchObject) {\n      validator = validators.patchValidator;\n\n      if (!validator) {\n        validator = this.compilePatchValidator(jsonSchema);\n        validators.patchValidator = validator;\n      }\n    } else {\n      validator = validators.normalValidator;\n\n      if (!validator) {\n        validator = this.compileNormalValidator(jsonSchema);\n        validators.normalValidator = validator;\n      }\n    }\n\n    return validator;\n  }\n\n  compilePatchValidator(jsonSchema) {\n    jsonSchema = jsonSchemaWithoutRequired(jsonSchema);\n    // We need to use the ajv instance that doesn't set the default values.\n    return this.ajvNoDefaults.compile(jsonSchema);\n  }\n\n  compileNormalValidator(jsonSchema) {\n    return this.ajv.compile(jsonSchema);\n  }\n}\n\nfunction parseValidationError(errors, modelClass, options) {\n  if (!errors) {\n    return null;\n  }\n\n  let relationNames = modelClass.getRelationNames();\n  let errorHash = {};\n  let numErrors = 0;\n\n  for (const error of errors) {\n    const dataPath = `${options.dataPath || ''}${error.dataPath}`;\n\n    // If additionalProperties = false, relations can pop up as additionalProperty\n    // errors. Skip those.\n    if (\n      error.params &&\n      error.params.additionalProperty &&\n      relationNames.includes(error.params.additionalProperty)\n    ) {\n      continue;\n    }\n\n    // Unknown properties are reported in `['propertyName']` notation,\n    // so replace those with dot-notation, see:\n    // https://github.com/epoberezkin/ajv/issues/671\n    const key = dataPath.replace(/\\['([^' ]*)'\\]/g, '.$1').substring(1);\n\n    // More than one error can occur for the same key in Ajv, merge them in the array:\n    const array = errorHash[key] || (errorHash[key] = []);\n\n    // Use unshift instead of push so that the last error ends up at [0],\n    // preserving previous behavior where only the last error was stored.\n    array.unshift({\n      message: error.message,\n      keyword: error.keyword,\n      params: error.params\n    });\n\n    ++numErrors;\n  }\n\n  if (numErrors === 0) {\n    return null;\n  }\n\n  return modelClass.createValidationError({\n    type: ValidationErrorType.ModelValidation,\n    data: errorHash\n  });\n}\n\nfunction cloneDeep(obj) {\n  if (isObject(obj) && obj.$isObjectionModel) {\n    return obj.$clone();\n  } else {\n    return lodashCloneDeep(obj);\n  }\n}\n\nfunction setsDefaultValues(jsonSchema) {\n  return jsonSchema && jsonSchema.properties && hasDefaults(jsonSchema.properties);\n}\n\nfunction hasDefaults(obj) {\n  if (Array.isArray(obj)) {\n    return arrayHasDefaults(obj);\n  } else {\n    return objectHasDefaults(obj);\n  }\n}\n\nfunction arrayHasDefaults(arr) {\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    const val = arr[i];\n\n    if (isObject(val) && hasDefaults(val)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction objectHasDefaults(obj) {\n  const keys = Object.keys(obj);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (key === 'default') {\n      return true;\n    } else {\n      const val = obj[key];\n\n      if (isObject(val) && hasDefaults(val)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction jsonSchemaWithoutRequired(jsonSchema) {\n  const subSchemaProps = ['anyOf', 'oneOf', 'allOf', 'not', 'then', 'else'];\n\n  return Object.assign(\n    omit(jsonSchema, ['required', ...subSchemaProps]),\n    ...subSchemaProps.map(prop => subSchemaWithoutRequired(jsonSchema, prop))\n  );\n}\n\nfunction subSchemaWithoutRequired(jsonSchema, prop) {\n  if (jsonSchema[prop]) {\n    if (Array.isArray(jsonSchema[prop])) {\n      const schemaArray = jsonSchemaArrayWithoutRequired(jsonSchema[prop]);\n\n      if (schemaArray.length !== 0) {\n        return {\n          [prop]: schemaArray\n        };\n      } else {\n        return {};\n      }\n    } else {\n      return {\n        [prop]: jsonSchemaWithoutRequired(jsonSchema[prop])\n      };\n    }\n  } else {\n    return {};\n  }\n}\n\nfunction jsonSchemaArrayWithoutRequired(jsonSchemaArray) {\n  return jsonSchemaArray.map(jsonSchemaWithoutRequired).filter(isNotEmptyObject);\n}\n\nfunction isNotEmptyObject(obj) {\n  return Object.keys(obj).length !== 0;\n}\n\nmodule.exports = {\n  AjvValidator\n};\n","'use strict';\n\nconst { clone } = require('./modelClone');\nconst { bindKnex } = require('./modelBindKnex');\nconst { validate } = require('./modelValidate');\nconst { isMsSql } = require('../utils/knexUtils');\nconst { omit, pick } = require('./modelFilter');\nconst { visitModels } = require('./modelVisitor');\nconst { hasId, getSetId } = require('./modelId');\nconst { map: promiseMap } = require('../utils/promiseUtils');\nconst { toJson, toDatabaseJson } = require('./modelToJson');\nconst { values, propKey, hasProps } = require('./modelValues');\nconst { defineNonEnumerableProperty } = require('./modelUtils');\nconst { parseRelationsIntoModelInstances } = require('./modelParseRelations');\nconst { fetchTableMetadata, tableMetadata } = require('./modelTableMetadata');\nconst { asArray, isFunction, isString, asSingle } = require('../utils/objectUtils');\nconst { setJson, setFast, setRelated, appendRelated, setDatabaseJson } = require('./modelSet');\nconst {\n  getJsonAttributes,\n  parseJsonAttributes,\n  formatJsonAttributes\n} = require('./modelJsonAttributes');\nconst { columnNameToPropertyName, propertyNameToColumnName } = require('./modelColPropMap');\n\nconst { raw } = require('../queryBuilder/RawBuilder');\nconst { ref } = require('../queryBuilder/ReferenceBuilder');\n\nconst { AjvValidator } = require('./AjvValidator');\nconst { QueryBuilder } = require('../queryBuilder/QueryBuilder');\nconst { NotFoundError } = require('./NotFoundError');\nconst { ValidationError } = require('./ValidationError');\nconst { ModifierNotFoundError } = require('./ModifierNotFoundError');\nconst { RelationProperty } = require('../relations/RelationProperty');\n\nconst { HasOneRelation } = require('../relations/hasOne/HasOneRelation');\nconst { HasManyRelation } = require('../relations/hasMany/HasManyRelation');\nconst { ManyToManyRelation } = require('../relations/manyToMany/ManyToManyRelation');\nconst { BelongsToOneRelation } = require('../relations/belongsToOne/BelongsToOneRelation');\nconst { HasOneThroughRelation } = require('../relations/hasOneThrough/HasOneThroughRelation');\n\nconst { InstanceFindOperation } = require('../queryBuilder/operations/InstanceFindOperation');\nconst { InstanceInsertOperation } = require('../queryBuilder/operations/InstanceInsertOperation');\nconst { InstanceUpdateOperation } = require('../queryBuilder/operations/InstanceUpdateOperation');\nconst { InstanceDeleteOperation } = require('../queryBuilder/operations/InstanceDeleteOperation');\n\nclass Model {\n  $id(maybeId) {\n    return getSetId(this, maybeId);\n  }\n\n  $hasId() {\n    return hasId(this);\n  }\n\n  $hasProps(props) {\n    return hasProps(this, props);\n  }\n\n  $query(trx) {\n    const modelClass = this.constructor;\n\n    return modelClass\n      .query(trx)\n      .findOperationFactory(() => {\n        return new InstanceFindOperation('find', { instance: this });\n      })\n      .insertOperationFactory(() => {\n        return new InstanceInsertOperation('insert', { instance: this });\n      })\n      .updateOperationFactory(() => {\n        return new InstanceUpdateOperation('update', { instance: this });\n      })\n      .patchOperationFactory(() => {\n        return new InstanceUpdateOperation('patch', {\n          instance: this,\n          modelOptions: { patch: true }\n        });\n      })\n      .deleteOperationFactory(() => {\n        return new InstanceDeleteOperation('delete', { instance: this });\n      })\n      .relateOperationFactory(() => {\n        throw new Error('`relate` makes no sense in this context');\n      })\n      .unrelateOperationFactory(() => {\n        throw new Error('`unrelate` makes no sense in this context');\n      });\n  }\n\n  $relatedQuery(relationName, trx) {\n    const modelClass = this.constructor;\n    const relation = modelClass.getRelation(relationName);\n    const RelatedModelClass = relation.relatedModelClass;\n\n    return RelatedModelClass.query(trx)\n      .findOperationFactory(builder => {\n        const operation = relation.find(builder, [this]);\n        operation.assignResultToOwner = this.constructor.relatedFindQueryMutates;\n        return operation;\n      })\n      .insertOperationFactory(builder => {\n        const operation = relation.insert(builder, this);\n        operation.assignResultToOwner = this.constructor.relatedInsertQueryMutates;\n        return operation;\n      })\n      .updateOperationFactory(builder => {\n        return relation.update(builder, this);\n      })\n      .patchOperationFactory(builder => {\n        return relation.patch(builder, this);\n      })\n      .deleteOperationFactory(builder => {\n        return relation.delete(builder, this);\n      })\n      .relateOperationFactory(builder => {\n        return relation.relate(builder, this);\n      })\n      .unrelateOperationFactory(builder => {\n        return relation.unrelate(builder, this);\n      });\n  }\n\n  $loadRelated(relationExpression, modifiers, trx) {\n    return this.constructor.loadRelated(this, relationExpression, modifiers, trx);\n  }\n\n  $beforeValidate(jsonSchema, json, options) {\n    /* istanbul ignore next */\n    return jsonSchema;\n  }\n\n  $validate(json, options) {\n    return validate(this, json, options);\n  }\n\n  $afterValidate(json, options) {\n    // Do nothing by default.\n  }\n\n  $parseDatabaseJson(json) {\n    const columnNameMappers = this.constructor.getColumnNameMappers();\n\n    if (columnNameMappers) {\n      json = columnNameMappers.parse(json);\n    }\n\n    return parseJsonAttributes(json, this.constructor);\n  }\n\n  $formatDatabaseJson(json) {\n    const columnNameMappers = this.constructor.getColumnNameMappers();\n\n    json = formatJsonAttributes(json, this.constructor);\n\n    if (columnNameMappers) {\n      json = columnNameMappers.format(json);\n    }\n\n    return json;\n  }\n\n  $parseJson(json, options) {\n    return json;\n  }\n\n  $formatJson(json) {\n    return json;\n  }\n\n  $setJson(json, options) {\n    return setJson(this, json, options);\n  }\n\n  $setDatabaseJson(json) {\n    return setDatabaseJson(this, json);\n  }\n\n  $set(obj) {\n    return setFast(this, obj);\n  }\n\n  $setRelated(relation, models) {\n    return setRelated(this, relation, models);\n  }\n\n  $appendRelated(relation, models) {\n    return appendRelated(this, relation, models);\n  }\n\n  $toJson(opt) {\n    return toJson(this, opt);\n  }\n\n  toJSON(opt) {\n    return this.$toJson(opt);\n  }\n\n  $toDatabaseJson(builder) {\n    return toDatabaseJson(this, builder);\n  }\n\n  $beforeInsert(queryContext) {\n    // Do nothing by default.\n  }\n\n  $afterInsert(queryContext) {\n    // Do nothing by default.\n  }\n\n  $beforeUpdate(opt, queryContext) {\n    // Do nothing by default.\n  }\n\n  $afterUpdate(opt, queryContext) {\n    // Do nothing by default.\n  }\n\n  // TODO: Deprecate & remove in 3.0\n  $afterGet(queryContext) {\n    // Do nothing by default.\n  }\n\n  $afterFind(queryContext) {\n    // Do nothing by default.\n  }\n\n  $beforeDelete(queryContext) {\n    // Do nothing by default.\n  }\n\n  $afterDelete(queryContext) {\n    // Do nothing by default.\n  }\n\n  $omit(...args) {\n    return omit(this, args);\n  }\n\n  $pick(...args) {\n    return pick(this, args);\n  }\n\n  $values(props) {\n    return values(this, props);\n  }\n\n  $propKey(props) {\n    return propKey(this, props);\n  }\n\n  $idKey() {\n    return this.$propKey(this.constructor.getIdPropertyArray());\n  }\n\n  $clone(opt) {\n    return clone(this, !!(opt && opt.shallow), false);\n  }\n\n  $traverse(filterConstructor, callback) {\n    if (callback === undefined) {\n      callback = filterConstructor;\n      filterConstructor = null;\n    }\n\n    this.constructor.traverse(filterConstructor, this, callback);\n    return this;\n  }\n\n  $traverseAsync(filterConstructor, callback) {\n    if (callback === undefined) {\n      callback = filterConstructor;\n      filterConstructor = null;\n    }\n\n    return this.constructor.traverseAsync(filterConstructor, this, callback);\n  }\n\n  $omitFromJson(props) {\n    if (arguments.length === 0) {\n      return this.$$omitFromJson;\n    } else {\n      if (!this.hasOwnProperty('$$omitFromJson')) {\n        defineNonEnumerableProperty(this, '$$omitFromJson', props);\n      } else {\n        this.$$omitFromJson = this.$$omitFromJson.concat(props);\n      }\n    }\n  }\n\n  $omitFromDatabaseJson(props) {\n    if (arguments.length === 0) {\n      return this.$$omitFromDatabaseJson;\n    } else {\n      if (!this.hasOwnProperty('$$omitFromDatabaseJson')) {\n        defineNonEnumerableProperty(this, '$$omitFromDatabaseJson', props);\n      } else {\n        this.$$omitFromDatabaseJson = this.$$omitFromDatabaseJson.concat(props);\n      }\n    }\n  }\n\n  $knex() {\n    return this.constructor.knex();\n  }\n\n  $transaction() {\n    return this.constructor.transaction();\n  }\n\n  get $ref() {\n    return this.constructor.ref;\n  }\n\n  static get objectionModelClass() {\n    return Model;\n  }\n\n  static fromJson(json, options) {\n    const model = new this();\n    model.$setJson(json || {}, options);\n    return model;\n  }\n\n  static fromDatabaseJson(json) {\n    const model = new this();\n    model.$setDatabaseJson(json || {});\n    return model;\n  }\n\n  static onCreateQuery(builder) {\n    // Do nothing by default.\n  }\n\n  static beforeFind(args) {\n    // Do nothing by default.\n  }\n\n  static afterFind(args) {\n    // Do nothing by default.\n  }\n\n  static beforeInsert(args) {\n    // Do nothing by default.\n  }\n\n  static afterInsert(args) {\n    // Do nothing by default.\n  }\n\n  static beforeUpdate(args) {\n    // Do nothing by default.\n  }\n\n  static afterUpdate(args) {\n    // Do nothing by default.\n  }\n\n  static beforeDelete(args) {\n    // Do nothing by default.\n  }\n\n  static afterDelete(args) {\n    // Do nothing by default.\n  }\n\n  static omitImpl(obj, prop) {\n    delete obj[prop];\n  }\n\n  static joinTableAlias(relationPath) {\n    return `${relationPath}_join`;\n  }\n\n  static createValidator() {\n    return new AjvValidator({\n      onCreateAjv: ajv => {\n        /* Do Nothing by default */\n      },\n      options: {\n        allErrors: true,\n        validateSchema: false,\n        ownProperties: true,\n        v5: true\n      }\n    });\n  }\n\n  static modifierNotFound(builder, modifier) {\n    throw new this.ModifierNotFoundError(modifier);\n  }\n\n  static createNotFoundError(ctx, props) {\n    return new this.NotFoundError(props);\n  }\n\n  static createValidationError(props) {\n    return new this.ValidationError(props);\n  }\n\n  static getTableName() {\n    let tableName = this.tableName;\n\n    if (isFunction(tableName)) {\n      tableName = this.tableName();\n    }\n\n    if (!isString(tableName)) {\n      throw new Error(`Model ${this.name} must have a static property tableName`);\n    }\n\n    return tableName;\n  }\n\n  static getIdColumn() {\n    let idColumn = this.idColumn;\n\n    if (isFunction(idColumn)) {\n      idColumn = this.idColumn();\n    }\n\n    return idColumn;\n  }\n\n  static getValidator() {\n    return cachedGet(this, '$$validator', getValidator);\n  }\n\n  static getJsonSchema() {\n    return cachedGet(this, '$$jsonSchema', getJsonSchema);\n  }\n\n  static getJsonAttributes() {\n    return cachedGet(this, '$$jsonAttributes', getJsonAttributes);\n  }\n\n  static getColumnNameMappers() {\n    return cachedGet(this, '$$columnNameMappers', getColumnNameMappers);\n  }\n\n  static getConcurrency(knex) {\n    const DEFAULT_CONCURRENCY = 4;\n\n    if (this.concurrency === null) {\n      if (!knex) {\n        return DEFAULT_CONCURRENCY;\n      }\n\n      // The mssql driver is shit, and we cannot have concurrent queries.\n      if (isMsSql(knex)) {\n        return 1;\n      } else {\n        return DEFAULT_CONCURRENCY;\n      }\n    } else {\n      if (isFunction(this.concurrency)) {\n        return this.concurrency();\n      } else {\n        return this.concurrency;\n      }\n    }\n  }\n\n  static getModifiers() {\n    return this.modifiers || this.namedFilters || {};\n  }\n\n  static columnNameToPropertyName(columnName) {\n    let colToProp = cachedGet(this, '$$colToProp', () => new Map());\n    let propertyName = colToProp.get(columnName);\n\n    if (!propertyName) {\n      propertyName = columnNameToPropertyName(this, columnName);\n      colToProp.set(columnName, propertyName);\n    }\n\n    return propertyName;\n  }\n\n  static propertyNameToColumnName(propertyName) {\n    let propToCol = cachedGet(this, '$$propToCol', () => new Map());\n    let columnName = propToCol.get(propertyName);\n\n    if (!columnName) {\n      columnName = propertyNameToColumnName(this, propertyName);\n      propToCol.set(propertyName, columnName);\n    }\n\n    return columnName;\n  }\n\n  static getReadOnlyAttributes() {\n    return cachedGet(this, '$$readOnlyAttributes', getReadOnlyAttributes);\n  }\n\n  static getIdRelationProperty() {\n    return cachedGet(this, '$$idRelationProperty', getIdRelationProperty);\n  }\n\n  static getIdColumnArray() {\n    return this.getIdRelationProperty().cols;\n  }\n\n  static getIdPropertyArray() {\n    return this.getIdRelationProperty().props;\n  }\n\n  static getIdProperty() {\n    const idProps = this.getIdPropertyArray();\n\n    if (idProps.length === 1) {\n      return idProps[0];\n    } else {\n      return idProps;\n    }\n  }\n\n  static getRelationMappings() {\n    return cachedGet(this, '$$relationMappings', getRelationMappings);\n  }\n\n  static getRelations() {\n    const relations = Object.create(null);\n\n    for (const relationName of this.getRelationNames()) {\n      relations[relationName] = this.getRelation(relationName);\n    }\n\n    return relations;\n  }\n\n  static getRelationNames() {\n    return cachedGet(this, '$$relationNames', getRelationNames);\n  }\n\n  static getVirtualAttributes() {\n    return cachedGet(this, '$$virtualAttributes', getVirtualAttributes);\n  }\n\n  static query(trx) {\n    const query = this.QueryBuilder.forClass(this).transacting(trx);\n    this.onCreateQuery(query);\n    return query;\n  }\n\n  static relatedQuery(relationName) {\n    const relation = this.getRelation(relationName);\n    const modelClass = relation.relatedModelClass;\n\n    return modelClass\n      .query()\n      .alias(relation.name)\n      .findOperationFactory(builder => relation.subQuery(builder));\n  }\n\n  static fetchTableMetadata(opt) {\n    return fetchTableMetadata(this, opt);\n  }\n\n  static tableMetadata(opt) {\n    return tableMetadata(this, opt);\n  }\n\n  static knex(...args) {\n    if (args.length) {\n      defineNonEnumerableProperty(this, '$$knex', args[0]);\n    } else {\n      return this.$$knex;\n    }\n  }\n\n  static transaction() {\n    return this.knex();\n  }\n\n  static raw(...args) {\n    return raw(...args).toKnexRaw(this.query());\n  }\n\n  static get ref() {\n    return (...args) => {\n      return ref(...args).model(this);\n    };\n  }\n\n  /**\n   * NB. for v2.0, this can simply return `this.knex().fn`.\n   * However, in order to maintain backwards comparability of a bug that didn't\n   * have this method as a getter, the returned value needs to be callable and\n   * return the \"same\" `knex#FunctionHelper` instance.\n   * The effect is that `Model.fn.now()` and `Model.fn().now()` produce the same result.\n   */\n  static get fn() {\n    const fnHelper = this.knex().fn;\n    const wrapper = () => fnHelper;\n    Object.assign(wrapper, fnHelper);\n    Object.setPrototypeOf(wrapper, Object.getPrototypeOf(fnHelper));\n    return wrapper;\n  }\n\n  static knexQuery() {\n    return this.knex().table(this.getTableName());\n  }\n\n  static uniqueTag() {\n    if (this.name) {\n      return `${this.getTableName()}_${this.name}`;\n    } else {\n      return this.getTableName();\n    }\n  }\n\n  static bindKnex(knex) {\n    return bindKnex(this, knex);\n  }\n\n  static bindTransaction(trx) {\n    return bindKnex(this, trx);\n  }\n\n  static ensureModel(model, options) {\n    const modelClass = this;\n\n    if (!model) {\n      return null;\n    }\n\n    if (model instanceof modelClass) {\n      return parseRelationsIntoModelInstances(model, model, options);\n    } else {\n      return modelClass.fromJson(model, options);\n    }\n  }\n\n  static ensureModelArray(input, options) {\n    if (!input) {\n      return [];\n    }\n\n    if (Array.isArray(input)) {\n      const models = new Array(input.length);\n\n      for (let i = 0, l = input.length; i < l; ++i) {\n        models[i] = this.ensureModel(input[i], options);\n      }\n\n      return models;\n    } else {\n      return [this.ensureModel(input, options)];\n    }\n  }\n\n  static getRelationUnsafe(name) {\n    const mapping = this.getRelationMappings()[name];\n\n    if (!mapping) {\n      return null;\n    }\n\n    if (!this.hasOwnProperty('$$relations')) {\n      defineNonEnumerableProperty(this, '$$relations', Object.create(null));\n    }\n\n    if (!this.$$relations[name]) {\n      this.$$relations[name] = new mapping.relation(name, this);\n      this.$$relations[name].setMapping(mapping);\n    }\n\n    return this.$$relations[name];\n  }\n\n  static getRelation(name) {\n    const relation = this.getRelationUnsafe(name);\n\n    if (!relation) {\n      throw new Error(`A model class ${this.name} doesn't have relation ${name}`);\n    }\n\n    return relation;\n  }\n\n  static loadRelated($models, expression, modifiers, trx) {\n    return this.query(trx)\n      .resolve(this.ensureModelArray($models))\n      .findOptions({ dontCallFindHooks: true })\n      .eager(expression, modifiers)\n      .runAfter(models => (Array.isArray($models) ? models : models[0]));\n  }\n\n  static traverse(...args) {\n    const { traverser, models, filterConstructor } = getTraverseArgs(...args);\n\n    if (!asSingle(models)) {\n      return;\n    }\n\n    const modelClass = asSingle(models).constructor;\n\n    visitModels(models, modelClass, (model, _, parent, relation) => {\n      if (!filterConstructor || model instanceof filterConstructor) {\n        traverser(model, parent, relation && relation.name);\n      }\n    });\n\n    return this;\n  }\n\n  static traverseAsync(...args) {\n    const { traverser, models, filterConstructor } = getTraverseArgs(...args);\n\n    if (!asSingle(models)) {\n      return Promise.resolve();\n    }\n\n    const modelClass = asSingle(models).constructor;\n    const promises = [];\n\n    visitModels(models, modelClass, (model, _, parent, relation) => {\n      if (!filterConstructor || model instanceof filterConstructor) {\n        const maybePromise = traverser(model, parent, relation && relation.name);\n        promises.push(maybePromise);\n      }\n    });\n\n    return promiseMap(promises, it => it, { concurrency: this.getConcurrency(this.knex()) });\n  }\n}\n\nObject.defineProperties(Model.prototype, {\n  $isObjectionModel: {\n    enumerable: false,\n    writable: false,\n    value: true\n  },\n\n  $objectionModelClass: {\n    enumerable: false,\n    writable: false,\n    value: Model\n  }\n});\n\nModel.QueryBuilder = QueryBuilder;\n\nModel.HasOneRelation = HasOneRelation;\nModel.HasManyRelation = HasManyRelation;\nModel.ManyToManyRelation = ManyToManyRelation;\nModel.BelongsToOneRelation = BelongsToOneRelation;\nModel.HasOneThroughRelation = HasOneThroughRelation;\n\nModel.JoinEagerAlgorithm = 'JoinEagerAlgorithm';\nModel.NaiveEagerAlgorithm = 'NaiveEagerAlgorithm';\nModel.WhereInEagerAlgorithm = 'WhereInEagerAlgorithm';\n\nModel.ValidationError = ValidationError;\nModel.NotFoundError = NotFoundError;\nModel.ModifierNotFoundError = ModifierNotFoundError;\n\nModel.tableName = null;\nModel.jsonSchema = null;\nModel.idColumn = 'id';\nModel.uidProp = '#id';\nModel.uidRefProp = '#ref';\nModel.dbRefProp = '#dbRef';\nModel.propRefRegex = /#ref{([^\\.]+)\\.([^}]+)}/g;\nModel.jsonAttributes = null;\nModel.cloneObjectAttributes = true;\nModel.virtualAttributes = null;\nModel.relationMappings = null;\nModel.modelPaths = [];\nModel.pickJsonSchemaProperties = false;\nModel.defaultEagerAlgorithm = Model.WhereInEagerAlgorithm;\nModel.defaultEagerOptions = Object.freeze({ minimize: false, separator: ':', aliases: {} });\nModel.defaultFindOptions = Object.freeze({});\nModel.modifiers = null;\nModel.namedFilters = null;\nModel.useLimitInFirst = false;\nModel.columnNameMappers = null;\nModel.relatedFindQueryMutates = true;\nModel.relatedInsertQueryMutates = true;\nModel.concurrency = null;\n\nfunction cachedGet(target, hiddenPropertyName, creator) {\n  if (!target.hasOwnProperty(hiddenPropertyName)) {\n    defineNonEnumerableProperty(target, hiddenPropertyName, creator(target));\n  }\n\n  return target[hiddenPropertyName];\n}\n\nfunction getValidator(modelClass) {\n  return modelClass.createValidator();\n}\n\nfunction getJsonSchema(modelClass) {\n  return modelClass.jsonSchema;\n}\n\nfunction getColumnNameMappers(modelClass) {\n  return modelClass.columnNameMappers;\n}\n\nfunction getIdRelationProperty(modelClass) {\n  const idColumn = asArray(modelClass.getIdColumn());\n\n  return new RelationProperty(\n    idColumn.map(idCol => `${modelClass.getTableName()}.${idCol}`),\n    () => modelClass\n  );\n}\n\nfunction getReadOnlyAttributes(modelClass) {\n  const propertyNames = Object.getOwnPropertyNames(modelClass.prototype);\n\n  return propertyNames.filter(propName => {\n    const desc = Object.getOwnPropertyDescriptor(modelClass.prototype, propName);\n    return (desc.get && !desc.set) || desc.writable === false || isFunction(desc.value);\n  });\n}\n\nfunction getRelationMappings(modelClass) {\n  let relationMappings = modelClass.relationMappings;\n\n  if (isFunction(relationMappings)) {\n    relationMappings = relationMappings.call(modelClass);\n  }\n\n  return relationMappings || {};\n}\n\nfunction getRelationNames(modelClass) {\n  return Object.keys(modelClass.getRelationMappings());\n}\n\nfunction getVirtualAttributes(modelClass) {\n  return modelClass.virtualAttributes || [];\n}\n\nfunction getTraverseArgs(filterConstructor, models, traverser) {\n  filterConstructor = filterConstructor || null;\n\n  if (traverser === undefined) {\n    traverser = models;\n    models = filterConstructor;\n    filterConstructor = null;\n  }\n\n  if (!isFunction(traverser)) {\n    throw new Error('traverser must be a function');\n  }\n\n  return {\n    traverser,\n    models,\n    filterConstructor\n  };\n}\n\nmodule.exports = {\n  Model\n};\n","'use strict';\n\nclass ModifierNotFoundError extends Error {\n  constructor(modifierName) {\n    super(`Unable to determine modify function from provided value: \"${modifierName}\".`);\n    this.modifierName = modifierName;\n  }\n}\n\nmodule.exports = {\n  ModifierNotFoundError\n};\n","'use strict';\n\nclass NotFoundError extends Error {\n  constructor(data = {}) {\n    super(data.message || 'NotFoundError');\n\n    this.name = this.constructor.name;\n    this.data = data;\n    this.statusCode = 404;\n  }\n}\n\nmodule.exports = {\n  NotFoundError\n};\n","'use strict';\n\nclass RelationDoesNotExistError extends Error {\n  constructor(relationName) {\n    super(`unknown relation \"${relationName}\" in a relation expression`);\n\n    this.name = this.constructor.name;\n    this.relationName = relationName;\n  }\n}\n\nmodule.exports = {\n  RelationDoesNotExistError\n};\n","'use strict';\n\nconst { asArray, isString } = require('../utils/objectUtils');\n\nconst ValidationErrorType = {\n  ModelValidation: 'ModelValidation',\n  RelationExpression: 'RelationExpression',\n  UnallowedRelation: 'UnallowedRelation',\n  InvalidGraph: 'InvalidGraph'\n};\n\nclass ValidationError extends Error {\n  static get Type() {\n    return ValidationErrorType;\n  }\n\n  constructor({ type, message, data = {}, statusCode = 400 }) {\n    super(message || errorsToMessage(data));\n\n    this.name = this.constructor.name;\n    this.type = type;\n    this.data = data;\n    this.statusCode = statusCode;\n  }\n}\n\nfunction errorsToMessage(data) {\n  return Object.keys(data)\n    .reduce((messages, key) => {\n      messages.push(\n        `${key}: ${asArray(data[key])\n          .map(message)\n          .join(', ')}`\n      );\n      return messages;\n    }, [])\n    .join(', ');\n}\n\nfunction message(it) {\n  if (isString(it)) {\n    return it;\n  } else {\n    return it.message;\n  }\n}\n\nmodule.exports = {\n  ValidationError,\n  ValidationErrorType\n};\n","'use strict';\n\nclass Validator {\n  constructor(...args) {\n    this.constructor.init(this, ...args);\n  }\n\n  static init() {}\n\n  beforeValidate({ model, json, options }) {\n    model.$beforeValidate(null, json, options);\n  }\n\n  validate() {\n    /* istanbul ignore next */\n    throw new Error('not implemented');\n  }\n\n  afterValidate({ model, json, options }) {\n    model.$afterValidate(json, options);\n  }\n}\n\nmodule.exports = {\n  Validator\n};\n","'use strict';\n\nconst { ModelGraphBuilder } = require('./ModelGraphBuilder');\nconst NOT_CALCULATED = {};\n\nclass ModelGraph {\n  constructor(nodes, edges) {\n    this.nodes = nodes;\n    this.edges = edges;\n\n    // These are calculated lazily.\n    this._nodesByObjects = NOT_CALCULATED;\n    this._nodesByIdPathKeys = NOT_CALCULATED;\n  }\n\n  static create(rootModelClass, roots) {\n    const builder = ModelGraphBuilder.buildGraph(rootModelClass, roots);\n    return new ModelGraph(builder.nodes, builder.edges);\n  }\n\n  static createEmpty() {\n    return new ModelGraph([], []);\n  }\n\n  get rootObjects() {\n    return this.nodes.filter(node => !node.parentEdge).map(node => node.obj);\n  }\n\n  nodeForObject(obj) {\n    if (!obj) {\n      return null;\n    }\n\n    if (this._nodesByObjects === NOT_CALCULATED) {\n      this._nodesByObjects = createNodesByObjectsMap(this.nodes);\n    }\n\n    return this._nodesByObjects.get(obj) || null;\n  }\n\n  nodeForNode(node) {\n    if (!node) {\n      return null;\n    }\n\n    if (this._nodesByIdPathKeys === NOT_CALCULATED) {\n      this._nodesByIdPathKeys = createNodesByIdPathKeysMap(this.nodes);\n    }\n\n    return this._nodesByIdPathKeys.get(node.idPathKey) || null;\n  }\n}\n\nfunction createNodesByObjectsMap(nodes) {\n  const nodesByObjects = new Map();\n\n  for (const node of nodes) {\n    nodesByObjects.set(node.obj, node);\n  }\n\n  return nodesByObjects;\n}\n\nfunction createNodesByIdPathKeysMap(nodes) {\n  const nodesByIdPathKeys = new Map();\n\n  for (const node of nodes) {\n    const idPathKey = node.idPathKey;\n\n    if (idPathKey !== null) {\n      nodesByIdPathKeys.set(idPathKey, node);\n    }\n  }\n\n  return nodesByIdPathKeys;\n}\n\nmodule.exports = {\n  ModelGraph\n};\n","'use strict';\n\nconst { isObject, isString, asArray, asSingle } = require('../../utils/objectUtils');\nconst { ValidationErrorType } = require('../../model/ValidationError');\nconst { ModelGraphNode } = require('./ModelGraphNode');\nconst { ModelGraphEdge } = require('./ModelGraphEdge');\n\nclass ModelGraphBuilder {\n  constructor() {\n    this.nodes = [];\n    this.edges = [];\n  }\n\n  static buildGraph(rootModelClass, roots) {\n    const builder = new this();\n    builder._buildGraph(rootModelClass, roots);\n\n    return builder;\n  }\n\n  _buildGraph(rootModelClass, roots) {\n    if (roots) {\n      if (Array.isArray(roots)) {\n        this._buildNodes(rootModelClass, roots);\n      } else if (isObject(roots)) {\n        this._buildNode(rootModelClass, roots);\n      } else {\n        throw createNotModelError(rootModelClass, roots);\n      }\n    }\n\n    this._buildReferences();\n  }\n\n  _buildNodes(modelClass, objs, parentNode = null, relation = null) {\n    objs = asArray(objs);\n\n    objs.forEach((obj, index) => {\n      this._buildNode(modelClass, obj, parentNode, relation, index);\n    });\n  }\n\n  _buildNode(modelClass, obj, parentNode = null, relation = null, index = null) {\n    obj = asSingle(obj);\n\n    if (!isObject(obj) || !obj.$isObjectionModel) {\n      throw createNotModelError(modelClass, obj);\n    }\n\n    const node = new ModelGraphNode(modelClass, obj);\n    this.nodes.push(node);\n\n    if (parentNode) {\n      const edge = new ModelGraphEdge(\n        ModelGraphEdge.Type.Relation,\n        parentNode,\n        node,\n        relation,\n        index\n      );\n\n      node.parentEdge = edge;\n      this._addEdge(parentNode, node, edge);\n    }\n\n    this._buildRelationNodes(node);\n  }\n\n  _buildRelationNodes(node) {\n    for (const relationName of node.modelClass.getRelationNames()) {\n      const relatedObjects = node.obj[relationName];\n\n      if (!relatedObjects) {\n        continue;\n      }\n\n      const relation = node.modelClass.getRelation(relationName);\n\n      if (relation.isOneToOne()) {\n        this._buildNode(relation.relatedModelClass, relatedObjects, node, relation);\n      } else {\n        this._buildNodes(relation.relatedModelClass, relatedObjects, node, relation);\n      }\n    }\n  }\n\n  _buildReferences() {\n    const nodesByUid = this._nodesByUid();\n\n    this._buildObjectReferences(nodesByUid);\n    this._buildPropertyReferences(nodesByUid);\n  }\n\n  _nodesByUid() {\n    const nodesByUid = new Map();\n\n    for (const node of this.nodes) {\n      const uid = node.uid;\n\n      if (uid === undefined) {\n        continue;\n      }\n\n      nodesByUid.set(uid, node);\n    }\n\n    return nodesByUid;\n  }\n\n  _buildObjectReferences(nodesByUid) {\n    for (const node of this.nodes) {\n      const ref = node.reference;\n\n      if (ref === undefined) {\n        continue;\n      }\n\n      const refNode = nodesByUid.get(ref);\n\n      if (!refNode) {\n        throw createReferenceFoundError(node, ref);\n      }\n\n      const edge = new ModelGraphEdge(ModelGraphEdge.Type.Reference, node, refNode);\n      edge.refType = ModelGraphEdge.ReferenceType.Object;\n\n      this._addEdge(node, refNode, edge);\n    }\n  }\n\n  _buildPropertyReferences(nodesByUid) {\n    for (const node of this.nodes) {\n      const relationNames = node.modelClass.getRelationNames();\n\n      for (const prop of Object.keys(node.obj)) {\n        if (relationNames.includes(prop)) {\n          continue;\n        }\n\n        this._buildPropertyReference(nodesByUid, node, prop);\n      }\n    }\n  }\n\n  _buildPropertyReference(nodesByUid, node, prop) {\n    visitStrings(node.obj[prop], [prop], (str, path) => {\n      forEachMatch(node.modelClass.propRefRegex, str, match => {\n        const [_, ref, refPath] = match;\n        const refNode = nodesByUid.get(ref);\n\n        if (!refNode) {\n          throw createReferenceFoundError(node, ref);\n        }\n\n        const edge = new ModelGraphEdge(ModelGraphEdge.Type.Reference, node, refNode);\n\n        edge.refType = ModelGraphEdge.ReferenceType.Property;\n        edge.refMatch = match[0];\n        edge.refOwnerDataPath = path.slice();\n        edge.refRelatedDataPath = refPath.split('.');\n\n        this._addEdge(node, refNode, edge);\n      });\n    });\n  }\n\n  _addEdge(ownerNode, relatedNode, edge) {\n    this.edges.push(edge);\n\n    ownerNode.edges.push(edge);\n    relatedNode.edges.push(edge);\n\n    if (edge.type === ModelGraphEdge.Type.Reference) {\n      ownerNode.refEdges.push(edge);\n      relatedNode.refEdges.push(edge);\n    }\n  }\n}\n\nfunction visitStrings(value, path, visit) {\n  if (Array.isArray(value)) {\n    visitStringsInArray(value, path, visit);\n  } else if (isObject(value)) {\n    visitStringsInObject(value, path, visit);\n  } else if (isString(value)) {\n    visit(value, path);\n  }\n}\n\nfunction visitStringsInArray(value, path, visit) {\n  for (let i = 0; i < value.length; ++i) {\n    path.push(i);\n    visitStrings(value[i], path, visit);\n    path.pop();\n  }\n}\n\nfunction visitStringsInObject(value, path, visit) {\n  for (const prop of Object.keys(value)) {\n    path.push(prop);\n    visitStrings(value[prop], path, visit);\n    path.pop();\n  }\n}\n\nfunction forEachMatch(regex, str, cb) {\n  let matchResult = regex.exec(str);\n\n  while (matchResult) {\n    cb(matchResult);\n    matchResult = regex.exec(str);\n  }\n}\n\nfunction createReferenceFoundError(node, ref) {\n  return new Error('no reference found');\n}\n\nfunction createNotModelError(modelClass, value) {\n  throw modelClass.createValidationError({\n    type: ValidationErrorType.InvalidGraph,\n    message: `expected value \"${value}\" to be an instance of ${modelClass.name}`\n  });\n}\n\nmodule.exports = {\n  ModelGraphBuilder,\n  createNotModelError\n};\n","'use strict';\n\nconst Type = {\n  Relation: 'Relation',\n  Reference: 'Reference'\n};\n\nconst ReferenceType = {\n  Object: 'Object',\n  Property: 'Property'\n};\n\nclass ModelGraphEdge {\n  constructor(type, ownerNode, relatedNode, relation = null, relationIndex = null) {\n    this.type = type;\n\n    this.ownerNode = ownerNode;\n    this.relatedNode = relatedNode;\n    this.relation = relation;\n    this.relationIndex = relationIndex;\n\n    this.refType = null;\n    this.refMatch = null;\n\n    this.refOwnerDataPath = null;\n    this.refRelatedDataPath = null;\n  }\n\n  static get Type() {\n    return Type;\n  }\n\n  static get ReferenceType() {\n    return ReferenceType;\n  }\n\n  getOtherNode(node) {\n    return this.isOwnerNode(node) ? this.relatedNode : this.ownerNode;\n  }\n\n  isOwnerNode(node) {\n    return node === this.ownerNode;\n  }\n\n  isRelatedNode(node) {\n    return node === this.relatedNode;\n  }\n}\n\nmodule.exports = {\n  ModelGraphEdge\n};\n","'use strict';\n\nconst { ModelGraphEdge } = require('./ModelGraphEdge');\nconst { isNumber } = require('../../utils/objectUtils');\nconst NOT_CALCULATED = {};\n\nclass ModelGraphNode {\n  constructor(modelClass, obj) {\n    this.modelClass = modelClass;\n    this.obj = obj;\n    this.edges = [];\n    this.userData = {};\n    this.hadIdOriginally = obj.$hasId();\n\n    // These are also included in `edges`. These are simply\n    // shortcuts for commonly used edges.\n    this.refEdges = [];\n    this.parentEdge = null;\n\n    // These are calculated lazily.\n    this._relationPath = NOT_CALCULATED;\n    this._relationPathKey = NOT_CALCULATED;\n\n    this._dataPath = NOT_CALCULATED;\n    this._dataPathKey = NOT_CALCULATED;\n\n    this._idPath = NOT_CALCULATED;\n    this._idPathKey = NOT_CALCULATED;\n  }\n\n  get isReference() {\n    return this.reference !== undefined;\n  }\n\n  get isDbReference() {\n    return this.dbReference !== undefined;\n  }\n\n  get reference() {\n    return this.obj[this.modelClass.uidRefProp];\n  }\n\n  get dbReference() {\n    return this.obj[this.modelClass.dbRefProp];\n  }\n\n  get uid() {\n    return this.obj[this.modelClass.uidProp];\n  }\n\n  get parentNode() {\n    if (this.parentEdge) {\n      return this.parentEdge.ownerNode;\n    } else {\n      return null;\n    }\n  }\n\n  get indexInRelation() {\n    if (this.parentEdge) {\n      return this.parentEdge.relationIndex;\n    } else {\n      return null;\n    }\n  }\n\n  get relationName() {\n    if (this.parentEdge) {\n      return this.parentEdge.relation.name;\n    } else {\n      return null;\n    }\n  }\n\n  get relationPath() {\n    if (this._relationPath === NOT_CALCULATED) {\n      this._relationPath = this._createRelationPath();\n    }\n\n    return this._relationPath;\n  }\n\n  get relationPathKey() {\n    if (this._relationPathKey === NOT_CALCULATED) {\n      this._relationPathKey = this._createRelationPathKey();\n    }\n\n    return this._relationPathKey;\n  }\n\n  get dataPath() {\n    if (this._dataPath === NOT_CALCULATED) {\n      this._dataPath = this._createDataPath();\n    }\n\n    return this._dataPath;\n  }\n\n  get dataPathKey() {\n    if (this._dataPathKey === NOT_CALCULATED) {\n      this._dataPathKey = this._createDataPathKey();\n    }\n\n    return this._dataPathKey;\n  }\n\n  get idPath() {\n    if (this._idPath === NOT_CALCULATED) {\n      this._idPath = this._createIdPath();\n    }\n\n    return this._idPath;\n  }\n\n  get idPathKey() {\n    if (this._idPathKey === NOT_CALCULATED) {\n      this._idPathKey = this._createIdPathKey();\n    }\n\n    return this._idPathKey;\n  }\n\n  /**\n   * If this node is a reference, returns the referred node.\n   */\n  get referencedNode() {\n    for (const edge of this.refEdges) {\n      if (edge.refType === ModelGraphEdge.ReferenceType.Object && edge.isOwnerNode(this)) {\n        return edge.relatedNode;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns all nodes that are references to this node.\n   */\n  get referencingNodes() {\n    const nodes = [];\n\n    for (const edge of this.refEdges) {\n      if (edge.refType === ModelGraphEdge.ReferenceType.Object && edge.isRelatedNode(this)) {\n        nodes.push(edge.ownerNode);\n      }\n    }\n\n    return nodes;\n  }\n\n  get descendantRelationNodes() {\n    return this._collectDescendantRelationNodes([]);\n  }\n\n  removeEdge(edge) {\n    // Don't allow removing parent edges for now. It would\n    // cause all kinds of cache invalidation.\n    if (edge === this.parentEdge) {\n      throw new Error('cannot remove parent edge');\n    }\n\n    this.edges = this.edges.filter(it => it !== edge);\n    this.refEdges = this.refEdges.filter(it => it !== edge);\n  }\n\n  _collectDescendantRelationNodes(nodes) {\n    for (const edge of this.edges) {\n      if (edge.type === ModelGraphEdge.Type.Relation && edge.isOwnerNode(this)) {\n        nodes.push(edge.relatedNode);\n        edge.relatedNode._collectDescendantRelationNodes(nodes);\n      }\n    }\n\n    return nodes;\n  }\n\n  _createRelationPath() {\n    if (this.parentNode === null) {\n      return [];\n    } else {\n      return [...this.parentNode.relationPath, this.relationName];\n    }\n  }\n\n  _createRelationPathKey() {\n    return this.relationPath.join('.');\n  }\n\n  _createDataPath() {\n    if (this.parentEdge === null) {\n      return [];\n    } else if (this.parentEdge.relation.isOneToOne()) {\n      return [...this.parentNode.dataPath, this.relationName];\n    } else {\n      return [...this.parentNode.dataPath, this.relationName, this.indexInRelation];\n    }\n  }\n\n  _createDataPathKey() {\n    const dataPathKey = this.dataPath.reduce((key, it) => {\n      if (isNumber(it)) {\n        return `${key}[${it}]`;\n      } else {\n        return key ? `${key}.${it}` : it;\n      }\n    }, '');\n\n    return dataPathKey ? '.' + dataPathKey : dataPathKey;\n  }\n\n  _createIdPath() {\n    if (!this.obj.$hasId()) {\n      return null;\n    }\n\n    if (this.parentEdge === null) {\n      return [this.obj.$idKey()];\n    } else {\n      const path = this.parentNode.idPath;\n\n      if (path === null) {\n        return null;\n      }\n\n      return [...path, this.relationName, this.obj.$idKey()];\n    }\n  }\n\n  _createIdPathKey() {\n    const idPath = this.idPath;\n\n    if (idPath) {\n      return this.idPath.join('.');\n    } else {\n      return null;\n    }\n  }\n}\n\nmodule.exports = {\n  ModelGraphNode\n};\n","'use strict';\n\nconst cache = new Map();\n\nfunction inheritModel(modelClass) {\n  let inherit = cache.get(modelClass.name);\n\n  if (!inherit) {\n    inherit = createClassInheritor(modelClass.name);\n    cache.set(modelClass.name, inherit);\n  }\n\n  return inherit(modelClass);\n}\n\nfunction createClassInheritor(className) {\n  return new Function(\n    'BaseClass',\n    `\n    'use strict';\n    return class ${className} extends BaseClass {}\n  `\n  );\n}\n\nmodule.exports = {\n  inheritModel\n};\n","'use strict';\n\nconst { inheritModel } = require('./inheritModel');\nconst { staticHiddenProps } = require('./modelUtils');\nconst { defineNonEnumerableProperty } = require('./modelUtils');\n\nfunction bindKnex(modelClass, knex) {\n  let BoundModelClass = getBoundModelFromCache(modelClass, knex);\n\n  if (BoundModelClass === null) {\n    BoundModelClass = inheritModel(modelClass);\n    BoundModelClass = copyHiddenProperties(modelClass, BoundModelClass);\n\n    BoundModelClass.knex(knex);\n\n    BoundModelClass = putBoundModelToCache(modelClass, BoundModelClass, knex);\n    BoundModelClass = bindRelations(modelClass, BoundModelClass, knex);\n  }\n\n  return BoundModelClass;\n}\n\nfunction getBoundModelFromCache(modelClass, knex) {\n  const cache = getCache(knex);\n  const cacheKey = modelClass.uniqueTag();\n\n  return cache.get(cacheKey) || null;\n}\n\nfunction getCache(knex) {\n  if (!knex.$$objection) {\n    createCache(knex);\n  }\n\n  return knex.$$objection.boundModels;\n}\n\nfunction createCache(knex) {\n  defineNonEnumerableProperty(knex, '$$objection', {\n    boundModels: new Map()\n  });\n}\n\nfunction copyHiddenProperties(modelClass, BoundModelClass) {\n  for (const prop of staticHiddenProps) {\n    // $$relations and $$relationArray are handled in separately.\n    if (modelClass.hasOwnProperty(prop) && prop !== '$$relations' && prop !== '$$relationArray') {\n      defineNonEnumerableProperty(BoundModelClass, prop, modelClass[prop]);\n    }\n  }\n\n  return BoundModelClass;\n}\n\nfunction putBoundModelToCache(modelClass, BoundModelClass, knex) {\n  const cache = getCache(knex);\n  const cacheKey = modelClass.uniqueTag();\n\n  cache.set(cacheKey, BoundModelClass);\n  return BoundModelClass;\n}\n\nfunction bindRelations(modelClass, BoundModelClass, knex) {\n  const boundRelations = Object.create(null);\n  const boundRelationArray = [];\n\n  for (const relationName of modelClass.getRelationNames()) {\n    const relation = modelClass.getRelation(relationName);\n    const boundRelation = relation.bindKnex(knex);\n\n    boundRelations[relation.name] = boundRelation;\n    boundRelationArray.push(boundRelation);\n  }\n\n  defineNonEnumerableProperty(BoundModelClass, '$$relations', boundRelations);\n  defineNonEnumerableProperty(BoundModelClass, '$$relationArray', boundRelationArray);\n\n  return BoundModelClass;\n}\n\nmodule.exports = {\n  bindKnex\n};\n","'use strict';\n\nconst { isObject, cloneDeep } = require('../utils/objectUtils');\nconst { hiddenProps } = require('./modelUtils');\nconst { defineNonEnumerableProperty } = require('./modelUtils');\nconst { isInternalProp } = require('../utils/internalPropUtils');\n\nfunction clone(model, shallow, stripInternal) {\n  let clone = null;\n\n  const omitFromJson = model.$omitFromJson();\n  const omitFromDatabaseJson = model.$omitFromDatabaseJson();\n\n  if (!shallow && !stripInternal) {\n    clone = cloneSimple(model);\n  } else {\n    clone = cloneWithOpt(model, shallow, stripInternal);\n  }\n\n  if (omitFromJson) {\n    clone.$omitFromJson(omitFromJson);\n  }\n\n  if (omitFromDatabaseJson) {\n    clone.$omitFromDatabaseJson(omitFromDatabaseJson);\n  }\n\n  clone = copyHiddenProps(model, clone);\n  return clone;\n}\n\nfunction cloneSimple(model) {\n  const clone = new model.constructor();\n  const keys = Object.keys(model);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = model[key];\n\n    if (isObject(value)) {\n      clone[key] = cloneObject(value);\n    } else {\n      clone[key] = value;\n    }\n  }\n\n  return clone;\n}\n\nfunction cloneWithOpt(model, shallow, stripInternal) {\n  const clone = new model.constructor();\n  const keys = Object.keys(model);\n  const relationNames = model.constructor.getRelationNames();\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = model[key];\n\n    if ((shallow && relationNames.includes(key)) || (stripInternal && isInternalProp(key))) {\n      continue;\n    }\n\n    if (isObject(value)) {\n      clone[key] = cloneObject(value);\n    } else {\n      clone[key] = value;\n    }\n  }\n\n  return clone;\n}\n\nfunction cloneObject(value) {\n  if (Array.isArray(value)) {\n    return cloneArray(value);\n  } else if (value.$isObjectionModel) {\n    return clone(value, false, false);\n  } else if (Buffer.isBuffer(value)) {\n    return new Buffer(value);\n  } else {\n    return cloneDeep(value);\n  }\n}\n\nfunction cloneArray(value) {\n  const ret = new Array(value.length);\n\n  for (let i = 0, l = ret.length; i < l; ++i) {\n    const item = value[i];\n\n    if (isObject(item)) {\n      ret[i] = cloneObject(item);\n    } else {\n      ret[i] = item;\n    }\n  }\n\n  return ret;\n}\n\nfunction copyHiddenProps(model, clone) {\n  for (let i = 0, l = hiddenProps.length; i < l; ++i) {\n    const prop = hiddenProps[i];\n\n    if (model.hasOwnProperty(prop)) {\n      defineNonEnumerableProperty(clone, prop, model[prop]);\n    }\n  }\n\n  return clone;\n}\n\nmodule.exports = {\n  clone\n};\n","'use strict';\n\nconst { difference } = require('../utils/objectUtils');\n\nfunction columnNameToPropertyName(modelClass, columnName) {\n  const model = new modelClass();\n  const addedProps = Object.keys(model.$parseDatabaseJson({}));\n\n  const row = {};\n  row[columnName] = null;\n\n  const props = Object.keys(model.$parseDatabaseJson(row));\n  const propertyName = difference(props, addedProps)[0];\n\n  return propertyName || columnName;\n}\n\nfunction propertyNameToColumnName(modelClass, propertyName) {\n  const model = new modelClass();\n  const addedCols = Object.keys(model.$formatDatabaseJson({}));\n\n  const obj = {};\n  obj[propertyName] = null;\n\n  const cols = Object.keys(model.$formatDatabaseJson(obj));\n  const columnName = difference(cols, addedCols)[0];\n\n  return columnName || propertyName;\n}\n\nmodule.exports = {\n  columnNameToPropertyName,\n  propertyNameToColumnName\n};\n","'use strict';\n\nconst { isObject } = require('../utils/objectUtils');\nconst { isInternalProp } = require('../utils/internalPropUtils');\n\nfunction omit(model, args) {\n  if (args.length === 1 && isObject(args[0])) {\n    const keys = args[0];\n\n    if (Array.isArray(keys)) {\n      omitArray(model, keys);\n    } else {\n      omitObject(model, keys);\n    }\n  } else {\n    omitArray(model, args);\n  }\n\n  return model;\n}\n\nfunction pick(model, args) {\n  if (args.length === 1 && isObject(args[0])) {\n    const keys = args[0];\n\n    if (Array.isArray(keys)) {\n      pickArray(model, keys);\n    } else {\n      pickObject(model, keys);\n    }\n  } else {\n    pickArray(model, args);\n  }\n\n  return model;\n}\n\nfunction omitObject(model, keyObj) {\n  const modelClass = model.constructor;\n  const keys = Object.keys(keyObj);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = keyObj[key];\n\n    if (value && !isInternalProp(key) && model.hasOwnProperty(key)) {\n      modelClass.omitImpl(model, key);\n    }\n  }\n}\n\nfunction omitArray(model, keys) {\n  const modelClass = model.constructor;\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!isInternalProp(key) && model.hasOwnProperty(key)) {\n      modelClass.omitImpl(model, key);\n    }\n  }\n}\n\nfunction pickObject(model, keyObj) {\n  const modelClass = model.constructor;\n  const keys = Object.keys(model);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!isInternalProp(key) && !keyObj[key]) {\n      modelClass.omitImpl(model, key);\n    }\n  }\n}\n\nfunction pickArray(model, pick) {\n  const modelClass = model.constructor;\n  const keys = Object.keys(model);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!isInternalProp(key) && !contains(pick, key)) {\n      modelClass.omitImpl(model, key);\n    }\n  }\n}\n\nfunction contains(arr, value) {\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    if (arr[i] === value) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  omit,\n  pick\n};\n","'use strict';\n\nfunction getSetId(model, maybeId) {\n  if (maybeId !== undefined) {\n    return setId(model, maybeId);\n  } else {\n    return getId(model);\n  }\n}\n\nfunction hasId(model) {\n  return model.$hasProps(model.constructor.getIdPropertyArray());\n}\n\nfunction setId(model, id) {\n  const idProp = model.constructor.getIdProperty();\n  const isCompositeId = Array.isArray(idProp);\n\n  if (Array.isArray(id)) {\n    if (isCompositeId) {\n      if (id.length !== idProp.length) {\n        throw new Error('trying to set an invalid identifier for a model');\n      }\n\n      for (let i = 0; i < id.length; ++i) {\n        model[idProp[i]] = id[i];\n      }\n    } else {\n      if (id.length !== 1) {\n        throw new Error('trying to set an invalid identifier for a model');\n      }\n\n      model[idProp] = id[0];\n    }\n  } else {\n    if (isCompositeId) {\n      if (idProp.length > 1) {\n        throw new Error('trying to set an invalid identifier for a model');\n      }\n\n      model[idProp[0]] = id;\n    } else {\n      model[idProp] = id;\n    }\n  }\n}\n\nfunction getId(model) {\n  const idProp = model.constructor.getIdProperty();\n  const isCompositeId = Array.isArray(idProp);\n\n  if (isCompositeId) {\n    return model.$values(idProp);\n  } else {\n    return model[idProp];\n  }\n}\n\nmodule.exports = {\n  getSetId,\n  hasId\n};\n","'use strict';\n\nconst { asArray, isObject, flatten, isString } = require('../utils/objectUtils');\n\nfunction parseJsonAttributes(json, modelClass) {\n  const jsonAttr = modelClass.getJsonAttributes();\n\n  if (jsonAttr.length) {\n    // JSON attributes may be returned as strings depending on the database and\n    // the database client. Convert them to objects here.\n    for (let i = 0, l = jsonAttr.length; i < l; ++i) {\n      const attr = jsonAttr[i];\n      const value = json[attr];\n\n      if (isString(value)) {\n        const parsed = tryParseJson(value);\n\n        // tryParseJson returns undefined if parsing failed.\n        if (parsed !== undefined) {\n          json[attr] = parsed;\n        }\n      }\n    }\n  }\n\n  return json;\n}\n\nfunction formatJsonAttributes(json, modelClass) {\n  const jsonAttr = modelClass.getJsonAttributes();\n\n  if (jsonAttr.length) {\n    // All database clients want JSON columns as strings. Do the conversion here.\n    for (let i = 0, l = jsonAttr.length; i < l; ++i) {\n      const attr = jsonAttr[i];\n      const value = json[attr];\n\n      if (isObject(value)) {\n        json[attr] = JSON.stringify(value);\n      }\n    }\n  }\n\n  return json;\n}\n\nfunction getJsonAttributes(modelClass) {\n  let jsonAttributes = modelClass.jsonAttributes;\n\n  if (Array.isArray(jsonAttributes)) {\n    return jsonAttributes;\n  }\n\n  jsonAttributes = [];\n\n  if (modelClass.getJsonSchema()) {\n    const props = modelClass.getJsonSchema().properties || {};\n\n    for (const propName of Object.keys(props)) {\n      const prop = props[propName];\n      let types = asArray(prop.type).filter(it => !!it);\n\n      if (types.length === 0 && Array.isArray(prop.anyOf)) {\n        types = flatten(prop.anyOf.map(it => it.type));\n      }\n\n      if (types.length === 0 && Array.isArray(prop.oneOf)) {\n        types = flatten(prop.oneOf.map(it => it.type));\n      }\n\n      if (types.indexOf('object') !== -1 || types.indexOf('array') !== -1) {\n        jsonAttributes.push(propName);\n      }\n    }\n  }\n\n  return jsonAttributes;\n}\n\nfunction tryParseJson(maybeJsonStr) {\n  try {\n    return JSON.parse(maybeJsonStr);\n  } catch (err) {\n    return undefined;\n  }\n}\n\nmodule.exports = {\n  parseJsonAttributes,\n  formatJsonAttributes,\n  getJsonAttributes\n};\n","'use strict';\n\nconst { isObject } = require('../utils/objectUtils');\n\nfunction parseRelationsIntoModelInstances(model, json, options = {}) {\n  if (!options.cache) {\n    options = Object.assign({}, options, {\n      cache: new Map()\n    });\n  }\n\n  options.cache.set(json, model);\n\n  for (const relationName of model.constructor.getRelationNames()) {\n    const relationJson = json[relationName];\n\n    if (relationJson !== undefined) {\n      const relation = model.constructor.getRelation(relationName);\n      const relationModel = parseRelation(relationJson, relation, options);\n\n      if (relationModel !== relationJson) {\n        model[relation.name] = relationModel;\n      }\n    }\n  }\n\n  return model;\n}\n\nfunction parseRelation(json, relation, options) {\n  if (Array.isArray(json)) {\n    return parseRelationArray(json, relation, options);\n  } else if (json) {\n    return parseRelationObject(json, relation, options);\n  } else {\n    return null;\n  }\n}\n\nfunction parseRelationArray(json, relation, options) {\n  const models = new Array(json.length);\n  let didChange = false;\n\n  for (let i = 0, l = json.length; i < l; ++i) {\n    const model = parseRelationObject(json[i], relation, options);\n\n    if (model !== json[i]) {\n      didChange = true;\n    }\n\n    models[i] = model;\n  }\n\n  if (didChange) {\n    return models;\n  } else {\n    return json;\n  }\n}\n\nfunction parseRelationObject(json, relation, options) {\n  if (isObject(json)) {\n    const modelClass = relation.relatedModelClass;\n    let model = options.cache.get(json);\n\n    if (model === undefined) {\n      if (json instanceof modelClass) {\n        model = parseRelationsIntoModelInstances(json, json, options);\n      } else {\n        model = modelClass.fromJson(json, options);\n      }\n    }\n\n    return model;\n  } else {\n    return json;\n  }\n}\n\nmodule.exports = {\n  parseRelationsIntoModelInstances\n};\n","'use strict';\n\nconst { isObject, isFunction } = require('../utils/objectUtils');\nconst { defineNonEnumerableProperty } = require('./modelUtils');\nconst { isKnexRaw, isKnexQueryBuilder } = require('../utils/knexUtils');\n\nconst QUERY_PROPS_PROPERTY = '$$queryProps';\n\n// Removes query properties from `json` and stores them into a hidden property\n// inside `model` so that they can be later merged back to `json`.\nfunction splitQueryProps(model, json) {\n  const keys = Object.keys(json);\n\n  if (hasQueryProps(json, keys)) {\n    const queryProps = {};\n    const modelProps = {};\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      const key = keys[i];\n      const value = json[key];\n\n      if (isQueryProp(value)) {\n        queryProps[key] = value;\n      } else {\n        modelProps[key] = value;\n      }\n    }\n\n    defineNonEnumerableProperty(model, QUERY_PROPS_PROPERTY, queryProps);\n\n    return modelProps;\n  } else {\n    return json;\n  }\n}\n\nfunction hasQueryProps(json, keys) {\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    if (isQueryProp(json[keys[i]])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isQueryProp(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  return (\n    isKnexQueryBuilder(value) ||\n    isKnexRaw(value) ||\n    isKnexRawConvertable(value) ||\n    value.isObjectionQueryBuilderBase\n  );\n}\n\n// Merges and converts `model`'s query properties into `json`.\nfunction mergeQueryProps(model, json, omitProps, builder) {\n  json = convertExistingQueryProps(json, builder);\n  json = convertAndMergeHiddenQueryProps(model, json, omitProps, builder);\n\n  return json;\n}\n\n// Converts the query properties in `json` to knex raw instances.\n// `json` may have query properties even though we removed them.\n// For example they may have been added in lifecycle hooks.\nfunction convertExistingQueryProps(json, builder) {\n  const keys = Object.keys(json);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = json[key];\n\n    if (isQueryProp(value)) {\n      json[key] = queryPropToKnexRaw(value, builder);\n    }\n  }\n\n  return json;\n}\n\n// Converts and merges the query props that were split from the model\n// and stored into QUERY_PROPS_PROPERTY.\nfunction convertAndMergeHiddenQueryProps(model, json, omitProps, builder) {\n  const queryProps = model[QUERY_PROPS_PROPERTY];\n\n  if (!queryProps) {\n    // The model has no query properties.\n    return json;\n  }\n\n  const modelClass = model.constructor;\n  const keys = Object.keys(queryProps);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!omitProps || !omitProps.includes(key)) {\n      const queryProp = queryPropToKnexRaw(queryProps[key], builder);\n      json[modelClass.propertyNameToColumnName(key)] = queryProp;\n    }\n  }\n\n  return json;\n}\n\n// Converts a query property into a knex `raw` instance.\nfunction queryPropToKnexRaw(queryProp, builder) {\n  if (!queryProp) {\n    return queryProp;\n  }\n\n  if (queryProp.isObjectionQueryBuilderBase) {\n    return buildObjectionQueryBuilder(queryProp, builder);\n  } else if (isKnexRawConvertable(queryProp)) {\n    return buildKnexRawConvertable(queryProp, builder);\n  } else {\n    return queryProp;\n  }\n}\n\nfunction buildObjectionQueryBuilder(builder, parentBuilder) {\n  return builder.subqueryOf(parentBuilder).toKnexQuery();\n}\n\nfunction buildKnexRawConvertable(convertable, builder) {\n  if (!builder) {\n    throw new Error(\n      'toDatabaseJson called without a query builder instance for a model with query properties'\n    );\n  }\n\n  return convertable.toKnexRaw(builder);\n}\n\nfunction isKnexRawConvertable(queryProp) {\n  return isFunction(queryProp.toKnexRaw);\n}\n\nmodule.exports = {\n  splitQueryProps,\n  mergeQueryProps\n};\n","'use strict';\n\nconst { isInternalProp } = require('../utils/internalPropUtils');\nconst { splitQueryProps } = require('./modelQueryProps');\nconst { isFunction, isString } = require('../utils/objectUtils');\nconst { parseRelationsIntoModelInstances } = require('./modelParseRelations');\n\nfunction setJson(model, json, options) {\n  json = json || {};\n  options = options || {};\n\n  if (Object.prototype.toString.call(json) !== '[object Object]') {\n    throw new Error(\n      'You should only pass objects to $setJson method. ' +\n        '$setJson method was given an invalid value ' +\n        json\n    );\n  }\n\n  if (!json.$isObjectionModel) {\n    // json can contain \"query properties\" like `raw` instances, query builders etc.\n    // We take them out of `json` and store them to a hidden property $$queryProps\n    // in the model instance for later use.\n    json = splitQueryProps(model, json);\n  }\n\n  json = model.$parseJson(json, options);\n  json = model.$validate(json, options);\n\n  model.$set(json);\n\n  if (!options.skipParseRelations) {\n    parseRelationsIntoModelInstances(model, json, options);\n  }\n\n  return model;\n}\n\nfunction setDatabaseJson(model, json) {\n  json = model.$parseDatabaseJson(json);\n\n  if (json) {\n    const keys = Object.keys(json);\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      const key = keys[i];\n      model[key] = json[key];\n    }\n  }\n\n  return model;\n}\n\nfunction setFast(model, obj) {\n  if (obj) {\n    // Don't try to set read-only properties. They can easily get here\n    // through `fromJson` when parsing an object that was previously\n    // serialized from a model instance.\n    const readOnlyAttr = model.constructor.getReadOnlyAttributes();\n    const keys = Object.keys(obj);\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      const key = keys[i];\n      const value = obj[key];\n\n      if (!isInternalProp(key) && !isFunction(value) && !readOnlyAttr.includes(key)) {\n        model[key] = value;\n      }\n    }\n  }\n\n  return model;\n}\n\nfunction setRelated(model, relation, models) {\n  relation = ensureRelation(model, relation);\n\n  if (relation.isOneToOne()) {\n    if (Array.isArray(models)) {\n      if (models.length === 0) {\n        model[relation.name] = null;\n      } else {\n        model[relation.name] = models[0] || null;\n      }\n    } else {\n      model[relation.name] = models || null;\n    }\n  } else {\n    if (!models) {\n      model[relation.name] = [];\n    } else if (Array.isArray(models)) {\n      model[relation.name] = models;\n    } else {\n      model[relation.name] = [models];\n    }\n  }\n\n  return this;\n}\n\nfunction appendRelated(model, relation, models) {\n  relation = ensureRelation(model, relation);\n\n  if (!model[relation.name] || relation.isOneToOne()) {\n    return model.$setRelated(relation, models);\n  } else {\n    if (Array.isArray(models)) {\n      models.forEach(it => model[relation.name].push(it));\n    } else if (models) {\n      model[relation.name].push(models);\n    }\n  }\n\n  return this;\n}\n\nfunction ensureRelation(model, relation) {\n  if (isString(relation)) {\n    return model.constructor.getRelation(relation);\n  } else {\n    return relation;\n  }\n}\n\nmodule.exports = {\n  setFast,\n  setJson,\n  setDatabaseJson,\n  setRelated,\n  appendRelated\n};\n","'use strict';\n\nconst { defineNonEnumerableProperty } = require('./modelUtils');\nconst { isPromise } = require('../utils/promiseUtils');\n\nconst TABLE_METADATA = '$$tableMetadata';\n\nfunction fetchTableMetadata(\n  modelClass,\n  { parentBuilder = null, knex = null, force = false, table = null } = {}\n) {\n  // The table isn't necessarily same as `modelClass.getTableName()` for example if\n  // a view is queried instead.\n  if (!table) {\n    if (parentBuilder) {\n      table = parentBuilder.tableNameFor(modelClass.getTableName());\n    } else {\n      table = modelClass.getTableName();\n    }\n  }\n\n  // Call tableMetadata first instead of accessing the cache directly beause\n  // tableMetadata may have been overriden.\n  let metadata = modelClass.tableMetadata({ table });\n\n  if (!force && metadata) {\n    return Promise.resolve(metadata);\n  }\n\n  // Memoize metadata but only for modelClass. The hasOwnProperty check\n  // will fail for subclasses and the value gets recreated.\n  if (!modelClass.hasOwnProperty(TABLE_METADATA)) {\n    defineNonEnumerableProperty(modelClass, TABLE_METADATA, new Map());\n  }\n\n  // The cache needs to be checked in addition to calling tableMetadata\n  // because the cache may contain a temporary promise in which case\n  // tableMetadata returns null.\n  metadata = modelClass[TABLE_METADATA].get(table);\n\n  if (!force && metadata) {\n    return Promise.resolve(metadata);\n  } else {\n    const promise = modelClass\n      .query(knex)\n      .childQueryOf(parentBuilder)\n      .columnInfo({ table })\n      .then(columnInfo => {\n        const metadata = {\n          columns: Object.keys(columnInfo)\n        };\n\n        modelClass[TABLE_METADATA].set(table, metadata);\n        return metadata;\n      });\n\n    modelClass[TABLE_METADATA].set(table, promise);\n    return promise;\n  }\n}\n\nfunction tableMetadata(modelClass, { table } = {}) {\n  if (modelClass.hasOwnProperty(TABLE_METADATA)) {\n    const metadata = modelClass[TABLE_METADATA].get(table || modelClass.getTableName());\n\n    if (isPromise(metadata)) {\n      return null;\n    } else {\n      return metadata;\n    }\n  } else {\n    return null;\n  }\n}\n\nmodule.exports = {\n  fetchTableMetadata,\n  tableMetadata\n};\n","'use strict';\n\nconst { isInternalProp } = require('../utils/internalPropUtils');\nconst { mergeQueryProps } = require('./modelQueryProps');\nconst { isObject, cloneDeep, isFunction } = require('../utils/objectUtils');\nconst EMPTY_ARRAY = [];\n\nfunction toJson(model, optIn) {\n  const modelClass = model.constructor;\n\n  const opt = {\n    virtuals: getVirtuals(optIn),\n    shallow: isShallow(optIn),\n    omit: getOmit(optIn, modelClass),\n    pick: null,\n    omitFromJson: model.$omitFromJson() || null,\n    cloneObjects: modelClass.cloneObjectAttributes\n  };\n\n  let json = toExternalJsonImpl(model, opt);\n  json = model.$formatJson(json);\n\n  return json;\n}\n\nfunction toDatabaseJson(model, builder) {\n  const modelClass = model.constructor;\n\n  const opt = {\n    virtuals: false,\n    shallow: true,\n    omit: modelClass.getRelationNames(),\n    pick: getPick(modelClass),\n    omitFromJson: model.$omitFromDatabaseJson() || null,\n    cloneObjects: modelClass.cloneObjectAttributes\n  };\n\n  let json = toDatabaseJsonImpl(model, opt);\n  json = model.$formatDatabaseJson(json);\n\n  return mergeQueryProps(model, json, opt.omitFromJson, builder);\n}\n\nfunction getVirtuals(opt) {\n  if (!opt) {\n    return true;\n  } else if (Array.isArray(opt.virtuals)) {\n    return opt.virtuals;\n  } else {\n    return opt.virtuals !== false;\n  }\n}\n\nfunction isShallow(opt) {\n  return !!opt && !!opt.shallow;\n}\n\nfunction getOmit(opt, modelClass) {\n  return isShallow(opt) ? modelClass.getRelationNames() : null;\n}\n\nfunction getPick(modelClass) {\n  const jsonSchema = modelClass.getJsonSchema();\n  return (jsonSchema && modelClass.pickJsonSchemaProperties && jsonSchema.properties) || null;\n}\n\nfunction toExternalJsonImpl(model, opt) {\n  const json = {};\n  const keys = Object.keys(model);\n  const vAttr = getVirtualAttributes(model, opt);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = model[key];\n\n    assignJsonValue(json, key, value, opt);\n  }\n\n  if (vAttr.length !== 0) {\n    assignVirtualAttributes(json, model, vAttr, opt);\n  }\n\n  return json;\n}\n\nfunction getVirtualAttributes(model, opt) {\n  if (Array.isArray(opt.virtuals)) {\n    return opt.virtuals;\n  } else if (opt.virtuals === true) {\n    return model.constructor.getVirtualAttributes();\n  } else {\n    return EMPTY_ARRAY;\n  }\n}\n\nfunction toDatabaseJsonImpl(model, opt) {\n  const json = {};\n  const keys = Object.keys(model);\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = model[key];\n\n    assignJsonValue(json, key, value, opt);\n  }\n\n  return json;\n}\n\nfunction assignJsonValue(json, key, value, opt) {\n  const type = typeof value;\n\n  if (\n    type !== 'function' &&\n    type !== 'undefined' &&\n    !isInternalProp(key) &&\n    !shouldOmit(opt, key) &&\n    shouldPick(opt, key)\n  ) {\n    if (isObject(value)) {\n      json[key] = toJsonObject(value, opt);\n    } else {\n      json[key] = value;\n    }\n  }\n}\n\nfunction shouldOmit(opt, key) {\n  return (\n    (opt.omit !== null && opt.omit.includes(key)) ||\n    (opt.omitFromJson !== null && opt.omitFromJson.includes(key))\n  );\n}\n\nfunction shouldPick(opt, key) {\n  return opt.pick === null || key in opt.pick;\n}\n\nfunction assignVirtualAttributes(json, model, vAttr, opt) {\n  for (let i = 0, l = vAttr.length; i < l; ++i) {\n    const key = vAttr[i];\n    let value = model[key];\n\n    if (isFunction(value)) {\n      value = value.call(model);\n    }\n\n    assignJsonValue(json, key, value, opt);\n  }\n}\n\nfunction toJsonObject(value, opt) {\n  if (Array.isArray(value)) {\n    return toJsonArray(value, opt);\n  } else if (value.$isObjectionModel) {\n    // No branch for $toDatabaseJson here since there is never a need\n    // to have nested models in database rows.\n    return value.$toJson(opt);\n  } else if (Buffer.isBuffer(value)) {\n    return value;\n  } else if (opt.cloneObjects) {\n    return cloneDeep(value);\n  } else {\n    return value;\n  }\n}\n\nfunction toJsonArray(value, opt) {\n  const ret = new Array(value.length);\n\n  for (let i = 0, l = ret.length; i < l; ++i) {\n    const item = value[i];\n\n    if (isObject(item)) {\n      ret[i] = toJsonObject(item, opt);\n    } else {\n      ret[i] = item;\n    }\n  }\n\n  return ret;\n}\n\nmodule.exports = {\n  toJson,\n  toDatabaseJson\n};\n","'use strict';\n\nconst hiddenProps = ['$$queryProps'];\n\nconst staticHiddenProps = [\n  '$$knex',\n  '$$validator',\n  '$$jsonSchema',\n  '$$colToProp',\n  '$$propToCol',\n  '$$relationMappings',\n  '$$relations',\n  '$$relationNames',\n  '$$jsonAttributes',\n  '$$columnNameMappers',\n  '$$tableMetadata',\n  '$$readOnlyAttributes',\n  '$$idRelationProperty',\n  '$$virtualAttributes'\n];\n\nfunction defineNonEnumerableProperty(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    enumerable: false,\n    writable: true,\n    configurable: true,\n    value\n  });\n}\n\nfunction keyByProps(models, props) {\n  const map = new Map();\n\n  for (let i = 0, l = models.length; i < l; ++i) {\n    const model = models[i];\n    map.set(model.$propKey(props), model);\n  }\n\n  return map;\n}\n\nmodule.exports = {\n  hiddenProps,\n  staticHiddenProps,\n  defineNonEnumerableProperty,\n  keyByProps\n};\n","'use strict';\n\nconst { clone } = require('./modelClone');\n\nfunction validate(model, json, options = {}) {\n  json = json || model;\n\n  const inputJson = json;\n  const validatingModelInstance = inputJson && inputJson.$isObjectionModel;\n\n  if (options.skipValidation) {\n    return json;\n  }\n\n  if (validatingModelInstance) {\n    // Strip away relations and other internal stuff.\n    // TODO 1: This should use `json.$toJson()` since we always validate the input representation!\n    // TODO 2: This should also keep the relations in the object because some validators may\n    //         depend on the relations.\n    json = clone(json, true, true);\n    // We can mutate `json` now that we took a copy of it.\n    options = Object.assign({}, options, { mutable: true });\n  }\n\n  const modelClass = model.constructor;\n  const validator = modelClass.getValidator();\n  const args = {\n    options,\n    model,\n    json,\n    ctx: Object.create(null)\n  };\n\n  validator.beforeValidate(args);\n  json = validator.validate(args);\n  validator.afterValidate(args);\n\n  if (validatingModelInstance) {\n    // If we cloned `json`, we need to copy the possible default values.\n    return inputJson.$set(json);\n  } else {\n    return json;\n  }\n}\n\nmodule.exports = {\n  validate\n};\n","'use strict';\n\nconst { isObject } = require('../utils/objectUtils');\n\n// Property keys needs to be prefixed with a non-numeric character so that\n// they are not considered indexes when used as object keys.\nconst PROP_KEY_PREFIX = 'k_';\n\nfunction values(model, args) {\n  switch (args.length) {\n    case 1:\n      return values1(model, args);\n    case 2:\n      return values2(model, args);\n    case 3:\n      return values3(model, args);\n    default:\n      return valuesN(model, args);\n  }\n}\n\nfunction propKey(model, props) {\n  switch (props.length) {\n    case 1:\n      return propKey1(model, props);\n    case 2:\n      return propKey2(model, props);\n    case 3:\n      return propKey3(model, props);\n    default:\n      return propKeyN(model, props);\n  }\n}\n\nfunction hasProps(model, props) {\n  for (let i = 0; i < props.length; ++i) {\n    const value = model[props[i]];\n\n    if (isNullOrUndefined(value)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction values1(model, args) {\n  return [model[args[0]]];\n}\n\nfunction values2(model, args) {\n  return [model[args[0]], model[args[1]]];\n}\n\nfunction values3(model, args) {\n  return [model[args[0]], model[args[1]], model[args[2]]];\n}\n\nfunction valuesN(model, args) {\n  const ret = new Array(args.length);\n\n  for (let i = 0, l = args.length; i < l; ++i) {\n    ret[i] = model[args[i]];\n  }\n\n  return ret;\n}\n\nfunction propKey1(model, props) {\n  return PROP_KEY_PREFIX + propToStr(model[props[0]]);\n}\n\nfunction propKey2(model, props) {\n  return PROP_KEY_PREFIX + propToStr(model[props[0]]) + ',' + propToStr(model[props[1]]);\n}\n\nfunction propKey3(model, props) {\n  return (\n    PROP_KEY_PREFIX +\n    propToStr(model[props[0]]) +\n    ',' +\n    propToStr(model[props[1]]) +\n    ',' +\n    propToStr(model[props[2]])\n  );\n}\n\nfunction propKeyN(model, props) {\n  let key = PROP_KEY_PREFIX;\n\n  for (let i = 0, l = props.length; i < l; ++i) {\n    key += propToStr(model[props[i]]);\n\n    if (i < l - 1) {\n      key += ',';\n    }\n  }\n\n  return key;\n}\n\nfunction propToStr(value) {\n  if (value === null) {\n    return 'null';\n  } else if (value === undefined) {\n    return 'undefined';\n  } else if (isObject(value)) {\n    return JSON.stringify(value);\n  } else {\n    return `${value}`;\n  }\n}\n\nfunction isNullOrUndefined(val) {\n  return val === null || val === undefined;\n}\n\nmodule.exports = {\n  PROP_KEY_PREFIX,\n  propToStr,\n  values,\n  hasProps,\n  propKey\n};\n","'use strict';\n\nfunction visitModels(models, modelClass, visitor) {\n  doVisit(models, modelClass, null, null, visitor);\n}\n\nfunction doVisit(models, modelClass, parent, rel, visitor) {\n  if (Array.isArray(models)) {\n    visitMany(models, modelClass, parent, rel, visitor);\n  } else if (models) {\n    visitOne(models, modelClass, parent, rel, visitor);\n  }\n}\n\nfunction visitMany(models, modelClass, parent, rel, visitor) {\n  for (let i = 0, l = models.length; i < l; ++i) {\n    visitOne(models[i], modelClass, parent, rel, visitor);\n  }\n}\n\nfunction visitOne(model, modelClass, parent, rel, visitor) {\n  if (model) {\n    visitor(model, modelClass, parent, rel);\n  }\n\n  const relationNames = modelClass.getRelationNames();\n\n  for (let i = 0, l = relationNames.length; i < l; ++i) {\n    const relationName = relationNames[i];\n    const relatedObj = model[relationName];\n\n    if (relatedObj) {\n      const relation = modelClass.getRelation(relationName);\n      doVisit(relatedObj, relation.relatedModelClass, model, relation, visitor);\n    }\n  }\n}\n\nmodule.exports = {\n  visitModels\n};\n","'use strict';\n\nconst { Model: NativeModel } = require('./model/Model');\nconst { QueryBuilder: NativeQueryBuilder } = require('./queryBuilder/QueryBuilder');\nconst { QueryBuilderBase } = require('./queryBuilder/QueryBuilderBase');\nconst { QueryBuilderOperation } = require('./queryBuilder/operations/QueryBuilderOperation');\nconst { RelationExpression } = require('./queryBuilder/RelationExpression');\nconst { ValidationError } = require('./model/ValidationError');\nconst { NotFoundError } = require('./model/NotFoundError');\nconst { AjvValidator: NativeAjvValidator } = require('./model/AjvValidator');\nconst { Validator: NativeValidator } = require('./model/Validator');\nconst { Relation } = require('./relations/Relation');\nconst { HasOneRelation } = require('./relations/hasOne/HasOneRelation');\nconst { HasManyRelation } = require('./relations/hasMany/HasManyRelation');\nconst { BelongsToOneRelation } = require('./relations/belongsToOne/BelongsToOneRelation');\nconst { HasOneThroughRelation } = require('./relations/hasOneThrough/HasOneThroughRelation');\nconst { ManyToManyRelation } = require('./relations/manyToMany/ManyToManyRelation');\nconst { transaction } = require('./transaction');\n\nconst {\n  snakeCaseMappers,\n  knexSnakeCaseMappers,\n  knexIdentifierMapping\n} = require('./utils/identifierMapping');\nconst { compose, mixin } = require('./utils/mixin');\nconst { ref } = require('./queryBuilder/ReferenceBuilder');\nconst { lit } = require('./queryBuilder/LiteralBuilder');\nconst { raw } = require('./queryBuilder/RawBuilder');\n\nconst { inherit } = require('../lib/utils/classUtils');\nconst { deprecate } = require('../lib/utils/deprecate');\n\n// We need to wrap the classes, that people can inherit, with ES5 classes\n// so that babel is able to use ES5 inheritance. sigh... Maybe people\n// should stop transpiling node apps to ES5 in the year 2019? Node 6\n// with full class support was released three years ago.\n\nfunction Model() {\n  // Nothing to do here.\n}\n\nfunction QueryBuilder(...args) {\n  NativeQueryBuilder.init(this, ...args);\n}\n\nfunction Validator(...args) {\n  NativeValidator.init(this, ...args);\n}\n\nfunction AjvValidator(...args) {\n  NativeAjvValidator.init(this, ...args);\n}\n\ninherit(Model, NativeModel);\ninherit(QueryBuilder, NativeQueryBuilder);\ninherit(Validator, NativeValidator);\ninherit(AjvValidator, NativeAjvValidator);\n\nModel.QueryBuilder = QueryBuilder;\n\nmodule.exports = {\n  Model,\n  QueryBuilder,\n  QueryBuilderBase,\n  QueryBuilderOperation,\n  RelationExpression,\n  ValidationError,\n  NotFoundError,\n  AjvValidator,\n  Validator,\n  Relation,\n  HasOneRelation,\n  HasManyRelation,\n  BelongsToOneRelation,\n  HasOneThroughRelation,\n  ManyToManyRelation,\n\n  transaction,\n  compose,\n  mixin,\n  ref,\n  lit,\n  raw,\n\n  snakeCaseMappers,\n  knexSnakeCaseMappers,\n  knexIdentifierMapping\n};\n\nObject.defineProperties(module.exports, {\n  Promise: {\n    enumerable: true,\n\n    get: () => {\n      deprecate(\n        'objection.Promise is deprecated and will be removed in 2.0.0. Bluebird dependency will be removed in 2.0.0.'\n      );\n      return require('bluebird');\n    }\n  },\n\n  lodash: {\n    enumerable: true,\n\n    get: () => {\n      deprecate(\n        'objection.lodash is deprecated and will be removed in 2.0.0. lodash dependency will be removed in 2.0.0.'\n      );\n      return require('lodash');\n    }\n  }\n});\n","'use strict';\n\nclass InternalOptions {\n  constructor() {\n    this.skipUndefined = false;\n    this.keepImplicitJoinProps = false;\n    this.isInternalQuery = false;\n    this.debug = false;\n  }\n\n  clone() {\n    const copy = new this.constructor();\n\n    copy.skipUndefined = this.skipUndefined;\n    copy.keepImplicitJoinProps = this.keepImplicitJoinProps;\n    copy.isInternalQuery = this.isInternalQuery;\n    copy.debug = this.debug;\n\n    return copy;\n  }\n}\n\nmodule.exports = {\n  InternalOptions\n};\n","'use strict';\n\nconst { QueryBuilderOperationSupport } = require('./QueryBuilderOperationSupport');\nconst { KnexOperation } = require('./operations/KnexOperation');\n\nclass JoinBuilder extends QueryBuilderOperationSupport {\n  using(...args) {\n    return this.addOperation(new KnexOperation('using'), args);\n  }\n\n  on(...args) {\n    return this.addOperation(new KnexOperation('on'), args);\n  }\n\n  orOn(...args) {\n    return this.addOperation(new KnexOperation('orOn'), args);\n  }\n\n  onBetween(...args) {\n    return this.addOperation(new KnexOperation('onBetween'), args);\n  }\n\n  onNotBetween(...args) {\n    return this.addOperation(new KnexOperation('onNotBetween'), args);\n  }\n\n  orOnBetween(...args) {\n    return this.addOperation(new KnexOperation('orOnBetween'), args);\n  }\n\n  orOnNotBetween(...args) {\n    return this.addOperation(new KnexOperation('orOnNotBetween'), args);\n  }\n\n  onIn(...args) {\n    return this.addOperation(new KnexOperation('onIn'), args);\n  }\n\n  onNotIn(...args) {\n    return this.addOperation(new KnexOperation('onNotIn'), args);\n  }\n\n  orOnIn(...args) {\n    return this.addOperation(new KnexOperation('orOnIn'), args);\n  }\n\n  orOnNotIn(...args) {\n    return this.addOperation(new KnexOperation('orOnNotIn'), args);\n  }\n\n  onNull(...args) {\n    return this.addOperation(new KnexOperation('onNull'), args);\n  }\n\n  orOnNull(...args) {\n    return this.addOperation(new KnexOperation('orOnNull'), args);\n  }\n\n  onNotNull(...args) {\n    return this.addOperation(new KnexOperation('onNotNull'), args);\n  }\n\n  orOnNotNull(...args) {\n    return this.addOperation(new KnexOperation('orOnNotNull'), args);\n  }\n\n  onExists(...args) {\n    return this.addOperation(new KnexOperation('onExists'), args);\n  }\n\n  orOnExists(...args) {\n    return this.addOperation(new KnexOperation('orOnExists'), args);\n  }\n\n  onNotExists(...args) {\n    return this.addOperation(new KnexOperation('onNotExists'), args);\n  }\n\n  orOnNotExists(...args) {\n    return this.addOperation(new KnexOperation('orOnNotExists'), args);\n  }\n\n  type(...args) {\n    return this.addOperation(new KnexOperation('type'), args);\n  }\n\n  andOn(...args) {\n    return this.addOperation(new KnexOperation('andOn'), args);\n  }\n\n  andOnIn(...args) {\n    return this.addOperation(new KnexOperation('andOnIn'), args);\n  }\n\n  andOnNotIn(...args) {\n    return this.addOperation(new KnexOperation('andOnNotIn'), args);\n  }\n\n  andOnNull(...args) {\n    return this.addOperation(new KnexOperation('andOnNull'), args);\n  }\n\n  andOnNotNull(...args) {\n    return this.addOperation(new KnexOperation('andOnNotNull'), args);\n  }\n\n  andOnExists(...args) {\n    return this.addOperation(new KnexOperation('andOnExists'), args);\n  }\n\n  andOnNotExists(...args) {\n    return this.addOperation(new KnexOperation('andOnNotExists'), args);\n  }\n\n  andOnBetween(...args) {\n    return this.addOperation(new KnexOperation('andOnBetween'), args);\n  }\n\n  andOnNotBetween(...args) {\n    return this.addOperation(new KnexOperation('andOnNotBetween'), args);\n  }\n\n  onVal(...args) {\n    return this.addOperation(new KnexOperation('onVal'), args);\n  }\n\n  andOnVal(...args) {\n    return this.addOperation(new KnexOperation('andOnVal'), args);\n  }\n\n  orOnVal(...args) {\n    return this.addOperation(new KnexOperation('orOnVal'), args);\n  }\n}\n\nmodule.exports = {\n  JoinBuilder\n};\n","'use strict';\n\nconst { asArray, isObject } = require('../utils/objectUtils');\nconst { buildArg } = require('../utils/buildUtils');\nconst { deprecate } = require('../utils/deprecate');\n\nclass LiteralBuilder {\n  constructor(value) {\n    this._value = value;\n    this._cast = null;\n    // Cast objects and arrays to json by default.\n    this._toJson = isObject(value);\n    this._toArray = false;\n  }\n\n  get cast() {\n    return this._cast;\n  }\n\n  castText() {\n    return this.castTo('text');\n  }\n\n  castInt() {\n    return this.castTo('integer');\n  }\n\n  castBigInt() {\n    return this.castTo('bigint');\n  }\n\n  castFloat() {\n    return this.castTo('float');\n  }\n\n  castDecimal() {\n    return this.castTo('decimal');\n  }\n\n  castReal() {\n    return this.castTo('real');\n  }\n\n  castBool() {\n    return this.castTo('boolean');\n  }\n\n  castJson() {\n    this._toArray = false;\n    this._toJson = true;\n    this._cast = 'jsonb';\n    return this;\n  }\n\n  castArray() {\n    deprecate(\n      'castArray() is deprecated. Use asArray() instead. castArray() will be removed in 2.0'\n    );\n    return this.asArray();\n  }\n\n  castType(sqlType) {\n    deprecate(\n      'castType(type) is deprecated. Use castTo(type) instead. castType(type) will be removed in 2.0'\n    );\n    return this.castTo(sqlType);\n  }\n\n  castTo(sqlType) {\n    this._cast = sqlType;\n    return this;\n  }\n\n  asArray() {\n    this._toJson = false;\n    this._toArray = true;\n    return this;\n  }\n\n  toKnexRaw(builder) {\n    let sql = null;\n    let bindings = null;\n\n    if (this._toJson) {\n      bindings = JSON.stringify(this._value);\n      sql = '?';\n    } else if (this._toArray) {\n      bindings = asArray(this._value).map(it => buildArg(it, builder));\n      sql = `ARRAY[${bindings.map(() => '?').join(', ')}]`;\n    } else {\n      bindings = this._value;\n      sql = '?';\n    }\n\n    if (this._cast) {\n      sql = `CAST(${sql} AS ${this._cast})`;\n    }\n\n    return builder.knex().raw(sql, bindings);\n  }\n}\n\nfunction lit(val) {\n  return new LiteralBuilder(val);\n}\n\nmodule.exports = {\n  LiteralBuilder,\n  lit\n};\n","'use strict';\n\nconst Bluebird = require('bluebird');\n\nconst { raw } = require('./RawBuilder');\nconst { deprecate } = require('../utils/deprecate');\nconst { createModifier } = require('../utils/createModifier');\nconst { ValidationErrorType } = require('../model/ValidationError');\nconst { isObject, isString, isFunction, last } = require('../utils/objectUtils');\nconst { RelationExpression, DuplicateRelationError } = require('./RelationExpression');\nconst { Selection } = require('./operations/select/Selection');\n\nconst { QueryBuilderContext } = require('./QueryBuilderContext');\nconst { QueryBuilderBase } = require('./QueryBuilderBase');\n\nconst { FindOperation } = require('./operations/FindOperation');\nconst { DeleteOperation } = require('./operations/DeleteOperation');\nconst { UpdateOperation } = require('./operations/UpdateOperation');\nconst { InsertOperation } = require('./operations/InsertOperation');\nconst { RelateOperation } = require('./operations/RelateOperation');\nconst { UnrelateOperation } = require('./operations/UnrelateOperation');\n\nconst { JoinEagerOperation } = require('./operations/eager/JoinEagerOperation');\nconst { NaiveEagerOperation } = require('./operations/eager/NaiveEagerOperation');\nconst { WhereInEagerOperation } = require('./operations/eager/WhereInEagerOperation');\n\nconst { InsertGraphAndFetchOperation } = require('./operations/InsertGraphAndFetchOperation');\nconst { UpsertGraphAndFetchOperation } = require('./operations/UpsertGraphAndFetchOperation');\nconst { InsertAndFetchOperation } = require('./operations/InsertAndFetchOperation');\nconst { UpdateAndFetchOperation } = require('./operations/UpdateAndFetchOperation');\nconst { JoinRelationOperation } = require('./operations/JoinRelationOperation');\nconst { OnBuildKnexOperation } = require('./operations/OnBuildKnexOperation');\nconst { InsertGraphOperation } = require('./operations/InsertGraphOperation');\nconst { UpsertGraphOperation } = require('./operations/UpsertGraphOperation');\nconst { RunBeforeOperation } = require('./operations/RunBeforeOperation');\nconst { RunAfterOperation } = require('./operations/RunAfterOperation');\nconst { FindByIdOperation } = require('./operations/FindByIdOperation');\nconst { FindByIdsOperation } = require('./operations/FindByIdsOperation');\nconst { OnBuildOperation } = require('./operations/OnBuildOperation');\nconst { OnErrorOperation } = require('./operations/OnErrorOperation');\nconst { SelectOperation } = require('./operations/select/SelectOperation');\nconst { EagerOperation } = require('./operations/eager/EagerOperation');\nconst { RangeOperation } = require('./operations/RangeOperation');\nconst { FirstOperation } = require('./operations/FirstOperation');\nconst { FromOperation } = require('./operations/FromOperation');\nconst { KnexOperation } = require('./operations/KnexOperation');\n\nclass QueryBuilder extends QueryBuilderBase {\n  static init(self, modelClass) {\n    super.init(self, modelClass);\n\n    self._resultModelClass = null;\n    self._explicitRejectValue = null;\n    self._explicitResolveValue = null;\n\n    self._allowedUpsertExpression = null;\n    self._findOperationOptions = modelClass.defaultFindOptions;\n\n    self._findOperationFactory = findOperationFactory;\n    self._insertOperationFactory = insertOperationFactory;\n    self._updateOperationFactory = updateOperationFactory;\n    self._patchOperationFactory = patchOperationFactory;\n    self._relateOperationFactory = relateOperationFactory;\n    self._unrelateOperationFactory = unrelateOperationFactory;\n    self._deleteOperationFactory = deleteOperationFactory;\n  }\n\n  static get QueryBuilderContext() {\n    return QueryBuilderContext;\n  }\n\n  static parseRelationExpression(expr) {\n    return RelationExpression.create(expr).toPojo();\n  }\n\n  tableNameFor(modelClassOrTableName, newTableName) {\n    return super.tableNameFor(getTableName(modelClassOrTableName), newTableName);\n  }\n\n  tableName(newTableName) {\n    return this.tableNameFor(this.modelClass().getTableName(), newTableName);\n  }\n\n  tableRef() {\n    return this.tableRefFor(this.modelClass().getTableName());\n  }\n\n  aliasFor(modelClassOrTableName, alias) {\n    return super.aliasFor(getTableName(modelClassOrTableName), alias);\n  }\n\n  alias(alias) {\n    return this.aliasFor(this.modelClass().getTableName(), alias);\n  }\n\n  fullIdColumnFor(modelClass) {\n    const tableName = this.tableRefFor(modelClass.getTableName());\n    const idColumn = modelClass.getIdColumn();\n\n    if (Array.isArray(idColumn)) {\n      return idColumn.map(col => `${tableName}.${col}`);\n    } else {\n      return `${tableName}.${idColumn}`;\n    }\n  }\n\n  fullIdColumn() {\n    return this.fullIdColumnFor(this.modelClass());\n  }\n\n  applyModifier(...args) {\n    for (const arg of args) {\n      const modifier = createModifier({\n        modifier: arg,\n        modelClass: this.modelClass()\n      });\n\n      modifier(this);\n    }\n\n    return this;\n  }\n\n  applyFilter(...args) {\n    return this.applyModifier(...args);\n  }\n\n  modify(...args) {\n    const arg = args[0];\n    if (isFunction(arg)) {\n      super.modify(...args);\n    } else if (arg) {\n      this.applyModifier(...args);\n    }\n    return this;\n  }\n\n  reject(error) {\n    this._explicitRejectValue = error;\n    return this;\n  }\n\n  resolve(value) {\n    this._explicitResolveValue = value;\n    return this;\n  }\n\n  isExplicitlyResolvedOrRejected() {\n    return !!(this._explicitRejectValue || this._explicitResolveValue);\n  }\n\n  isExecutable() {\n    return !this.isExplicitlyResolvedOrRejected() && !findQueryExecutorOperation(this);\n  }\n\n  findOperationFactory(factory) {\n    this._findOperationFactory = factory;\n    return this;\n  }\n\n  insertOperationFactory(factory) {\n    this._insertOperationFactory = factory;\n    return this;\n  }\n\n  updateOperationFactory(factory) {\n    this._updateOperationFactory = factory;\n    return this;\n  }\n\n  patchOperationFactory(factory) {\n    this._patchOperationFactory = factory;\n    return this;\n  }\n\n  deleteOperationFactory(factory) {\n    this._deleteOperationFactory = factory;\n    return this;\n  }\n\n  relateOperationFactory(factory) {\n    this._relateOperationFactory = factory;\n    return this;\n  }\n\n  unrelateOperationFactory(factory) {\n    this._unrelateOperationFactory = factory;\n    return this;\n  }\n\n  eagerAlgorithm(algorithm, eagerOptions) {\n    ensureEagerOperation(this, algorithm);\n\n    if (eagerOptions) {\n      this.eagerOptions(eagerOptions);\n    }\n\n    return this;\n  }\n\n  eager(exp, modifiers) {\n    const eagerOp = ensureEagerOperation(this);\n\n    eagerOp.expression = parseRelationExpression(this.modelClass(), exp);\n    eagerOp.modifiers = modifiers;\n\n    checkEager(this);\n    return this;\n  }\n\n  joinEager(exp, modifiers) {\n    return this.eagerAlgorithm(getJoinEagerAlgorithm(this)).eager(exp, modifiers);\n  }\n\n  naiveEager(exp, modifiers) {\n    return this.eagerAlgorithm(getNaiveEagerAlgorithm(this)).eager(exp, modifiers);\n  }\n\n  mergeEager(exp, modifiers) {\n    const eagerOp = ensureEagerOperation(this);\n\n    eagerOp.expression = eagerOp.expression.merge(parseRelationExpression(this.modelClass(), exp));\n\n    eagerOp.modifiers = Object.assign({}, eagerOp.modifiers, modifiers);\n\n    checkEager(this);\n    return this;\n  }\n\n  mergeJoinEager(exp, modifiers) {\n    return this.eagerAlgorithm(this.modelClass().JoinEagerAlgorithm).mergeEager(exp, modifiers);\n  }\n\n  mergeNaiveEager(exp, modifiers) {\n    return this.eagerAlgorithm(this.modelClass().NaiveEagerAlgorithm).mergeEager(exp, modifiers);\n  }\n\n  allowEager(exp) {\n    const eagerOp = ensureEagerOperation(this);\n    eagerOp.allowedExpression = parseRelationExpression(this.modelClass(), exp);\n\n    checkEager(this);\n    return this;\n  }\n\n  mergeAllowEager(exp) {\n    const eagerOp = ensureEagerOperation(this);\n\n    if (eagerOp.allowedExpression) {\n      eagerOp.allowedExpression = eagerOp.allowedExpression.merge(\n        parseRelationExpression(this.modelClass(), exp)\n      );\n    } else {\n      eagerOp.allowedExpression = parseRelationExpression(this.modelClass(), exp);\n    }\n\n    checkEager(this);\n    return this;\n  }\n\n  eagerObject() {\n    const eagerOp = this.findOperation(EagerOperation);\n\n    if (eagerOp && !eagerOp.expression.isEmpty) {\n      return eagerOp.expression.toPojo();\n    } else {\n      return null;\n    }\n  }\n\n  eagerModifiers() {\n    const eagerOp = this.findOperation(EagerOperation);\n\n    if (eagerOp && !eagerOp.expression.isEmpty) {\n      return Object.assign({}, eagerOp.modifiers);\n    } else {\n      return {};\n    }\n  }\n\n  eagerModifiersAtPath() {\n    const eagerOp = this.findOperation(EagerOperation);\n\n    if (eagerOp && !eagerOp.expression.isEmpty) {\n      return eagerOp.modifiersAtPath.map(it => Object.assign({}, it));\n    } else {\n      return [];\n    }\n  }\n\n  modifyEager(path, modifier) {\n    const eagerOp = ensureEagerOperation(this);\n    eagerOp.modifiersAtPath.push({ path, modifier });\n    return this;\n  }\n\n  filterEager(...args) {\n    return this.modifyEager(...args);\n  }\n\n  allowUpsert(exp) {\n    this._allowedUpsertExpression = exp || null;\n\n    if (isString(this._allowedUpsertExpression)) {\n      this._allowedUpsertExpression = parseRelationExpression(\n        this.modelClass(),\n        this._allowedUpsertExpression\n      );\n    }\n\n    return this;\n  }\n\n  allowedUpsertExpression() {\n    return this._allowedUpsertExpression;\n  }\n\n  allowInsert(exp) {\n    return this.allowUpsert(exp);\n  }\n\n  eagerOptions(opt) {\n    const eagerOp = ensureEagerOperation(this);\n    eagerOp.eagerOptions = Object.assign({}, eagerOp.eagerOptions, opt);\n    return this;\n  }\n\n  findOptions(opt) {\n    if (arguments.length !== 0) {\n      this._findOperationOptions = Object.assign({}, this._findOperationOptions, opt);\n      return this;\n    } else {\n      return this._findOperationOptions;\n    }\n  }\n\n  resultModelClass() {\n    return this._resultModelClass || this.modelClass();\n  }\n\n  isFind() {\n    return !(\n      this.isInsert() ||\n      this.isUpdate() ||\n      this.isDelete() ||\n      this.isRelate() ||\n      this.isUnrelate()\n    );\n  }\n\n  isInsert() {\n    return this.has(InsertOperation);\n  }\n\n  isUpdate() {\n    return this.has(UpdateOperation);\n  }\n\n  isDelete() {\n    return this.has(DeleteOperation);\n  }\n\n  isRelate() {\n    return this.has(RelateOperation);\n  }\n\n  isUnrelate() {\n    return this.has(UnrelateOperation);\n  }\n\n  hasWheres() {\n    return this.has(QueryBuilderBase.WhereSelector);\n  }\n\n  hasSelects() {\n    return this.has(QueryBuilderBase.SelectSelector);\n  }\n\n  hasEager() {\n    const eagerOp = this.findOperation(EagerOperation);\n    return !!eagerOp && !eagerOp.expression.isEmpty;\n  }\n\n  isSelectAll() {\n    if (this._operations.length === 0) {\n      return true;\n    }\n\n    const tableRef = this.tableRef();\n    const tableName = this.tableNameFor(this.modelClass().getTableName());\n\n    return this.everyOperation(op => {\n      if (op.constructor === SelectOperation) {\n        // SelectOperations with zero selections are the ones that only have\n        // raw items or other non-trivial selections.\n        return (\n          op.selections.length > 0 &&\n          op.selections.every(select => {\n            return (!select.table || select.table === tableRef) && select.column === '*';\n          })\n        );\n      } else if (op.constructor === FromOperation) {\n        return op.table === tableName;\n      } else if (op.name === 'as' || op.is(FindOperation)) {\n        return true;\n      } else {\n        return false;\n      }\n    });\n  }\n\n  isFindQuery() {\n    deprecate(\n      `isFindQuery is deprecated. Use isFind instead. This method will be removed in version 2.0`\n    );\n    return this.isFind();\n  }\n\n  isEagerQuery() {\n    deprecate(\n      `isEagerQuery is deprecated. Use hasEager instead. This method will be removed in version 2.0`\n    );\n    return this.hasEager();\n  }\n\n  toString() {\n    try {\n      return this.toKnexQuery().toString();\n    } catch (err) {\n      return `This query cannot be built synchronously. Consider using debug() method instead.`;\n    }\n  }\n\n  toSql() {\n    return this.toString();\n  }\n\n  toFindQuery() {\n    return this.clone().clear(\n      op => op.is(InsertOperation) || op.is(UpdateOperation) || op.is(DeleteOperation)\n    );\n  }\n\n  clone() {\n    const builder = new this.constructor(this.modelClass());\n\n    // Call the super class's clone implementation.\n    this.baseCloneInto(builder);\n\n    builder._resultModelClass = this._resultModelClass;\n\n    builder._explicitRejectValue = this._explicitRejectValue;\n    builder._explicitResolveValue = this._explicitResolveValue;\n\n    builder._allowedUpsertExpression = this._allowedUpsertExpression;\n    builder._findOperationOptions = this._findOperationOptions;\n\n    builder._findOperationFactory = this._findOperationFactory;\n    builder._insertOperationFactory = this._insertOperationFactory;\n    builder._updateOperationFactory = this._updateOperationFactory;\n    builder._patchOperationFactory = this._patchOperationFactory;\n    builder._relateOperationFactory = this._relateOperationFactory;\n    builder._unrelateOperationFactory = this._unrelateOperationFactory;\n    builder._deleteOperationFactory = this._deleteOperationFactory;\n\n    return builder;\n  }\n\n  clearEager() {\n    this.clear(EagerOperation);\n    return this;\n  }\n\n  clearReject() {\n    this._explicitRejectValue = null;\n    return this;\n  }\n\n  clearResolve() {\n    this._explicitResolveValue = null;\n    return this;\n  }\n\n  castTo(modelClass) {\n    this._resultModelClass = modelClass;\n    return this;\n  }\n\n  then(...args) {\n    const promise = this.execute();\n    return promise.then(...args);\n  }\n\n  map(...args) {\n    const promise = this.execute();\n    return promise.map(...args);\n  }\n\n  reduce(...args) {\n    const promise = this.execute();\n    return promise.reduce(...args);\n  }\n\n  catch(...args) {\n    const promise = this.execute();\n    return promise.catch(...args);\n  }\n\n  return(...args) {\n    const promise = this.execute();\n    return promise.return(...args);\n  }\n\n  reflect() {\n    const promise = this.execute();\n    return promise.reflect();\n  }\n\n  bind(...args) {\n    const promise = this.execute();\n    return promise.bind(...args);\n  }\n\n  asCallback(...args) {\n    const promise = this.execute();\n    return promise.asCallback(...args);\n  }\n\n  nodeify(...args) {\n    const promise = this.execute();\n    return promise.nodeify(...args);\n  }\n\n  resultSize() {\n    const knex = this.knex();\n    const builder = this.clone().clear(/orderBy|offset|limit/);\n\n    const countQuery = knex.count('* as count').from(knexBuilder => {\n      builder.toKnexQuery(knexBuilder).as('temp');\n    });\n\n    if (this.internalOptions().debug) {\n      countQuery.debug();\n    }\n\n    return countQuery.then(\n      result => (result[0] && result[0].count ? parseInt(result[0].count, 10) : 0)\n    );\n  }\n\n  toKnexQuery(knexBuilder = this.knex().queryBuilder()) {\n    // Take a clone so that we don't modify this instance during build.\n    let builder = this.clone();\n\n    builder = addImplicitOperations(builder);\n    builder = callOnBuildHooks(builder);\n\n    const queryExecutorOperation = findQueryExecutorOperation(builder);\n\n    if (queryExecutorOperation) {\n      // If the query executor is set, we build the builder that it returns.\n      return queryExecutorOperation.queryExecutor(builder).toKnexQuery();\n    } else {\n      return buildKnexQuery(builder, knexBuilder);\n    }\n  }\n\n  execute() {\n    // Take a clone so that we don't modify this instance during execution.\n    const builder = this.clone();\n\n    return Bluebird.try(() => beforeExecute(builder))\n      .then(() => doExecute(builder))\n      .then(result => afterExecute(builder, result))\n      .catch(error => handleExecuteError(builder, error));\n  }\n\n  pluck(propertyName) {\n    return this.runAfter(result => {\n      if (Array.isArray(result)) {\n        return result.map(it => it && it[propertyName]);\n      } else if (isObject(result)) {\n        return result[propertyName];\n      } else {\n        return result;\n      }\n    });\n  }\n\n  throwIfNotFound() {\n    return this.runAfter(result => {\n      if (\n        (Array.isArray(result) && result.length === 0) ||\n        result === null ||\n        result === undefined ||\n        result === 0\n      ) {\n        throw this.modelClass().createNotFoundError(this.context());\n      } else {\n        return result;\n      }\n    });\n  }\n\n  findSelection(selection, explicit = false) {\n    let noSelectStatements = true;\n    let selectionInstance = null;\n\n    this.forEachOperation(true, op => {\n      if (op.constructor === SelectOperation) {\n        selectionInstance = op.findSelection(this, selection);\n        noSelectStatements = false;\n\n        if (selectionInstance) {\n          return false;\n        }\n      }\n    });\n\n    if (selectionInstance) {\n      return selectionInstance;\n    }\n\n    if (noSelectStatements && !explicit) {\n      const selectAll = new Selection(this.tableRef(), '*');\n\n      if (Selection.doesSelect(this, selectAll, selection)) {\n        return selectAll;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }\n\n  findAllSelections() {\n    let allSelections = [];\n\n    this.forEachOperation(true, op => {\n      if (op.constructor === SelectOperation) {\n        allSelections = allSelections.concat(op.selections);\n      }\n    });\n\n    return allSelections;\n  }\n\n  hasSelection(selection, explicit) {\n    return this.findSelection(selection, explicit) !== null;\n  }\n\n  hasSelectionAs(selection, alias, explicit) {\n    selection = Selection.create(selection);\n    const foundSelection = this.findSelection(selection, explicit);\n\n    if (foundSelection === null) {\n      return false;\n    } else {\n      if (foundSelection.column === '*') {\n        // * selects the columns with their column names as aliases.\n        return selection.column === alias;\n      } else {\n        return foundSelection.name === alias;\n      }\n    }\n  }\n\n  traverse(modelClass, traverser) {\n    if (typeof traverser === 'undefined') {\n      traverser = modelClass;\n      modelClass = null;\n    }\n\n    return this.runAfter(result => {\n      this.resultModelClass().traverse(modelClass, result, traverser);\n      return result;\n    });\n  }\n\n  pick(modelClass, properties) {\n    if (typeof properties === 'undefined') {\n      properties = modelClass;\n      modelClass = null;\n    }\n\n    // Turn the properties into a hash for performance.\n    properties = properties.reduce((obj, prop) => {\n      obj[prop] = true;\n      return obj;\n    }, {});\n\n    return this.traverse(modelClass, model => {\n      model.$pick(properties);\n    });\n  }\n\n  omit(modelClass, properties) {\n    if (typeof properties === 'undefined') {\n      properties = modelClass;\n      modelClass = null;\n    }\n\n    // Turn the properties into a hash for performance.\n    properties = properties.reduce((obj, prop) => {\n      obj[prop] = true;\n      return obj;\n    }, {});\n\n    return this.traverse(modelClass, model => {\n      model.$omit(properties);\n    });\n  }\n\n  page(page, pageSize) {\n    return this.range(+page * +pageSize, (+page + 1) * +pageSize - 1);\n  }\n\n  columnInfo({ table = null } = {}) {\n    table = table || this.tableNameFor(this.modelClass().getTableName());\n\n    const knex = this.knex();\n    const tableParts = table.split('.');\n    const columnInfoQuery = knex(last(tableParts)).columnInfo();\n\n    if (tableParts.length > 1) {\n      columnInfoQuery.withSchema(tableParts[0]);\n    }\n\n    if (this.internalOptions().debug) {\n      columnInfoQuery.debug();\n    }\n\n    return columnInfoQuery;\n  }\n\n  withSchema(schema) {\n    this.internalContext().onBuild.push(builder => {\n      if (!builder.has(/withSchema/)) {\n        // Need to push this operation to the front because knex doesn't use the\n        // schema for operations called before `withSchema`.\n        builder.addOperationToFront(new KnexOperation('withSchema'), [schema]);\n      }\n    });\n\n    return this;\n  }\n\n  debug /* istanbul ignore next */() {\n    this.internalOptions().debug = true;\n    this.internalContext().onBuild.push(builder => {\n      builder.addOperation(new KnexOperation('debug'), []);\n    });\n\n    return this;\n  }\n\n  insert(modelsOrObjects) {\n    return writeOperation(this, () => {\n      const insertOperation = this._insertOperationFactory(this);\n\n      this.addOperation(insertOperation, [modelsOrObjects]);\n    });\n  }\n\n  insertAndFetch(modelsOrObjects) {\n    return writeOperation(this, () => {\n      const insertOperation = this._insertOperationFactory(this);\n\n      const insertAndFetchOperation = new InsertAndFetchOperation('insertAndFetch', {\n        delegate: insertOperation\n      });\n\n      this.addOperation(insertAndFetchOperation, [modelsOrObjects]);\n    });\n  }\n\n  insertGraph(modelsOrObjects, opt) {\n    return writeOperation(this, () => {\n      const insertOperation = this._insertOperationFactory(this);\n\n      const insertGraphOperation = new InsertGraphOperation('insertGraph', {\n        delegate: insertOperation,\n        opt\n      });\n\n      this.addOperation(insertGraphOperation, [modelsOrObjects]);\n    });\n  }\n\n  insertWithRelated(...args) {\n    deprecate(\n      `insertWithRelated is deprecated. Use insertGraph instead. This method will be removed in version 2.0`\n    );\n    return this.insertGraph(...args);\n  }\n\n  insertGraphAndFetch(modelsOrObjects, opt) {\n    return writeOperation(this, () => {\n      const insertOperation = this._insertOperationFactory(this);\n\n      const insertGraphOperation = new InsertGraphOperation('insertGraph', {\n        delegate: insertOperation,\n        opt\n      });\n\n      const insertGraphAndFetchOperation = new InsertGraphAndFetchOperation('insertGraphAndFetch', {\n        delegate: insertGraphOperation\n      });\n\n      return this.addOperation(insertGraphAndFetchOperation, [modelsOrObjects]);\n    });\n  }\n\n  insertWithRelatedAndFetch(...args) {\n    deprecate(\n      `insertWithRelatedAndFetch is deprecated. Use insertGraphAndFetch instead. This method will be removed in version 2.0`\n    );\n    return this.insertGraphAndFetch(...args);\n  }\n\n  update(modelOrObject) {\n    return writeOperation(this, () => {\n      const updateOperation = this._updateOperationFactory(this);\n\n      this.addOperation(updateOperation, [modelOrObject]);\n    });\n  }\n\n  updateAndFetch(modelOrObject) {\n    return writeOperation(this, () => {\n      const updateOperation = this._updateOperationFactory(this);\n\n      if (!(updateOperation.instance instanceof this.modelClass())) {\n        throw new Error('updateAndFetch can only be called for instance operations');\n      }\n\n      const updateAndFetch = new UpdateAndFetchOperation('updateAndFetch', {\n        delegate: updateOperation\n      });\n\n      // patchOperation is an instance update operation that already adds the\n      // required \"where id = $\" clause.\n      updateAndFetch.skipIdWhere = true;\n\n      this.addOperation(updateAndFetch, [updateOperation.instance.$id(), modelOrObject]);\n    });\n  }\n\n  updateAndFetchById(id, modelOrObject) {\n    return writeOperation(this, () => {\n      const updateOperation = this._updateOperationFactory(this);\n\n      const updateAndFetch = new UpdateAndFetchOperation('updateAndFetch', {\n        delegate: updateOperation\n      });\n\n      this.addOperation(updateAndFetch, [id, modelOrObject]);\n    });\n  }\n\n  upsertGraph(modelsOrObjects, upsertOptions) {\n    return writeOperation(this, () => {\n      const upsertGraphOperation = new UpsertGraphOperation('upsertGraph', {\n        upsertOptions\n      });\n\n      this.addOperation(upsertGraphOperation, [modelsOrObjects]);\n    });\n  }\n\n  upsertGraphAndFetch(modelsOrObjects, upsertOptions) {\n    return writeOperation(this, () => {\n      const upsertGraphOperation = new UpsertGraphOperation('upsertGraph', {\n        upsertOptions\n      });\n\n      const upsertGraphAndFetchOperation = new UpsertGraphAndFetchOperation('upsertGraphAndFetch', {\n        delegate: upsertGraphOperation\n      });\n\n      return this.addOperation(upsertGraphAndFetchOperation, [modelsOrObjects]);\n    });\n  }\n\n  patch(modelOrObject) {\n    return writeOperation(this, () => {\n      const patchOperation = this._patchOperationFactory(this);\n\n      this.addOperation(patchOperation, [modelOrObject]);\n    });\n  }\n\n  patchAndFetch(modelOrObject) {\n    return writeOperation(this, () => {\n      const patchOperation = this._patchOperationFactory(this);\n\n      if (!(patchOperation.instance instanceof this.modelClass())) {\n        throw new Error('patchAndFetch can only be called for instance operations');\n      }\n\n      const patchAndFetch = new UpdateAndFetchOperation('patchAndFetch', {\n        delegate: patchOperation\n      });\n\n      // patchOperation is an instance update operation that already adds the\n      // required \"where id = $\" clause.\n      patchAndFetch.skipIdWhere = true;\n\n      this.addOperation(patchAndFetch, [patchOperation.instance.$id(), modelOrObject]);\n    });\n  }\n\n  patchAndFetchById(id, modelOrObject) {\n    return writeOperation(this, () => {\n      const patchOperation = this._patchOperationFactory(this);\n\n      const patchAndFetch = new UpdateAndFetchOperation('patchAndFetch', {\n        delegate: patchOperation\n      });\n\n      this.addOperation(patchAndFetch, [id, modelOrObject]);\n    });\n  }\n\n  delete(...args) {\n    return writeOperation(this, () => {\n      if (args.length) {\n        throw new Error(\n          `Don't pass arguments to delete(). You should use it like this: delete().where('foo', 'bar').andWhere(...)`\n        );\n      }\n\n      const deleteOperation = this._deleteOperationFactory(this);\n      this.addOperation(deleteOperation, args);\n    });\n  }\n\n  del(...args) {\n    return this.delete(...args);\n  }\n\n  relate(...args) {\n    return writeOperation(this, () => {\n      const relateOperation = this._relateOperationFactory(this);\n\n      this.addOperation(relateOperation, args);\n    });\n  }\n\n  unrelate(...args) {\n    return writeOperation(this, () => {\n      if (args.length) {\n        throw new Error(\n          `Don't pass arguments to unrelate(). You should use it like this: unrelate().where('foo', 'bar').andWhere(...)`\n        );\n      }\n\n      const unrelateOperation = this._unrelateOperationFactory(this);\n      this.addOperation(unrelateOperation, args);\n    });\n  }\n\n  increment(propertyName, howMuch) {\n    const columnName = this.modelClass().propertyNameToColumnName(propertyName);\n\n    return this.patch({\n      [columnName]: raw('?? + ?', [columnName, howMuch])\n    });\n  }\n\n  decrement(propertyName, howMuch) {\n    const columnName = this.modelClass().propertyNameToColumnName(propertyName);\n\n    return this.patch({\n      [columnName]: raw('?? - ?', [columnName, howMuch])\n    });\n  }\n\n  findOne(...args) {\n    return this.where.apply(this, args).first();\n  }\n\n  range(...args) {\n    return this.addOperation(new RangeOperation('range'), args);\n  }\n\n  first(...args) {\n    return this.addOperation(new FirstOperation('first'), args);\n  }\n\n  joinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'innerJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  innerJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'innerJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  outerJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'outerJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  fullOuterJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'fullOuterJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  leftJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'leftJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  leftOuterJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'leftOuterJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  rightJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'rightJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  rightOuterJoinRelation(expression, options) {\n    ensureJoinRelationOperation(this, 'rightOuterJoin').addCall({\n      expression,\n      options\n    });\n\n    return this;\n  }\n\n  deleteById(...args) {\n    return this.findById(...args).delete();\n  }\n\n  findById(...args) {\n    return this.addOperation(new FindByIdOperation('findById'), args).first();\n  }\n\n  findByIds(...args) {\n    return this.addOperation(new FindByIdsOperation('findByIds'), args);\n  }\n\n  runBefore(...args) {\n    return this.addOperation(new RunBeforeOperation('runBefore'), args);\n  }\n\n  onBuild(...args) {\n    return this.addOperation(new OnBuildOperation('onBuild'), args);\n  }\n\n  onBuildKnex(...args) {\n    return this.addOperation(new OnBuildKnexOperation('onBuildKnex'), args);\n  }\n\n  runAfter(...args) {\n    return this.addOperation(new RunAfterOperation('runAfter'), args);\n  }\n\n  onError(...args) {\n    return this.addOperation(new OnErrorOperation('onError'), args);\n  }\n\n  from(...args) {\n    return this.addOperation(new FromOperation('from'), args);\n  }\n\n  table(...args) {\n    return this.addOperation(new FromOperation('table'), args);\n  }\n}\n\nObject.defineProperties(QueryBuilder.prototype, {\n  isObjectionQueryBuilder: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nfunction getTableName(modelClassOrTableName) {\n  if (isString(modelClassOrTableName)) {\n    return modelClassOrTableName;\n  } else {\n    return modelClassOrTableName.getTableName();\n  }\n}\n\nfunction ensureEagerOperation(builder, algorithm = null) {\n  const defaultEagerOptions = builder.modelClass().defaultEagerOptions;\n  const eagerOp = builder.findOperation(EagerOperation);\n\n  if (algorithm) {\n    const EagerOperationClass = getOperationClassForEagerAlgorithm(builder, algorithm);\n\n    if (eagerOp instanceof EagerOperationClass) {\n      return eagerOp;\n    } else {\n      const newEagerOp = new EagerOperationClass('eager', {\n        defaultEagerOptions\n      });\n\n      if (eagerOp) {\n        newEagerOp.cloneFrom(eagerOp);\n      }\n\n      builder.clear(EagerOperation);\n      builder.addOperation(newEagerOp);\n\n      return newEagerOp;\n    }\n  } else {\n    if (eagerOp) {\n      return eagerOp;\n    } else {\n      const EagerOperationClass = getOperationClassForEagerAlgorithm(\n        builder,\n        getDefaultEagerAlgorithm(builder)\n      );\n\n      const newEagerOp = new EagerOperationClass('eager', {\n        defaultEagerOptions\n      });\n\n      builder.addOperation(newEagerOp);\n\n      return newEagerOp;\n    }\n  }\n}\n\nfunction getDefaultEagerAlgorithm(builder) {\n  return builder.modelClass().defaultEagerAlgorithm;\n}\n\nfunction getJoinEagerAlgorithm(builder) {\n  return builder.modelClass().JoinEagerAlgorithm;\n}\n\nfunction getNaiveEagerAlgorithm(builder) {\n  return builder.modelClass().NaiveEagerAlgorithm;\n}\n\nfunction getOperationClassForEagerAlgorithm(builder, algorithm) {\n  if (algorithm === getJoinEagerAlgorithm(builder)) {\n    return JoinEagerOperation;\n  } else if (algorithm === getNaiveEagerAlgorithm(builder)) {\n    return NaiveEagerOperation;\n  } else {\n    return WhereInEagerOperation;\n  }\n}\n\nfunction parseRelationExpression(modelClass, exp) {\n  try {\n    return RelationExpression.create(exp);\n  } catch (err) {\n    if (err instanceof DuplicateRelationError) {\n      throw modelClass.createValidationError({\n        type: ValidationErrorType.RelationExpression,\n        message: `Duplicate relation name \"${\n          err.relationName\n        }\" in relation expression \"${exp}\". Use \"a.[b, c]\" instead of \"[a.b, a.c]\".`\n      });\n    } else {\n      throw modelClass.createValidationError({\n        type: ValidationErrorType.RelationExpression,\n        message: `Invalid relation expression \"${exp}\"`\n      });\n    }\n  }\n}\n\nfunction checkEager(builder) {\n  const eagerOp = builder.findOperation(EagerOperation);\n\n  if (!eagerOp) {\n    return;\n  }\n\n  const expr = eagerOp.expression;\n  const allowedExpr = eagerOp.allowedExpression;\n\n  if (expr.numChildren > 0 && allowedExpr && !allowedExpr.isSubExpression(expr)) {\n    const modelClass = builder.modelClass();\n\n    builder.reject(\n      modelClass.createValidationError({\n        type: ValidationErrorType.UnallowedRelation,\n        message: 'eager expression not allowed'\n      })\n    );\n  }\n}\n\nfunction findQueryExecutorOperation(builder) {\n  return builder.findOperation(op => op.hasQueryExecutor());\n}\n\nfunction beforeExecute(builder) {\n  let promise = Promise.resolve();\n\n  builder = addImplicitOperations(builder);\n\n  // Resolve all before hooks before building and executing the query\n  // and the rest of the hooks.\n  promise = chainOperationHooks(promise, builder, 'onBefore1');\n\n  promise = chainHooks(promise, builder, builder.context().runBefore);\n  promise = chainHooks(promise, builder, builder.internalContext().runBefore);\n\n  promise = chainOperationHooks(promise, builder, 'onBefore2');\n  promise = chainOperationHooks(promise, builder, 'onBefore3');\n\n  return promise;\n}\n\nfunction doExecute(builder) {\n  let promise = Promise.resolve();\n\n  builder = callOnBuildHooks(builder);\n  const queryExecutorOperation = findQueryExecutorOperation(builder);\n\n  const explicitRejectValue = builder._explicitRejectValue;\n  const explicitResolveValue = builder._explicitResolveValue;\n\n  if (explicitRejectValue !== null) {\n    promise = Promise.reject(explicitRejectValue);\n  } else if (explicitResolveValue !== null) {\n    promise = Promise.resolve(explicitResolveValue);\n  } else if (queryExecutorOperation !== null) {\n    promise = Promise.resolve(queryExecutorOperation.queryExecutor(builder));\n  } else {\n    promise = Promise.resolve(buildKnexQuery(builder));\n\n    promise = chainOperationHooks(promise, builder, 'onRawResult');\n    promise = promise.then(result => createModels(result, builder));\n  }\n\n  return promise;\n}\n\nfunction afterExecute(builder, result) {\n  let promise = Promise.resolve(result);\n\n  promise = chainOperationHooks(promise, builder, 'onAfter1');\n  promise = chainOperationHooks(promise, builder, 'onAfter2');\n\n  promise = chainHooks(promise, builder, builder.context().runAfter);\n  promise = chainHooks(promise, builder, builder.internalContext().runAfter);\n\n  promise = chainOperationHooks(promise, builder, 'onAfter3');\n\n  return promise;\n}\n\nfunction handleExecuteError(builder, err) {\n  let promise = Promise.reject(err);\n\n  builder.forEachOperation(true, op => {\n    if (op.hasOnError()) {\n      promise = promise.catch(err =>\n        builder.callAsyncOperationMethod(op, 'onError', [builder, err])\n      );\n    }\n  });\n\n  return promise;\n}\n\nfunction chainOperationHooks(promise, builder, hookName) {\n  return promise.then(result => {\n    let promise = Promise.resolve(result);\n\n    builder.forEachOperation(true, op => {\n      if (op.hasHook(hookName)) {\n        promise = promise.then(result =>\n          builder.callAsyncOperationMethod(op, hookName, [builder, result])\n        );\n      }\n    });\n\n    return promise;\n  });\n}\n\nfunction ensureJoinRelationOperation(builder, joinOperation) {\n  const opName = joinOperation + 'Relation';\n  let op = builder.findOperation(opName);\n\n  if (!op) {\n    op = new JoinRelationOperation(opName, { joinOperation });\n    builder.addOperation(op);\n  }\n\n  return op;\n}\n\nfunction addImplicitOperations(builder) {\n  if (builder.isFind()) {\n    // If no write operations have been called at this point this query is a\n    // find query and we need to call the custom find implementation.\n    addFindOperation(builder);\n  }\n\n  if (builder.hasEager()) {\n    moveEagerOperationToEnd(builder);\n  }\n\n  return builder;\n}\n\nfunction addFindOperation(builder) {\n  if (!builder.has(FindOperation)) {\n    const operation = builder._findOperationFactory(builder);\n    builder.addOperationToFront(operation, []);\n  }\n}\n\nfunction moveEagerOperationToEnd(builder) {\n  const eagerOp = builder.findOperation(EagerOperation);\n\n  builder.clear(EagerOperation);\n  builder.addOperation(eagerOp);\n}\n\nfunction callOnBuildHooks(builder) {\n  callOnBuildFuncs(builder, builder.context().onBuild);\n  callOnBuildFuncs(builder, builder.internalContext().onBuild);\n\n  builder.executeOnBuild();\n  return builder;\n}\n\nfunction callOnBuildFuncs(builder, func) {\n  if (isFunction(func)) {\n    func.call(builder, builder);\n  } else if (Array.isArray(func)) {\n    func.forEach(func => callOnBuildFuncs(builder, func));\n  }\n}\n\nfunction buildKnexQuery(builder, knexBuilder = builder.knex().queryBuilder()) {\n  builder.executeOnBuildKnex(knexBuilder);\n\n  const fromOperation = builder.findLastOperation(QueryBuilderBase.FromSelector);\n  const hasSelects = builder.has(QueryBuilderBase.SelectSelector);\n\n  // Set the table only if it hasn't been explicitly set yet.\n  if (!builder.isPartial() && !fromOperation) {\n    setDefaultTable(builder, knexBuilder);\n  }\n\n  // Only add `table.*` select if there are no explicit selects\n  // and `from` is a table name and not a subquery.\n  if (!builder.isPartial() && !hasSelects && (!fromOperation || fromOperation.table)) {\n    setDefaultSelect(builder, knexBuilder);\n  }\n\n  return knexBuilder;\n}\n\nfunction setDefaultTable(builder, knexBuilder) {\n  const table = builder.tableNameFor(builder.modelClass().getTableName());\n  const tableRef = builder.tableRef();\n\n  if (table === tableRef) {\n    knexBuilder.table(table);\n  } else {\n    knexBuilder.table(`${table} as ${tableRef}`);\n  }\n}\n\nfunction setDefaultSelect(builder, knexBuilder) {\n  const tableRef = builder.tableRef();\n\n  knexBuilder.select(`${tableRef}.*`);\n}\n\nfunction chainHooks(promise, builder, func) {\n  return promise.then(result => {\n    let promise = Promise.resolve(result);\n\n    if (isFunction(func)) {\n      promise = promise.then(result => func.call(builder, result, builder));\n    } else if (Array.isArray(func)) {\n      func.forEach(func => {\n        promise = chainHooks(promise, builder, func);\n      });\n    }\n\n    return promise;\n  });\n}\n\nfunction createModels(result, builder) {\n  const modelClass = builder.resultModelClass();\n\n  if (result === null || result === undefined) {\n    return null;\n  }\n\n  if (Array.isArray(result)) {\n    if (result.length && shouldBeConvertedToModel(result[0], modelClass)) {\n      for (let i = 0, l = result.length; i < l; ++i) {\n        result[i] = modelClass.fromDatabaseJson(result[i]);\n      }\n    }\n  } else if (shouldBeConvertedToModel(result, modelClass)) {\n    result = modelClass.fromDatabaseJson(result);\n  }\n\n  return result;\n}\n\nfunction shouldBeConvertedToModel(obj, modelClass) {\n  return isObject(obj) && !(obj instanceof modelClass);\n}\n\nfunction writeOperation(builder, cb) {\n  if (!builder.isFind()) {\n    return builder.reject(\n      new Error(\n        'Double call to a write method. ' +\n          'You can only call one of the write methods ' +\n          '(insert, update, patch, delete, relate, unrelate, increment, decrement) ' +\n          'and only once per query builder.'\n      )\n    );\n  }\n\n  try {\n    cb();\n    return builder;\n  } catch (err) {\n    return builder.reject(err);\n  }\n}\n\nfunction findOperationFactory() {\n  return new FindOperation('find');\n}\n\nfunction insertOperationFactory() {\n  return new InsertOperation('insert');\n}\n\nfunction updateOperationFactory() {\n  return new UpdateOperation('update');\n}\n\nfunction patchOperationFactory() {\n  return new UpdateOperation('patch', {\n    modelOptions: { patch: true }\n  });\n}\n\nfunction relateOperationFactory() {\n  return new RelateOperation('relate', {});\n}\n\nfunction unrelateOperationFactory() {\n  return new UnrelateOperation('unrelate', {});\n}\n\nfunction deleteOperationFactory() {\n  return new DeleteOperation('delete');\n}\n\nmodule.exports = {\n  QueryBuilder\n};\n","'use strict';\n\nconst { QueryBuilderOperationSupport } = require('./QueryBuilderOperationSupport');\nconst { isSqlite, isMsSql } = require('../utils/knexUtils');\n\nconst { KnexOperation } = require('./operations/KnexOperation');\nconst { SelectOperation } = require('./operations/select/SelectOperation');\nconst { ReturningOperation } = require('./operations/ReturningOperation');\nconst { WhereCompositeOperation } = require('./operations/WhereCompositeOperation');\nconst { WhereJsonPostgresOperation } = require('./operations/jsonApi/WhereJsonPostgresOperation');\n\nconst {\n  WhereInCompositeOperation\n} = require('./operations/whereInComposite/WhereInCompositeOperation');\nconst {\n  WhereInCompositeSqliteOperation\n} = require('./operations/whereInComposite/WhereInCompositeSqliteOperation');\nconst {\n  WhereInCompositeMsSqlOperation\n} = require('./operations/whereInComposite/WhereInCompositeMsSqlOperation');\nconst {\n  WhereJsonHasPostgresOperation\n} = require('./operations/jsonApi/WhereJsonHasPostgresOperation');\nconst {\n  WhereJsonNotObjectPostgresOperation\n} = require('./operations/jsonApi/WhereJsonNotObjectPostgresOperation');\n\nclass QueryBuilderBase extends QueryBuilderOperationSupport {\n  modify(...args) {\n    const func = args[0];\n\n    if (!func) {\n      return this;\n    }\n\n    if (args.length === 1) {\n      func.call(this, this);\n    } else {\n      args[0] = this;\n      func(...args);\n    }\n\n    return this;\n  }\n\n  transacting(trx) {\n    this._context.knex = trx || null;\n    return this;\n  }\n\n  select(...args) {\n    return this.addOperation(new SelectOperation('select'), args);\n  }\n\n  insert(...args) {\n    return this.addOperation(new KnexOperation('insert'), args);\n  }\n\n  update(...args) {\n    return this.addOperation(new KnexOperation('update'), args);\n  }\n\n  delete(...args) {\n    return this.addOperation(new KnexOperation('delete'), args);\n  }\n\n  del(...args) {\n    return this.delete(...args);\n  }\n\n  forUpdate(...args) {\n    return this.addOperation(new KnexOperation('forUpdate'), args);\n  }\n\n  forShare(...args) {\n    return this.addOperation(new KnexOperation('forShare'), args);\n  }\n\n  as(...args) {\n    return this.addOperation(new KnexOperation('as'), args);\n  }\n\n  columns(...args) {\n    return this.addOperation(new SelectOperation('columns'), args);\n  }\n\n  column(...args) {\n    return this.addOperation(new SelectOperation('column'), args);\n  }\n\n  from(...args) {\n    return this.addOperation(new KnexOperation('from'), args);\n  }\n\n  fromJS(...args) {\n    return this.addOperation(new KnexOperation('fromJS'), args);\n  }\n\n  into(...args) {\n    return this.addOperation(new KnexOperation('into'), args);\n  }\n\n  withSchema(...args) {\n    return this.addOperation(new KnexOperation('withSchema'), args);\n  }\n\n  table(...args) {\n    return this.addOperation(new KnexOperation('table'), args);\n  }\n\n  distinct(...args) {\n    return this.addOperation(new SelectOperation('distinct'), args);\n  }\n\n  join(...args) {\n    return this.addOperation(new KnexOperation('join'), args);\n  }\n\n  joinRaw(...args) {\n    return this.addOperation(new KnexOperation('joinRaw'), args);\n  }\n\n  innerJoin(...args) {\n    return this.addOperation(new KnexOperation('innerJoin'), args);\n  }\n\n  leftJoin(...args) {\n    return this.addOperation(new KnexOperation('leftJoin'), args);\n  }\n\n  leftOuterJoin(...args) {\n    return this.addOperation(new KnexOperation('leftOuterJoin'), args);\n  }\n\n  rightJoin(...args) {\n    return this.addOperation(new KnexOperation('rightJoin'), args);\n  }\n\n  rightOuterJoin(...args) {\n    return this.addOperation(new KnexOperation('rightOuterJoin'), args);\n  }\n\n  outerJoin(...args) {\n    return this.addOperation(new KnexOperation('outerJoin'), args);\n  }\n\n  fullOuterJoin(...args) {\n    return this.addOperation(new KnexOperation('fullOuterJoin'), args);\n  }\n\n  crossJoin(...args) {\n    return this.addOperation(new KnexOperation('crossJoin'), args);\n  }\n\n  where(...args) {\n    return this.addOperation(new KnexOperation('where'), args);\n  }\n\n  andWhere(...args) {\n    return this.addOperation(new KnexOperation('andWhere'), args);\n  }\n\n  orWhere(...args) {\n    return this.addOperation(new KnexOperation('orWhere'), args);\n  }\n\n  whereNot(...args) {\n    return this.addOperation(new KnexOperation('whereNot'), args);\n  }\n\n  orWhereNot(...args) {\n    return this.addOperation(new KnexOperation('orWhereNot'), args);\n  }\n\n  whereRaw(...args) {\n    return this.addOperation(new KnexOperation('whereRaw'), args);\n  }\n\n  andWhereRaw(...args) {\n    return this.addOperation(new KnexOperation('andWhereRaw'), args);\n  }\n\n  orWhereRaw(...args) {\n    return this.addOperation(new KnexOperation('orWhereRaw'), args);\n  }\n\n  whereWrapped(...args) {\n    return this.addOperation(new KnexOperation('whereWrapped'), args);\n  }\n\n  havingWrapped(...args) {\n    return this.addOperation(new KnexOperation('havingWrapped'), args);\n  }\n\n  whereExists(...args) {\n    return this.addOperation(new KnexOperation('whereExists'), args);\n  }\n\n  orWhereExists(...args) {\n    return this.addOperation(new KnexOperation('orWhereExists'), args);\n  }\n\n  whereNotExists(...args) {\n    return this.addOperation(new KnexOperation('whereNotExists'), args);\n  }\n\n  orWhereNotExists(...args) {\n    return this.addOperation(new KnexOperation('orWhereNotExists'), args);\n  }\n\n  whereIn(...args) {\n    return this.addOperation(new KnexOperation('whereIn'), args);\n  }\n\n  orWhereIn(...args) {\n    return this.addOperation(new KnexOperation('orWhereIn'), args);\n  }\n\n  whereNotIn(...args) {\n    return this.addOperation(new KnexOperation('whereNotIn'), args);\n  }\n\n  orWhereNotIn(...args) {\n    return this.addOperation(new KnexOperation('orWhereNotIn'), args);\n  }\n\n  whereNull(...args) {\n    return this.addOperation(new KnexOperation('whereNull'), args);\n  }\n\n  orWhereNull(...args) {\n    return this.addOperation(new KnexOperation('orWhereNull'), args);\n  }\n\n  whereNotNull(...args) {\n    return this.addOperation(new KnexOperation('whereNotNull'), args);\n  }\n\n  orWhereNotNull(...args) {\n    return this.addOperation(new KnexOperation('orWhereNotNull'), args);\n  }\n\n  whereBetween(...args) {\n    return this.addOperation(new KnexOperation('whereBetween'), args);\n  }\n\n  andWhereBetween(...args) {\n    return this.addOperation(new KnexOperation('andWhereBetween'), args);\n  }\n\n  whereNotBetween(...args) {\n    return this.addOperation(new KnexOperation('whereNotBetween'), args);\n  }\n\n  andWhereNotBetween(...args) {\n    return this.addOperation(new KnexOperation('andWhereNotBetween'), args);\n  }\n\n  orWhereBetween(...args) {\n    return this.addOperation(new KnexOperation('orWhereBetween'), args);\n  }\n\n  orWhereNotBetween(...args) {\n    return this.addOperation(new KnexOperation('orWhereNotBetween'), args);\n  }\n\n  groupBy(...args) {\n    return this.addOperation(new KnexOperation('groupBy'), args);\n  }\n\n  groupByRaw(...args) {\n    return this.addOperation(new KnexOperation('groupByRaw'), args);\n  }\n\n  orderBy(...args) {\n    return this.addOperation(new KnexOperation('orderBy'), args);\n  }\n\n  orderByRaw(...args) {\n    return this.addOperation(new KnexOperation('orderByRaw'), args);\n  }\n\n  union(...args) {\n    return this.addOperation(new KnexOperation('union'), args);\n  }\n\n  unionAll(...args) {\n    return this.addOperation(new KnexOperation('unionAll'), args);\n  }\n\n  intersect(...args) {\n    return this.addOperation(new KnexOperation('intersect'), args);\n  }\n\n  having(...args) {\n    return this.addOperation(new KnexOperation('having'), args);\n  }\n\n  orHaving(...args) {\n    return this.addOperation(new KnexOperation('orHaving'), args);\n  }\n\n  havingIn(...args) {\n    return this.addOperation(new KnexOperation('havingIn'), args);\n  }\n\n  orHavingIn(...args) {\n    return this.addOperation(new KnexOperation('havingIn'), args);\n  }\n\n  havingNotIn(...args) {\n    return this.addOperation(new KnexOperation('havingNotIn'), args);\n  }\n\n  orHavingNotIn(...args) {\n    return this.addOperation(new KnexOperation('orHavingNotIn'), args);\n  }\n\n  havingNull(...args) {\n    return this.addOperation(new KnexOperation('havingNull'), args);\n  }\n\n  orHavingNull(...args) {\n    return this.addOperation(new KnexOperation('orHavingNull'), args);\n  }\n\n  havingNotNull(...args) {\n    return this.addOperation(new KnexOperation('havingNotNull'), args);\n  }\n\n  orHavingNotNull(...args) {\n    return this.addOperation(new KnexOperation('orHavingNotNull'), args);\n  }\n\n  havingExists(...args) {\n    return this.addOperation(new KnexOperation('havingExists'), args);\n  }\n\n  orHavingExists(...args) {\n    return this.addOperation(new KnexOperation('orHavingExists'), args);\n  }\n\n  havingNotExists(...args) {\n    return this.addOperation(new KnexOperation('havingNotExists'), args);\n  }\n\n  orHavingNotExists(...args) {\n    return this.addOperation(new KnexOperation('orHavingNotExists'), args);\n  }\n\n  havingBetween(...args) {\n    return this.addOperation(new KnexOperation('havingBetween'), args);\n  }\n\n  orHavingBetween(...args) {\n    return this.addOperation(new KnexOperation('havingBetween'), args);\n  }\n\n  havingNotBetween(...args) {\n    return this.addOperation(new KnexOperation('havingNotBetween'), args);\n  }\n\n  orHavingNotBetween(...args) {\n    return this.addOperation(new KnexOperation('havingNotBetween'), args);\n  }\n\n  havingRaw(...args) {\n    return this.addOperation(new KnexOperation('havingRaw'), args);\n  }\n\n  orHavingRaw(...args) {\n    return this.addOperation(new KnexOperation('orHavingRaw'), args);\n  }\n\n  offset(...args) {\n    return this.addOperation(new KnexOperation('offset'), args);\n  }\n\n  limit(...args) {\n    return this.addOperation(new KnexOperation('limit'), args);\n  }\n\n  count(...args) {\n    return this.addOperation(new SelectOperation('count'), args);\n  }\n\n  countDistinct(...args) {\n    return this.addOperation(new SelectOperation('countDistinct'), args);\n  }\n\n  min(...args) {\n    return this.addOperation(new SelectOperation('min'), args);\n  }\n\n  max(...args) {\n    return this.addOperation(new SelectOperation('max'), args);\n  }\n\n  sum(...args) {\n    return this.addOperation(new SelectOperation('sum'), args);\n  }\n\n  sumDistinct(...args) {\n    return this.addOperation(new SelectOperation('sumDistinct'), args);\n  }\n\n  avg(...args) {\n    return this.addOperation(new SelectOperation('avg'), args);\n  }\n\n  avgDistinct(...args) {\n    return this.addOperation(new SelectOperation('avgDistinct'), args);\n  }\n\n  debug(...args) {\n    return this.addOperation(new KnexOperation('debug'), args);\n  }\n\n  returning(...args) {\n    return this.addOperation(new ReturningOperation('returning'), args);\n  }\n\n  truncate(...args) {\n    return this.addOperation(new KnexOperation('truncate'), args);\n  }\n\n  connection(...args) {\n    return this.addOperation(new KnexOperation('connection'), args);\n  }\n\n  options(...args) {\n    return this.addOperation(new KnexOperation('options'), args);\n  }\n\n  columnInfo(...args) {\n    return this.addOperation(new KnexOperation('columnInfo'), args);\n  }\n\n  off(...args) {\n    return this.addOperation(new KnexOperation('off'), args);\n  }\n\n  timeout(...args) {\n    return this.addOperation(new KnexOperation('timeout'), args);\n  }\n\n  with(...args) {\n    return this.addOperation(new KnexOperation('with'), args);\n  }\n\n  withRaw(...args) {\n    return this.addOperation(new KnexOperation('withRaw'), args);\n  }\n\n  withWrapped(...args) {\n    return this.addOperation(new KnexOperation('withWrapped'), args);\n  }\n\n  withRecursive(...args) {\n    return this.addOperation(new KnexOperation('withRecursive'), args);\n  }\n\n  whereComposite(...args) {\n    return this.addOperation(new WhereCompositeOperation('whereComposite'), args);\n  }\n\n  whereInComposite(...args) {\n    let operation = null;\n\n    if (isSqlite(this.knex())) {\n      operation = new WhereInCompositeSqliteOperation('whereInComposite');\n    } else if (isMsSql(this.knex())) {\n      operation = new WhereInCompositeMsSqlOperation('whereInComposite');\n    } else {\n      operation = new WhereInCompositeOperation('whereInComposite');\n    }\n\n    return this.addOperation(operation, args);\n  }\n\n  whereNotInComposite(...args) {\n    let operation = null;\n\n    if (isSqlite(this.knex())) {\n      operation = new WhereInCompositeSqliteOperation('whereNotInComposite', { prefix: 'not' });\n    } else if (isMsSql(this.knex())) {\n      operation = new WhereInCompositeMsSqlOperation('whereNotInComposite', { prefix: 'not' });\n    } else {\n      operation = new WhereInCompositeOperation('whereNotInComposite', { prefix: 'not' });\n    }\n\n    return this.addOperation(operation, args);\n  }\n\n  whereJsonSupersetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('whereJsonSupersetOf', { operator: '@>', bool: 'and' }),\n      args\n    );\n  }\n\n  orWhereJsonSupersetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('orWhereJsonSupersetOf', { operator: '@>', bool: 'or' }),\n      args\n    );\n  }\n\n  whereJsonNotSupersetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('whereJsonNotSupersetOf', {\n        operator: '@>',\n        bool: 'and',\n        prefix: 'not'\n      }),\n      args\n    );\n  }\n\n  orWhereJsonNotSupersetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('orWhereJsonNotSupersetOf', {\n        operator: '@>',\n        bool: 'or',\n        prefix: 'not'\n      }),\n      args\n    );\n  }\n\n  whereJsonSubsetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('whereJsonSubsetOf', { operator: '<@', bool: 'and' }),\n      args\n    );\n  }\n\n  orWhereJsonSubsetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('orWhereJsonSubsetOf', { operator: '<@', bool: 'or' }),\n      args\n    );\n  }\n\n  whereJsonNotSubsetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('whereJsonNotSubsetOf', {\n        operator: '<@',\n        bool: 'and',\n        prefix: 'not'\n      }),\n      args\n    );\n  }\n\n  orWhereJsonNotSubsetOf(...args) {\n    return this.addOperation(\n      new WhereJsonPostgresOperation('orWhereJsonNotSubsetOf', {\n        operator: '<@',\n        bool: 'or',\n        prefix: 'not'\n      }),\n      args\n    );\n  }\n\n  whereJsonNotArray(...args) {\n    return this.addOperation(\n      new WhereJsonNotObjectPostgresOperation('whereJsonNotArray', {\n        bool: 'and',\n        compareValue: []\n      }),\n      args\n    );\n  }\n\n  orWhereJsonNotArray(...args) {\n    return this.addOperation(\n      new WhereJsonNotObjectPostgresOperation('orWhereJsonNotArray', {\n        bool: 'or',\n        compareValue: []\n      }),\n      args\n    );\n  }\n\n  whereJsonNotObject(...args) {\n    return this.addOperation(\n      new WhereJsonNotObjectPostgresOperation('whereJsonNotObject', {\n        bool: 'and',\n        compareValue: {}\n      }),\n      args\n    );\n  }\n\n  orWhereJsonNotObject(...args) {\n    return this.addOperation(\n      new WhereJsonNotObjectPostgresOperation('orWhereJsonNotObject', {\n        bool: 'or',\n        compareValue: {}\n      }),\n      args\n    );\n  }\n\n  whereJsonHasAny(...args) {\n    return this.addOperation(\n      new WhereJsonHasPostgresOperation('whereJsonHasAny', { bool: 'and', operator: '?|' }),\n      args\n    );\n  }\n\n  orWhereJsonHasAny(...args) {\n    return this.addOperation(\n      new WhereJsonHasPostgresOperation('orWhereJsonHasAny', { bool: 'or', operator: '?|' }),\n      args\n    );\n  }\n\n  whereJsonHasAll(...args) {\n    return this.addOperation(\n      new WhereJsonHasPostgresOperation('whereJsonHasAll', { bool: 'and', operator: '?&' }),\n      args\n    );\n  }\n\n  orWhereJsonHasAll(...args) {\n    return this.addOperation(\n      new WhereJsonHasPostgresOperation('orWhereJsonHasAll', { bool: 'or', operator: '?&' }),\n      args\n    );\n  }\n\n  whereJsonIsArray(fieldExpression) {\n    return this.whereJsonSupersetOf(fieldExpression, []);\n  }\n\n  orWhereJsonIsArray(fieldExpression) {\n    return this.orWhereJsonSupersetOf(fieldExpression, []);\n  }\n\n  whereJsonIsObject(fieldExpression) {\n    return this.whereJsonSupersetOf(fieldExpression, {});\n  }\n\n  orWhereJsonIsObject(fieldExpression) {\n    return this.orWhereJsonSupersetOf(fieldExpression, {});\n  }\n\n  whereColumn(...args) {\n    return this.addOperation(new KnexOperation('whereColumn'), args);\n  }\n\n  andWhereColumn(...args) {\n    return this.addOperation(new KnexOperation('andWhereColumn'), args);\n  }\n\n  orWhereColumn(...args) {\n    return this.addOperation(new KnexOperation('orWhereColumn'), args);\n  }\n\n  whereNotColumn(...args) {\n    return this.addOperation(new KnexOperation('whereNotColumn'), args);\n  }\n\n  andWhereNotColumn(...args) {\n    return this.addOperation(new KnexOperation('andWhereNotColumn'), args);\n  }\n\n  orWhereNotColumn(...args) {\n    return this.addOperation(new KnexOperation('orWhereNotColumn'), args);\n  }\n}\n\nObject.defineProperties(QueryBuilderBase.prototype, {\n  isObjectionQueryBuilderBase: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nmodule.exports = {\n  QueryBuilderBase\n};\n","'use strict';\n\nconst { QueryBuilderContextBase } = require('./QueryBuilderContextBase');\n\nclass QueryBuilderContext extends QueryBuilderContextBase {\n  constructor(userContext) {\n    super(userContext);\n\n    this.runBefore = [];\n    this.runAfter = [];\n    this.onBuild = [];\n  }\n\n  clone() {\n    const ctx = super.clone();\n\n    ctx.runBefore = this.runBefore.slice();\n    ctx.runAfter = this.runAfter.slice();\n    ctx.onBuild = this.onBuild.slice();\n\n    return ctx;\n  }\n}\n\nmodule.exports = {\n  QueryBuilderContext\n};\n","'use strict';\n\nconst { InternalOptions } = require('./InternalOptions');\n\nclass QueryBuilderContextBase {\n  constructor(builder) {\n    this.userContext = builder ? new builder.constructor.QueryBuilderUserContext(builder) : null;\n    this.options = builder ? new this.constructor.InternalOptions() : null;\n    this.knex = null;\n\n    this.aliasMap = null;\n    this.tableMap = null;\n  }\n\n  static get InternalOptions() {\n    return InternalOptions;\n  }\n\n  clone() {\n    const ctx = new this.constructor();\n\n    ctx.userContext = this.userContext;\n    ctx.options = this.options.clone();\n    ctx.knex = this.knex;\n\n    ctx.aliasMap = this.aliasMap;\n    ctx.tableMap = this.tableMap;\n\n    return ctx;\n  }\n}\n\nmodule.exports = {\n  QueryBuilderContextBase\n};\n","'use strict';\n\nconst promiseUtils = require('../utils/promiseUtils');\n\nconst { isSubclassOf } = require('../utils/classUtils');\nconst { isString, isFunction, isRegExp, last } = require('../utils/objectUtils');\nconst { QueryBuilderOperation } = require('./operations/QueryBuilderOperation');\nconst { QueryBuilderContextBase } = require('./QueryBuilderContextBase');\nconst { QueryBuilderUserContext } = require('./QueryBuilderUserContext');\n\nconst AllSelector = () => true;\nconst SelectSelector = /^(select|columns|column|distinct|count|countDistinct|min|max|sum|sumDistinct|avg|avgDistinct)$/;\nconst WhereSelector = /^(where|orWhere|andWhere|find)/;\nconst OnSelector = /^(on|orOn|andOn)/;\nconst OrderBySelector = /orderBy/;\nconst JoinSelector = /(join|joinRaw|joinRelation)$/i;\nconst FromSelector = /^(from|into|table)$/;\n\nclass QueryBuilderOperationSupport {\n  constructor(...args) {\n    this.constructor.init(this, ...args);\n  }\n\n  static init(self, modelClass) {\n    self._modelClass = modelClass;\n    self._operations = [];\n    self._context = new this.QueryBuilderContext(self);\n    self._parentQuery = null;\n    self._isPartialQuery = false;\n    self._activeOperations = [];\n  }\n\n  static forClass(modelClass) {\n    return new this(modelClass);\n  }\n\n  static get AllSelector() {\n    return AllSelector;\n  }\n\n  static get QueryBuilderContext() {\n    return QueryBuilderContextBase;\n  }\n\n  static get QueryBuilderUserContext() {\n    return QueryBuilderUserContext;\n  }\n\n  static get SelectSelector() {\n    return SelectSelector;\n  }\n\n  static get WhereSelector() {\n    return WhereSelector;\n  }\n\n  static get OnSelector() {\n    return OnSelector;\n  }\n\n  static get JoinSelector() {\n    return JoinSelector;\n  }\n\n  static get FromSelector() {\n    return FromSelector;\n  }\n\n  static get OrderBySelector() {\n    return OrderBySelector;\n  }\n\n  modelClass() {\n    return this._modelClass;\n  }\n\n  context(obj) {\n    const ctx = this._context;\n\n    if (arguments.length === 0) {\n      return ctx.userContext;\n    } else {\n      ctx.userContext = ctx.userContext.newFromObject(this, obj);\n      return this;\n    }\n  }\n\n  mergeContext(obj) {\n    const ctx = this._context;\n    ctx.userContext = ctx.userContext.newMerge(this, obj);\n    return this;\n  }\n\n  internalContext(ctx) {\n    if (arguments.length === 0) {\n      return this._context;\n    } else {\n      this._context = ctx;\n      return this;\n    }\n  }\n\n  internalOptions(opt) {\n    if (arguments.length === 0) {\n      return this._context.options;\n    } else {\n      const oldOpt = this._context.options;\n      this._context.options = Object.assign(oldOpt, opt);\n      return this;\n    }\n  }\n\n  isPartial(isPartial) {\n    if (arguments.length === 0) {\n      return this._isPartialQuery;\n    } else {\n      this._isPartialQuery = isPartial;\n      return this;\n    }\n  }\n\n  isInternal() {\n    return this.internalOptions().isInternalQuery;\n  }\n\n  tableNameFor(tableName, newTableName) {\n    const ctx = this.internalContext();\n    const tableMap = ctx.tableMap;\n\n    if (isString(newTableName)) {\n      ctx.tableMap = tableMap || new Map();\n      ctx.tableMap.set(tableName, newTableName);\n      return this;\n    } else {\n      return (tableMap && tableMap.get(tableName)) || tableName;\n    }\n  }\n\n  aliasFor(tableName, alias) {\n    const ctx = this.internalContext();\n    const aliasMap = ctx.aliasMap;\n\n    if (isString(alias)) {\n      ctx.aliasMap = aliasMap || new Map();\n      ctx.aliasMap.set(tableName, alias);\n      return this;\n    } else {\n      return (aliasMap && aliasMap.get(tableName)) || null;\n    }\n  }\n\n  tableRefFor(tableName) {\n    return this.aliasFor(tableName) || this.tableNameFor(tableName);\n  }\n\n  childQueryOf(query, { fork, isInternalQuery } = {}) {\n    if (query) {\n      let ctx = query.internalContext();\n\n      if (fork) {\n        ctx = ctx.clone();\n      }\n\n      if (isInternalQuery) {\n        ctx.options.isInternalQuery = true;\n      }\n\n      this._parentQuery = query;\n      this.internalContext(ctx);\n\n      // Use the parent's knex if there was no knex in `ctx`.\n      if (this.unsafeKnex() === null) {\n        this.knex(query.unsafeKnex());\n      }\n    }\n\n    return this;\n  }\n\n  subqueryOf(query) {\n    if (query) {\n      this._parentQuery = query;\n\n      if (this.unsafeKnex() === null) {\n        this.knex(query.unsafeKnex());\n      }\n    }\n\n    return this;\n  }\n\n  parentQuery() {\n    return this._parentQuery;\n  }\n\n  knex(...args) {\n    if (args.length === 0) {\n      const knex = this.unsafeKnex();\n\n      if (!knex) {\n        throw new Error(\n          `no database connection available for a query. You need to bind the model class or the query to a knex instance.`\n        );\n      }\n\n      return knex;\n    } else {\n      this._context.knex = args[0];\n      return this;\n    }\n  }\n\n  unsafeKnex() {\n    return this._context.knex || this._modelClass.knex() || null;\n  }\n\n  clear(operationSelector) {\n    const operationsToRemove = new Set();\n\n    this.forEachOperation(operationSelector, op => {\n      // If an ancestor operation has already been removed,\n      // there's no need to remove the children anymore.\n      if (!op.isAncestorInSet(operationsToRemove)) {\n        operationsToRemove.add(op);\n      }\n    });\n\n    for (const op of operationsToRemove) {\n      this.removeOperation(op);\n    }\n\n    return this;\n  }\n\n  clearSelect() {\n    return this.clear(SelectSelector);\n  }\n\n  clearWhere() {\n    return this.clear(WhereSelector);\n  }\n\n  clearOrder() {\n    return this.clear(OrderBySelector);\n  }\n\n  copyFrom(queryBuilder, operationSelector) {\n    const operationsToAdd = new Set();\n\n    queryBuilder.forEachOperation(operationSelector, op => {\n      // If an ancestor operation has already been added,\n      // there is no need to add\n      if (!op.isAncestorInSet(operationsToAdd)) {\n        operationsToAdd.add(op);\n      }\n    });\n\n    for (const op of operationsToAdd) {\n      const opClone = op.clone();\n\n      // We may be moving nested operations to the root. Clear\n      // any links to the parent operations.\n      opClone.parentOperation = null;\n      opClone.adderHookName = null;\n\n      // We don't use `addOperation` here because we don't what to\n      // call `onAdd` or add these operations as child operations.\n      this._operations.push(opClone);\n    }\n\n    return this;\n  }\n\n  has(operationSelector) {\n    return !!this.findOperation(operationSelector);\n  }\n\n  forEachOperation(operationSelector, callback, match = true) {\n    const selector = buildFunctionForOperationSelector(operationSelector);\n\n    for (const op of this._operations) {\n      if (selector(op) === match && callback(op) === false) {\n        break;\n      }\n\n      const childRes = op.forEachDescendantOperation(op => {\n        if (selector(op) === match && callback(op) === false) {\n          return false;\n        }\n      });\n\n      if (childRes === false) {\n        break;\n      }\n    }\n\n    return this;\n  }\n\n  findOperation(operationSelector) {\n    let op = null;\n\n    this.forEachOperation(operationSelector, it => {\n      op = it;\n      return false;\n    });\n\n    return op;\n  }\n\n  findLastOperation(operationSelector) {\n    let op = null;\n\n    this.forEachOperation(operationSelector, it => {\n      op = it;\n    });\n\n    return op;\n  }\n\n  everyOperation(operationSelector) {\n    let every = true;\n\n    this.forEachOperation(\n      operationSelector,\n      () => {\n        every = false;\n        return false;\n      },\n      false\n    );\n\n    return every;\n  }\n\n  callOperationMethod(operation, hookName, args) {\n    try {\n      operation.removeChildOperationsByHookName(hookName);\n\n      this._activeOperations.push({\n        operation,\n        hookName\n      });\n\n      return operation[hookName](...args);\n    } finally {\n      this._activeOperations.pop();\n    }\n  }\n\n  callAsyncOperationMethod(operation, hookName, args) {\n    operation.removeChildOperationsByHookName(hookName);\n\n    this._activeOperations.push({\n      operation,\n      hookName\n    });\n\n    return promiseUtils\n      .try(() => operation[hookName](...args))\n      .then(result => {\n        this._activeOperations.pop();\n        return result;\n      })\n      .catch(err => {\n        this._activeOperations.pop();\n        return Promise.reject(err);\n      });\n  }\n\n  addOperation(operation, args) {\n    const ret = this.addOperationUsingMethod('push', operation, args);\n    return ret;\n  }\n\n  addOperationToFront(operation, args) {\n    return this.addOperationUsingMethod('unshift', operation, args);\n  }\n\n  addOperationUsingMethod(arrayMethod, operation, args) {\n    const shouldAdd = this.callOperationMethod(operation, 'onAdd', [this, args]);\n\n    if (shouldAdd) {\n      if (this._activeOperations.length) {\n        const { operation: parentOperation, hookName } = last(this._activeOperations);\n        parentOperation.addChildOperation(hookName, operation);\n      } else {\n        this._operations[arrayMethod](operation);\n      }\n    }\n\n    return this;\n  }\n\n  removeOperation(operation) {\n    if (operation.parentOperation) {\n      operation.parentOperation.removeChildOperation(operation);\n    } else {\n      const index = this._operations.indexOf(operation);\n\n      if (index !== -1) {\n        this._operations.splice(index, 1);\n      }\n    }\n\n    return this;\n  }\n\n  clone() {\n    return this.baseCloneInto(new this.constructor(this.unsafeKnex()));\n  }\n\n  baseCloneInto(builder) {\n    builder._modelClass = this._modelClass;\n    builder._operations = this._operations.map(it => it.clone());\n    builder._context = this._context.clone();\n    builder._parentQuery = this._parentQuery;\n    builder._isPartialQuery = this._isPartialQuery;\n\n    // Don't copy the active operation stack. We never continue (nor can we)\n    // a query from the exact mid-hook-call state.\n    builder._activeOperations = [];\n\n    return builder;\n  }\n\n  toKnexQuery(knexBuilder = this.knex().queryBuilder()) {\n    this.executeOnBuild();\n    this.executeOnBuildKnex(knexBuilder);\n\n    return knexBuilder;\n  }\n\n  executeOnBuild() {\n    this.forEachOperation(true, op => {\n      if (op.hasOnBuild()) {\n        this.callOperationMethod(op, 'onBuild', [this]);\n      }\n    });\n  }\n\n  executeOnBuildKnex(knexBuilder) {\n    this.forEachOperation(true, op => {\n      if (op.hasOnBuildKnex()) {\n        this.callOperationMethod(op, 'onBuildKnex', [knexBuilder, this]);\n      }\n    });\n  }\n\n  toString() {\n    return this.toKnexQuery().toString();\n  }\n\n  toSql() {\n    return this.toString();\n  }\n\n  skipUndefined() {\n    this.internalOptions().skipUndefined = true;\n    return this;\n  }\n}\n\nfunction buildFunctionForOperationSelector(operationSelector) {\n  if (operationSelector === true) {\n    return AllSelector;\n  } else if (isRegExp(operationSelector)) {\n    return op => operationSelector.test(op.name);\n  } else if (isString(operationSelector)) {\n    return op => op.name === operationSelector;\n  } else if (isSubclassOf(operationSelector, QueryBuilderOperation)) {\n    return op => op.is(operationSelector);\n  } else if (isFunction(operationSelector)) {\n    return operationSelector;\n  } else {\n    return () => false;\n  }\n}\n\nmodule.exports = {\n  QueryBuilderOperationSupport\n};\n","'use strict';\n\nconst SYMBOL_BUILDER = Symbol();\n\nclass QueryBuilderUserContext {\n  constructor(builder) {\n    // This should never ever be accessed outside this class. We only\n    // store it so that we can access builder.knex() lazily.\n    this[SYMBOL_BUILDER] = builder;\n  }\n\n  get transaction() {\n    return this[SYMBOL_BUILDER].knex();\n  }\n\n  newFromObject(builder, obj) {\n    const ctx = new this.constructor(builder);\n    Object.assign(ctx, obj);\n    return ctx;\n  }\n\n  newMerge(builder, obj) {\n    const ctx = new this.constructor(builder);\n    Object.assign(ctx, this, obj);\n    return ctx;\n  }\n}\n\nmodule.exports = {\n  QueryBuilderUserContext\n};\n","'use strict';\n\nconst { isPlainObject } = require('../utils/objectUtils');\nconst { buildArg } = require('../utils/buildUtils');\n\nclass RawBuilder {\n  constructor(sql, args) {\n    this._sql = `${sql}`;\n    this._args = args;\n    this._as = null;\n  }\n\n  get alias() {\n    return this._as;\n  }\n\n  as(as) {\n    this._as = as;\n    return this;\n  }\n\n  toKnexRaw(builder) {\n    let args = null;\n    let sql = this._sql;\n\n    if (this._args.length === 1 && isPlainObject(this._args[0])) {\n      args = buildObject(this._args[0], builder);\n\n      if (this._as) {\n        args.__alias__ = this._as;\n        sql += ' as :__alias__:';\n      }\n    } else {\n      args = buildArray(this._args, builder);\n\n      if (this._as) {\n        args.push(this._as);\n        sql += ' as ??';\n      }\n    }\n\n    return builder.knex().raw(sql, args);\n  }\n}\n\nObject.defineProperties(RawBuilder.prototype, {\n  isObjectionRawBuilder: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nfunction buildArray(arr, builder) {\n  return arr.map(it => buildArg(it, builder));\n}\n\nfunction buildObject(obj, builder) {\n  return Object.keys(obj).reduce((args, key) => {\n    args[key] = buildArg(obj[key], builder);\n    return args;\n  }, {});\n}\n\nfunction raw() {\n  let sql = arguments[0];\n  let args = null;\n\n  if (arguments.length === 2 && Array.isArray(arguments[1])) {\n    args = new Array(arguments[1].length);\n\n    for (let i = 0, l = args.length; i < l; ++i) {\n      args[i] = arguments[1][i];\n    }\n  } else {\n    args = new Array(arguments.length - 1);\n\n    for (let i = 1, l = arguments.length; i < l; ++i) {\n      args[i - 1] = arguments[i];\n    }\n  }\n\n  return new RawBuilder(sql, args);\n}\n\nmodule.exports = {\n  RawBuilder,\n  raw\n};\n","'use strict';\n\nconst { parseFieldExpression } = require('../utils/parseFieldExpression');\nconst { isObject } = require('../utils/objectUtils');\nconst { deprecate } = require('../utils/deprecate');\n\nclass ReferenceBuilder {\n  constructor(expr) {\n    this._expr = expr;\n    this._parsedExpr = null;\n    this._column = null;\n    this._table = null;\n    this._cast = null;\n    this._toJson = false;\n    this._table = null;\n    this._alias = null;\n    this._modelClass = null;\n\n    // This `if` makes it possible for `clone` to skip\n    // parsing the expression again.\n    if (expr !== null) {\n      this._parseExpression(expr);\n    }\n  }\n\n  get parsedExpr() {\n    return this._parsedExpr;\n  }\n\n  get column() {\n    return this._column;\n  }\n\n  set column(column) {\n    this._column = column;\n  }\n\n  get alias() {\n    return this._alias;\n  }\n\n  set alias(alias) {\n    this._alias = alias;\n  }\n\n  get tableName() {\n    return this._table;\n  }\n\n  set tableName(table) {\n    this._table = table;\n  }\n\n  get modelClass() {\n    return this._modelClass;\n  }\n\n  set modelClass(modelClass) {\n    this._modelClass = modelClass;\n  }\n\n  get isPlainColumnRef() {\n    return (\n      (!this._parsedExpr || this._parsedExpr.access.length === 0) && !this._cast && !this._toJson\n    );\n  }\n\n  get expression() {\n    return this._expr;\n  }\n\n  get cast() {\n    return this._cast;\n  }\n\n  fullColumn(builder) {\n    const table = this.tableName\n      ? this.tableName\n      : this.modelClass\n        ? builder.tableRefFor(this.modelClass.getTableName())\n        : null;\n\n    if (table) {\n      return `${table}.${this.column}`;\n    } else {\n      return this.column;\n    }\n  }\n\n  castText() {\n    return this.castTo('text');\n  }\n\n  castInt() {\n    return this.castTo('integer');\n  }\n\n  castBigInt() {\n    return this.castTo('bigint');\n  }\n\n  castFloat() {\n    return this.castTo('float');\n  }\n\n  castDecimal() {\n    return this.castTo('decimal');\n  }\n\n  castReal() {\n    return this.castTo('real');\n  }\n\n  castBool() {\n    return this.castTo('boolean');\n  }\n\n  castJson() {\n    this._toJson = true;\n    return this;\n  }\n\n  castType(sqlType) {\n    deprecate(\n      'castType(type) is deprecated. Use castTo(type) instead. castType(type) will be removed in 2.0'\n    );\n    return this.castTo(sqlType);\n  }\n\n  castTo(sqlType) {\n    this._cast = sqlType;\n    return this;\n  }\n\n  from(table) {\n    this._table = table;\n    return this;\n  }\n\n  table(table) {\n    this._table = table;\n    return this;\n  }\n\n  model(modelClass) {\n    this._modelClass = modelClass;\n    return this;\n  }\n\n  as(alias) {\n    this._alias = alias;\n    return this;\n  }\n\n  clone() {\n    const clone = new this.constructor(null);\n\n    clone._expr = this._expr;\n    clone._parsedExpr = this._parsedExpr;\n    clone._column = this._column;\n    clone._table = this._table;\n    clone._cast = this._cast;\n    clone._toJson = this._toJson;\n    clone._table = this._table;\n    clone._alias = this._alias;\n    clone._modelClass = this._modelClass;\n\n    return clone;\n  }\n\n  toKnexRaw(builder) {\n    return builder.knex().raw(...this._createRawArgs(builder));\n  }\n\n  _parseExpression(expr) {\n    this._parsedExpr = parseFieldExpression(expr);\n    this._column = this._parsedExpr.column;\n    this._table = this._parsedExpr.table;\n  }\n\n  _createRawArgs(builder) {\n    let bindings = [];\n    let sql = this._createReferenceSql(builder, bindings);\n\n    sql = this._maybeCast(sql, bindings);\n    sql = this._maybeToJsonb(sql, bindings);\n    sql = this._maybeAlias(sql, bindings);\n\n    return [sql, bindings];\n  }\n\n  _createReferenceSql(builder, bindings) {\n    bindings.push(this.fullColumn(builder));\n\n    if (this._parsedExpr.access.length > 0) {\n      const extractor = this._cast ? '#>>' : '#>';\n      const jsonFieldRef = this._parsedExpr.access.map(field => field.ref).join(',');\n      return `??${extractor}'{${jsonFieldRef}}'`;\n    } else {\n      return '??';\n    }\n  }\n\n  _maybeCast(sql) {\n    if (this._cast) {\n      return `CAST(${sql} AS ${this._cast})`;\n    } else {\n      return sql;\n    }\n  }\n\n  _maybeToJsonb(sql) {\n    if (this._toJson) {\n      return `to_jsonb(${sql})`;\n    } else {\n      return sql;\n    }\n  }\n\n  _maybeAlias(sql, bindings) {\n    if (this._shouldAlias()) {\n      bindings.push(this._alias);\n      return `${sql} as ??`;\n    } else {\n      return sql;\n    }\n  }\n\n  _shouldAlias() {\n    if (!this._alias) {\n      return false;\n    } else if (!this.isPlainColumnRef) {\n      return true;\n    } else {\n      // No need to alias if we are dealing with a simple column reference\n      // and the alias is the same as the column name.\n      return this._alias !== this._column;\n    }\n  }\n}\n\nObject.defineProperties(ReferenceBuilder.prototype, {\n  isObjectionReferenceBuilder: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nconst ref = reference => {\n  if (isObject(reference) && reference.isObjectionReferenceBuilder) {\n    return reference;\n  } else {\n    return new ReferenceBuilder(reference);\n  }\n};\n\nmodule.exports = {\n  ReferenceBuilder,\n  ref\n};\n","'use strict';\n\nconst parser = require('./parsers/relationExpressionParser');\nconst { isObject, isNumber, isString, union } = require('../utils/objectUtils');\nconst { RelationDoesNotExistError } = require('../model/RelationDoesNotExistError');\n\nclass RelationExpressionParseError extends Error {}\nclass DuplicateRelationError extends RelationExpressionParseError {\n  constructor(relationName) {\n    super();\n    this.relationName = relationName;\n  }\n}\n\nclass RelationExpression {\n  constructor(node = newNode(), recursionDepth = 0) {\n    this.node = node;\n    this.recursionDepth = recursionDepth;\n  }\n\n  // Create a relation expression from a string, a pojo or another\n  // RelationExpression instance.\n  static create(expr) {\n    if (isObject(expr)) {\n      if (expr.isObjectionRelationExpression) {\n        return expr;\n      } else {\n        return new RelationExpression(normalizeNode(expr));\n      }\n    } else if (isString(expr)) {\n      if (expr.trim().length === 0) {\n        return new RelationExpression();\n      } else {\n        try {\n          return new RelationExpression(parse(expr));\n        } catch (err) {\n          if (err.duplicateRelationName) {\n            throw new DuplicateRelationError(err.duplicateRelationName);\n          } else {\n            throw new RelationExpressionParseError(err.message);\n          }\n        }\n      }\n    } else {\n      return new RelationExpression();\n    }\n  }\n\n  // Create a relation expression from a model graph.\n  static fromModelGraph(graph) {\n    if (!graph) {\n      return new RelationExpression();\n    } else {\n      return new RelationExpression(modelGraphToNode(graph, newNode()));\n    }\n  }\n\n  get maxRecursionDepth() {\n    if (isNumber(this.node.$recursive)) {\n      return this.node.$recursive;\n    } else {\n      return this.node.$recursive ? Number.MAX_SAFE_INTEGER : 0;\n    }\n  }\n\n  get numChildren() {\n    return this.node.$childNames.length;\n  }\n\n  get isEmpty() {\n    return this.numChildren === 0;\n  }\n\n  // Merges this relation expression with another. `expr` can be a string,\n  // a pojo, or a RelationExpression instance.\n  merge(expr) {\n    const node = RelationExpression.create(expr).node;\n    return new RelationExpression(mergeNodes(this.node, node));\n  }\n\n  // Returns true if `expr` is contained by this expression. For example\n  // `a.b` is contained by `a.[b, c]`.\n  isSubExpression(expr) {\n    expr = RelationExpression.create(expr);\n\n    if (this.node.$allRecursive) {\n      return true;\n    }\n\n    if (expr.node.$allRecursive) {\n      return this.node.$allRecursive;\n    }\n\n    if (this.node.$relation !== expr.node.$relation) {\n      return false;\n    }\n\n    const maxRecursionDepth = expr.maxRecursionDepth;\n\n    if (maxRecursionDepth > 0) {\n      return this.node.$allRecursive || this.maxRecursionDepth >= maxRecursionDepth;\n    }\n\n    for (const childName of expr.node.$childNames) {\n      const ownSubExpression = this.childExpression(childName);\n      const subExpression = expr.childExpression(childName);\n\n      if (!ownSubExpression || !ownSubExpression.isSubExpression(subExpression)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Returns a RelationExpression for a child node or null if there\n  // is no child with the given name `childName`.\n  childExpression(childName) {\n    if (\n      this.node.$allRecursive ||\n      (childName === this.node.$name && this.recursionDepth < this.maxRecursionDepth - 1)\n    ) {\n      return new RelationExpression(this.node, this.recursionDepth + 1);\n    }\n\n    const child = this.node[childName];\n\n    if (child) {\n      return new RelationExpression(child);\n    } else {\n      return null;\n    }\n  }\n\n  // Loops throught all first level children.\n  forEachChildExpression(modelClass, cb) {\n    const maxRecursionDepth = this.maxRecursionDepth;\n\n    if (this.node.$allRecursive) {\n      for (const relationName of modelClass.getRelationNames()) {\n        const node = newNode(relationName, true);\n        const relation = modelClass.getRelationUnsafe(relationName);\n        const childExpr = new RelationExpression(node);\n\n        cb(childExpr, relation);\n      }\n    } else if (this.recursionDepth < maxRecursionDepth - 1) {\n      const relation = modelClass.getRelationUnsafe(this.node.$relation) || null;\n      const childExpr = new RelationExpression(this.node, this.recursionDepth + 1);\n\n      cb(childExpr, relation);\n    } else if (maxRecursionDepth === 0) {\n      for (const childName of this.node.$childNames) {\n        const node = this.node[childName];\n        const relation = modelClass.getRelationUnsafe(node.$relation);\n\n        if (!relation) {\n          throw new RelationDoesNotExistError(node.$relation);\n        }\n\n        const childExpr = new RelationExpression(node);\n\n        cb(childExpr, relation);\n      }\n    }\n  }\n\n  expressionsAtPath(path) {\n    return findExpressionsAtPath(this, RelationExpression.create(path), []);\n  }\n\n  clone() {\n    return new RelationExpression(cloneNode(this.node), this.recursionDepth);\n  }\n\n  toString() {\n    return toString(this.node);\n  }\n\n  toPojo() {\n    return cloneNode(this.node);\n  }\n\n  toJSON() {\n    return this.toPojo();\n  }\n}\n\nconst parseCache = new Map();\nfunction parse(str) {\n  const cachedNode = parseCache.get(str);\n\n  if (cachedNode) {\n    return cloneNode(cachedNode);\n  } else {\n    const node = parser.parse(str);\n    parseCache.set(str, cloneNode(node));\n    return node;\n  }\n}\n\n// All enumerable properties of a node that don't start with `$`\n// are child nodes.\nfunction getChildNames(node) {\n  if (!node) {\n    return [];\n  }\n\n  const childNames = [];\n\n  for (const key of Object.keys(node)) {\n    if (key[0] !== '$') {\n      childNames.push(key);\n    }\n  }\n\n  return childNames;\n}\n\nfunction toString(node) {\n  const childNames = node.$childNames;\n\n  let childExpr = childNames.map(childName => node[childName]).map(toString);\n  let str = node.$relation;\n\n  if (node.$recursive) {\n    if (isNumber(node.$recursive)) {\n      str += '.^' + node.$recursive;\n    } else {\n      str += '.^';\n    }\n  } else if (node.$allRecursive) {\n    str += '.*';\n  }\n\n  if (childExpr.length > 1) {\n    childExpr = `[${childExpr.join(', ')}]`;\n  } else {\n    childExpr = childExpr[0];\n  }\n\n  if (node.$modify.length) {\n    str += `(${node.$modify.join(', ')})`;\n  }\n\n  if (node.$name !== node.$relation) {\n    str += ` as ${node.$name}`;\n  }\n\n  if (childExpr) {\n    if (str) {\n      return `${str}.${childExpr}`;\n    } else {\n      return childExpr;\n    }\n  } else {\n    return str;\n  }\n}\n\nfunction cloneNode(node) {\n  return normalizeNode(node);\n}\n\nfunction modelGraphToNode(models, node) {\n  if (!models) {\n    return;\n  }\n\n  if (Array.isArray(models)) {\n    for (let i = 0, l = models.length; i < l; ++i) {\n      modelToNode(models[i], node);\n    }\n  } else {\n    modelToNode(models, node);\n  }\n\n  return node;\n}\n\nfunction modelToNode(model, node) {\n  const modelClass = model.constructor;\n  const relationNames = modelClass.getRelationNames();\n\n  for (let r = 0, lr = relationNames.length; r < lr; ++r) {\n    const relName = relationNames[r];\n\n    if (model.hasOwnProperty(relName)) {\n      let childNode = node[relName];\n\n      if (!childNode) {\n        childNode = newNode(relName);\n        node[relName] = childNode;\n        node.$childNames.push(relName);\n      }\n\n      modelGraphToNode(model[relName], childNode);\n    }\n  }\n}\n\nfunction newNode(name = null, allRecusive = false) {\n  return normalizeNode(null, name, allRecusive);\n}\n\nfunction normalizeNode(node = null, name = null, allRecusive = false) {\n  const normalized = {\n    $name: (node && node.$name) || name || null,\n    $relation: (node && node.$relation) || name || null,\n    $modify: (node && node.$modify && node.$modify.slice()) || [],\n    $recursive: (node && node.$recursive) || false,\n    $allRecursive: (node && node.$allRecursive) || allRecusive || false,\n    $childNames: (node && node.$childNames && node.$childNames.slice()) || getChildNames(node)\n  };\n\n  for (const childName of normalized.$childNames) {\n    const childNode = node[childName];\n\n    if (isObject(childNode) || childNode === true) {\n      normalized[childName] = normalizeNode(childNode, childName);\n    }\n  }\n\n  return normalized;\n}\n\nfunction findExpressionsAtPath(target, path, results) {\n  if (path.node.$childNames.length == 0) {\n    // Path leaf reached, add target node to result set.\n    results.push(target);\n  } else {\n    for (const childName of path.node.$childNames) {\n      const pathChild = path.childExpression(childName);\n      const targetChild = target.childExpression(childName);\n\n      if (targetChild) {\n        findExpressionsAtPath(targetChild, pathChild, results);\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction mergeNodes(node1, node2) {\n  const node = {\n    $name: node1.$name,\n    $relation: node1.$relation,\n    $modify: union(node1.$modify, node2.$modify),\n    $recursive: mergeRecursion(node1.$recursive, node2.$recursive),\n    $allRecursive: node1.$allRecursive || node2.$allRecursive,\n    $childNames: null\n  };\n\n  if (!node.$recursive && !node.$allRecursive) {\n    node.$childNames = union(node1.$childNames, node2.$childNames);\n\n    for (const childName of node.$childNames) {\n      const child1 = node1[childName];\n      const child2 = node2[childName];\n\n      if (child1 && child2) {\n        node[childName] = mergeNodes(child1, child2);\n      } else {\n        node[childName] = child1 || child2;\n      }\n    }\n  } else {\n    node.$childNames = [];\n  }\n\n  return node;\n}\n\nfunction mergeRecursion(rec1, rec2) {\n  if (rec1 === true || rec2 === true) {\n    return true;\n  } else if (isNumber(rec1) && isNumber(rec2)) {\n    return Math.max(rec1, rec2);\n  } else {\n    return rec1 || rec2;\n  }\n}\n\nObject.defineProperties(RelationExpression.prototype, {\n  isObjectionRelationExpression: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nmodule.exports = {\n  RelationExpression,\n  RelationExpressionParseError,\n  DuplicateRelationError\n};\n","'use strict';\n\nconst { asArray } = require('../utils/objectUtils');\n\nconst BUILDER_SYMBOL = Symbol();\n\nclass StaticHookArguments {\n  constructor({ builder, result = null }) {\n    // The builder should never be accessed through the arguments.\n    // Hide it as well as possible to discourage people from\n    // digging it out.\n    Object.defineProperty(this, BUILDER_SYMBOL, {\n      value: builder\n    });\n\n    Object.defineProperty(this, 'result', {\n      value: asArray(result)\n    });\n  }\n\n  static create(args) {\n    return new StaticHookArguments(args);\n  }\n\n  get findQuery() {\n    return this[BUILDER_SYMBOL].toFindQuery().runAfter(asArray);\n  }\n\n  get context() {\n    return this[BUILDER_SYMBOL].context();\n  }\n\n  get transaction() {\n    return this[BUILDER_SYMBOL].unsafeKnex();\n  }\n\n  get relation() {\n    const op = this[BUILDER_SYMBOL].findOperation(hasRelation);\n\n    if (op) {\n      return getRelation(op);\n    } else {\n      return null;\n    }\n  }\n\n  get modelOptions() {\n    const op = this[BUILDER_SYMBOL].findOperation(hasModelOptions);\n\n    if (op) {\n      return getModelOptions(op);\n    } else {\n      return null;\n    }\n  }\n\n  get modelInstances() {\n    const op = this[BUILDER_SYMBOL].findOperation(hasModelInstance);\n\n    if (op) {\n      return asArray(getModelInstance(op));\n    } else {\n      return [];\n    }\n  }\n\n  get inputModelInstances() {\n    const op = this[BUILDER_SYMBOL].findOperation(hasInputModelInstance);\n\n    if (op) {\n      return asArray(getInputModelInstance(op));\n    } else {\n      return [];\n    }\n  }\n\n  get cancelQuery() {\n    const args = this;\n\n    return cancelValue => {\n      const builder = this[BUILDER_SYMBOL];\n\n      if (cancelValue === undefined) {\n        if (builder.isInsert()) {\n          cancelValue = args.inputModelInstances;\n        } else if (builder.isFind()) {\n          cancelValue = [];\n        } else {\n          cancelValue = 0;\n        }\n      }\n\n      builder.resolve(cancelValue);\n    };\n  }\n}\n\nfunction getRelation(op) {\n  return op.relation;\n}\n\nfunction hasRelation(op) {\n  return !!getRelation(op);\n}\n\nfunction getModelOptions(op) {\n  return op.modelOptions;\n}\n\nfunction hasModelOptions(op) {\n  return !!getModelOptions(op);\n}\n\nfunction getModelInstance(op) {\n  return op.instance || op.owner || op.owners;\n}\n\nfunction hasModelInstance(op) {\n  return !!getModelInstance(op);\n}\n\nfunction getInputModelInstance(op) {\n  return op.models || op.model;\n}\n\nfunction hasInputModelInstance(op) {\n  return !!getInputModelInstance(op);\n}\n\nmodule.exports = {\n  StaticHookArguments\n};\n","'use strict';\n\nconst { isPostgres } = require('../../utils/knexUtils');\n\nconst POSTGRES_MAX_INSERT_BATCH_SIZE = 100;\nconst MAX_CONCURRENCY = 100;\n\nclass GraphAction {\n  static get ReturningAllSelector() {\n    return op => {\n      // Only select `returning('*')` operation.\n      return op.name === 'returning' && op.args.includes('*');\n    };\n  }\n\n  run(builder) {\n    return null;\n  }\n\n  _getConcurrency(builder, nodes) {\n    return nodes.reduce((minConcurrency, node) => {\n      return Math.min(minConcurrency, node.modelClass.getConcurrency(builder.unsafeKnex()));\n    }, MAX_CONCURRENCY);\n  }\n\n  _getBatchSize(builder) {\n    return isPostgres(builder.unsafeKnex()) ? POSTGRES_MAX_INSERT_BATCH_SIZE : 1;\n  }\n\n  _resolveReferences(node) {\n    if (node.isReference) {\n      this._resolveReference(node);\n    }\n  }\n\n  _resolveReference(node) {\n    const refNode = node.referencedNode;\n\n    for (const prop of Object.keys(refNode.obj)) {\n      if (!node.obj.hasOwnProperty(prop)) {\n        node.obj[prop] = refNode.obj[prop];\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  GraphAction\n};\n","'use strict';\n\nconst { asArray, groupBy } = require('../../utils/objectUtils');\nconst { ModelGraph } = require('../../model/graph/ModelGraph');\nconst { FetchStrategy } = require('./GraphOptions');\nconst { RelationExpression } = require('../RelationExpression');\n\nclass GraphOperation {\n  constructor({ graph, currentGraph, graphOptions }) {\n    this.graph = graph;\n    this.currentGraph = currentGraph;\n    this.graphOptions = graphOptions;\n  }\n\n  static fetchCurrentGraph({ builder, graph, graphOptions }) {\n    const rootObjects = graph.rootObjects;\n    const rootIds = getRootIds(rootObjects);\n    const modelClass = builder.modelClass();\n\n    if (rootIds.length === 0) {\n      return Promise.resolve(ModelGraph.create(modelClass, []));\n    }\n\n    const eagerExpr = RelationExpression.fromModelGraph(rootObjects);\n\n    return modelClass\n      .query()\n      .childQueryOf(builder, childQueryOptions())\n      .modify(propagateMethodCallsFromQuery(builder))\n      .modify(buildFetchQuerySelects(graph, graphOptions, eagerExpr))\n      .findByIds(rootIds)\n      .eagerAlgorithm(modelClass.WhereInEagerAlgorighm)\n      .eager(eagerExpr)\n      .internalOptions(fetchQueryInternalOptions())\n      .then(models => ModelGraph.create(modelClass, models));\n  }\n\n  createActions() {\n    return [];\n  }\n\n  shouldRelateAncestor(node) {\n    if (!node.parentNode) {\n      return false;\n    }\n\n    return (\n      this.graphOptions.shouldRelate(node.parentNode, this.currentGraph) ||\n      this.shouldRelateAncestor(node.parentNode)\n    );\n  }\n}\n\nfunction getRootIds(graph) {\n  return asArray(graph)\n    .filter(it => it.$hasId())\n    .map(root => root.$id());\n}\n\nfunction propagateMethodCallsFromQuery(builder) {\n  return fetchBuilder => {\n    // Propagate some method calls from the root query.\n    for (const method of ['forUpdate', 'forShare']) {\n      if (builder.has(method)) {\n        fetchBuilder[method]();\n      }\n    }\n  };\n}\n\nfunction buildFetchQuerySelects(graph, graphOptions, eagerExpr) {\n  return builder => {\n    const nodesByRelationPath = groupNodesByRelationPath(graph, eagerExpr);\n\n    for (const [relationPath, nodes] of nodesByRelationPath.entries()) {\n      const selectModifier = createFetchSelectModifier(nodes, graphOptions);\n\n      if (!relationPath) {\n        builder.modify(selectModifier);\n      } else {\n        builder.modifyEager(relationPath, selectModifier);\n      }\n    }\n  };\n}\n\nfunction groupNodesByRelationPath(graph, eagerExpr) {\n  const nodesByRelationPath = groupBy(graph.nodes, node => node.relationPathKey);\n\n  // Not all relation paths have nodes. Relations with nulls or empty arrays\n  // don't have nodes, but will still need to be fetched. Add these to the\n  // map as empty arrays.\n  forEachPath(eagerExpr.node, relationPath => {\n    if (!nodesByRelationPath.has(relationPath)) {\n      nodesByRelationPath.set(relationPath, []);\n    }\n  });\n\n  return nodesByRelationPath;\n}\n\nfunction createFetchSelectModifier(nodes, graphOptions) {\n  if (graphOptions.isFetchStrategy(FetchStrategy.OnlyIdentifiers)) {\n    return createIdentifierSelector();\n  } else if (graphOptions.isFetchStrategy(FetchStrategy.OnlyNeeded)) {\n    return createInputColumnSelector(nodes);\n  } else {\n    return () => {};\n  }\n}\n\n// Returns a function that only selects the id column.\nfunction createIdentifierSelector() {\n  return builder => {\n    builder.select(builder.fullIdColumn());\n  };\n}\n\n// Returns a function that only selects the columns that exist in the input.\nfunction createInputColumnSelector(nodes) {\n  return builder => {\n    const selects = new Map();\n\n    for (const node of nodes) {\n      const databaseJson = node.obj.$toDatabaseJson(builder);\n\n      for (const column of Object.keys(databaseJson)) {\n        if (!shouldSelectColumn(column, selects, node)) {\n          continue;\n        }\n\n        const selection =\n          createManyToManyExtraSelectionIfNeeded(builder, column, node) ||\n          createSelection(builder, column, node);\n\n        selects.set(column, selection);\n      }\n    }\n\n    const selectArr = Array.from(selects.values());\n    const idColumn = builder.fullIdColumn();\n\n    if (!selectArr.includes(idColumn)) {\n      // Always select the identifer.\n      selectArr.push(idColumn);\n    }\n\n    builder.select(selectArr);\n  };\n}\n\nfunction shouldSelectColumn(column, selects, node) {\n  const modelClass = node.modelClass;\n\n  return (\n    !selects.has(column) &&\n    column !== modelClass.propertyNameToColumnName(modelClass.dbRefProp) &&\n    column !== modelClass.propertyNameToColumnName(modelClass.uidRefProp) &&\n    column !== modelClass.propertyNameToColumnName(modelClass.uidProp)\n  );\n}\n\nfunction createManyToManyExtraSelectionIfNeeded(builder, column, node) {\n  if (node.parentEdge && node.parentEdge.relation.isObjectionManyToManyRelation) {\n    const relation = node.parentEdge.relation;\n    const extra = relation.joinTableExtras.find(extra => extra.aliasCol === column);\n\n    if (extra) {\n      return `${builder.tableRefFor(relation.joinModelClass)}.${extra.joinTableCol} as ${\n        extra.aliasCol\n      }`;\n    }\n  }\n\n  return null;\n}\n\nfunction createSelection(builder, column, node) {\n  return `${builder.tableRefFor(node.modelClass)}.${column}`;\n}\n\nfunction childQueryOptions() {\n  return {\n    fork: true,\n    isInternalQuery: true\n  };\n}\n\nfunction fetchQueryInternalOptions() {\n  return {\n    keepImplicitJoinProps: true\n  };\n}\n\nfunction forEachPath(eagerExprNode, cb, path = []) {\n  for (const relation of eagerExprNode.$childNames) {\n    path.push(relation);\n    cb(path.join('.'));\n    forEachPath(eagerExprNode[relation], cb, path);\n    path.pop();\n  }\n}\n\nmodule.exports = {\n  GraphOperation\n};\n","'use strict';\n\nconst NO_RELATE = 'noRelate';\nconst NO_UNRELATE = 'noUnrelate';\nconst NO_INSERT = 'noInsert';\nconst NO_UPDATE = 'noUpdate';\nconst NO_DELETE = 'noDelete';\n\nconst UPDATE = 'update';\nconst RELATE = 'relate';\nconst UNRELATE = 'unrelate';\nconst INSERT_MISSING = 'insertMissing';\nconst FETCH_STRATEGY = 'fetchStrategy';\n\nconst FetchStrategy = {\n  OnlyIdentifiers: 'OnlyIdentifiers',\n  Everything: 'Everything',\n  OnlyNeeded: 'OnlyNeeded'\n};\n\nclass GraphOptions {\n  constructor(options) {\n    if (options instanceof GraphOptions) {\n      this.options = options.options;\n    } else {\n      this.options = options;\n    }\n  }\n\n  isFetchStrategy(strategy) {\n    if (!FetchStrategy[strategy]) {\n      throw new Error(`unknown strategy \"${strategy}\"`);\n    }\n\n    if (!this.options[FETCH_STRATEGY]) {\n      return strategy === FetchStrategy.OnlyIdentifiers;\n    } else {\n      return this.options[FETCH_STRATEGY] === strategy;\n    }\n  }\n\n  isInsertOnly() {\n    // NO_RELATE is not in the list, since the `insert only` mode does\n    // relate things that can be related using inserts.\n    return [NO_DELETE, NO_UPDATE, NO_UNRELATE, INSERT_MISSING].every(opt => {\n      return this.options[opt] === true;\n    });\n  }\n\n  // Like `shouldRelate` but ignores settings that explicitly disable relate operations.\n  shouldRelateIgnoreDisable(node, currentGraph) {\n    if (node.isReference || node.isDbReference) {\n      return true;\n    }\n\n    return (\n      !getCurrentNode(node, currentGraph) &&\n      this._hasOption(node, RELATE) &&\n      !!node.parentEdge &&\n      !!node.parentEdge.relation &&\n      node.parentEdge.relation.hasRelateProp(node.obj)\n    );\n  }\n\n  shouldRelate(node, currentGraph) {\n    return !this._hasOption(node, NO_RELATE) && this.shouldRelateIgnoreDisable(node, currentGraph);\n  }\n\n  // Like `shouldInsert` but ignores settings that explicitly disable insert operations.\n  shouldInsertIgnoreDisable(node, currentGraph) {\n    return (\n      !getCurrentNode(node, currentGraph) &&\n      !this.shouldRelateIgnoreDisable(node, currentGraph) &&\n      (!node.hadIdOriginally || this._hasOption(node, INSERT_MISSING))\n    );\n  }\n\n  shouldInsert(node, currentGraph) {\n    return !this._hasOption(node, NO_INSERT) && this.shouldInsertIgnoreDisable(node, currentGraph);\n  }\n\n  // Like `shouldPatch() || shouldUpdate()` but ignores settings that explicitly disable\n  // update or patch operations.\n  shouldPatchOrUpdateIgnoreDisable(node, currentGraph) {\n    if (this.shouldRelate(node)) {\n      // We should update all nodes that are going to be related. Note that\n      // we don't actually update anything unless there is something to update\n      // so this is just a preliminary test.\n      return true;\n    }\n\n    return !!getCurrentNode(node, currentGraph);\n  }\n\n  shouldPatch(node, currentGraph) {\n    return (\n      this.shouldPatchOrUpdateIgnoreDisable(node, currentGraph) &&\n      !this._hasOption(node, NO_UPDATE) &&\n      !this._hasOption(node, UPDATE)\n    );\n  }\n\n  shouldUpdate(node, currentGraph) {\n    return (\n      this.shouldPatchOrUpdateIgnoreDisable(node, currentGraph) &&\n      !this._hasOption(node, NO_UPDATE) &&\n      this._hasOption(node, UPDATE)\n    );\n  }\n\n  // Like `shouldUnrelate` but ignores settings that explicitly disable unrelate operations.\n  shouldUnrelateIgnoreDisable(currentNode) {\n    return this._hasOption(currentNode, UNRELATE);\n  }\n\n  shouldUnrelate(currentNode, graph) {\n    return (\n      !getNode(currentNode, graph) &&\n      !this._hasOption(currentNode, NO_UNRELATE) &&\n      this.shouldUnrelateIgnoreDisable(currentNode)\n    );\n  }\n\n  shouldDelete(currentNode, graph) {\n    return (\n      !getNode(currentNode, graph) &&\n      !this._hasOption(currentNode, NO_DELETE) &&\n      !this.shouldUnrelateIgnoreDisable(currentNode)\n    );\n  }\n\n  shouldInsertOrRelate(node, currentGraph) {\n    return this.shouldInsert(node, currentGraph) || this.shouldRelate(node, currentGraph);\n  }\n\n  shouldDeleteOrUnrelate(currentNode, graph) {\n    return this.shouldDelete(currentNode, graph) || this.shouldUnrelate(currentNode, graph);\n  }\n\n  rebasedOptions(newRoot) {\n    const newOpt = {};\n    const newRootRelationPath = newRoot.relationPathKey;\n\n    for (const name of Object.keys(this.options)) {\n      const value = this.options[name];\n\n      if (Array.isArray(value)) {\n        newOpt[name] = value\n          .filter(it => it.startsWith(newRootRelationPath))\n          .map(it => it.slice(newRootRelationPath.length + 1))\n          .filter(it => !!it);\n      } else {\n        newOpt[name] = value;\n      }\n    }\n\n    return new GraphOptions(newOpt);\n  }\n\n  _hasOption(node, optionName) {\n    const option = this.options[optionName];\n\n    if (Array.isArray(option)) {\n      return option.indexOf(node.relationPathKey) !== -1;\n    } else {\n      return !!option;\n    }\n  }\n}\n\nfunction getCurrentNode(node, currentGraph) {\n  if (!currentGraph || !node) {\n    return null;\n  }\n\n  return currentGraph.nodeForNode(node);\n}\n\nfunction getNode(currentNode, graph) {\n  if (!graph || !currentNode) {\n    return null;\n  }\n\n  return graph.nodeForNode(currentNode);\n}\n\nmodule.exports = {\n  GraphOptions,\n  FetchStrategy\n};\n","'use strict';\n\nconst { ModelGraph } = require('../../model/graph/ModelGraph');\nconst { createNotModelError } = require('../../model/graph/ModelGraphBuilder');\nconst { GraphOperation } = require('../graph/GraphOperation');\nconst { GraphInsert } = require('../graph/insert/GraphInsert');\nconst { GraphPatch } = require('../graph/patch/GraphPatch');\nconst { GraphDelete } = require('../graph/delete/GraphDelete');\nconst { GraphRecursiveUpsert } = require('../graph/recursiveUpsert/GraphRecursiveUpsert');\nconst { GraphOptions } = require('../graph/GraphOptions');\nconst { ValidationErrorType } = require('../../model/ValidationError');\nconst { RelationExpression } = require('../RelationExpression');\nconst { uniqBy, asArray, isObject } = require('../../utils/objectUtils');\n\nclass GraphUpsert {\n  constructor({ rootModelClass, objects, upsertOptions }) {\n    checkCanBeConvertedToModels(rootModelClass, objects);\n\n    this.objects = rootModelClass.ensureModelArray(objects, GraphUpsert.modelOptions);\n    this.isArray = Array.isArray(objects);\n    this.upsertOpt = upsertOptions;\n  }\n\n  static get modelOptions() {\n    return { skipValidation: true };\n  }\n\n  run(builder) {\n    const modelClass = builder.modelClass();\n    const graphOptions = new GraphOptions(this.upsertOpt);\n\n    const graph = ModelGraph.create(modelClass, this.objects);\n    assignDbRefsAsRelateProps(graph);\n\n    return fetchCurrentGraph(builder, graphOptions, graph)\n      .then(pruneGraphs(graph, graphOptions))\n      .then(checkForErrors(graph, graphOptions, builder))\n      .then(executeOperations(graph, graphOptions, builder))\n      .then(returnResult(this.objects, this.isArray));\n  }\n}\n\nfunction checkCanBeConvertedToModels(modelClass, objects) {\n  asArray(objects).forEach(obj => {\n    if (!isObject(obj)) {\n      throw createNotModelError(modelClass, obj);\n    }\n  });\n}\n\nfunction assignDbRefsAsRelateProps(graph) {\n  for (const node of graph.nodes) {\n    if (!node.parentEdge || !node.parentEdge.relation || !node.isDbReference) {\n      continue;\n    }\n\n    node.parentEdge.relation.setRelateProp(node.obj, asArray(node.dbReference));\n  }\n}\n\nfunction fetchCurrentGraph(builder, graphOptions, graph) {\n  if (graphOptions.isInsertOnly()) {\n    return Promise.resolve(ModelGraph.createEmpty());\n  } else {\n    return GraphOperation.fetchCurrentGraph({ builder, graph, graphOptions });\n  }\n}\n\n// Remove branches from the graph that require no operations. For example\n// we never want to do anything for descendant nodes of a node that is\n// deleted or unrelated. We never delete recursively.\nfunction pruneGraphs(graph, graphOptions) {\n  return currentGraph => {\n    pruneRelatedBranches(graph, currentGraph, graphOptions);\n\n    if (!graphOptions.isInsertOnly()) {\n      pruneDeletedBranches(graph, currentGraph);\n    }\n\n    return currentGraph;\n  };\n}\n\nfunction pruneRelatedBranches(graph, currentGraph, graphOptions) {\n  const relateNodes = graph.nodes.filter(node => {\n    return (\n      !currentGraph.nodeForNode(node) && !graphOptions.shouldInsertIgnoreDisable(node, currentGraph)\n    );\n  });\n\n  removeBranchesFromGraph(findRoots(relateNodes), graph);\n}\n\nfunction pruneDeletedBranches(graph, currentGraph) {\n  const deleteNodes = currentGraph.nodes.filter(currentNode => !graph.nodeForNode(currentNode));\n\n  removeBranchesFromGraph(findRoots(deleteNodes), currentGraph);\n}\n\nfunction findRoots(nodes) {\n  const nodeSet = new Set(nodes);\n\n  return uniqBy(\n    nodes.filter(node => {\n      let parentNode = node.parentNode;\n\n      while (parentNode) {\n        if (nodeSet.has(parentNode)) {\n          return false;\n        }\n\n        parentNode = parentNode.parentNode;\n      }\n\n      return true;\n    })\n  );\n}\n\nfunction removeBranchesFromGraph(branchRoots, graph) {\n  const nodesToRemove = new Set(\n    branchRoots.reduce(\n      (nodesToRemove, node) => [...nodesToRemove, ...node.descendantRelationNodes],\n      []\n    )\n  );\n\n  const edgesToRemove = new Set();\n\n  for (const node of nodesToRemove) {\n    for (const edge of node.edges) {\n      const otherNode = edge.getOtherNode(node);\n\n      if (!nodesToRemove.has(otherNode)) {\n        otherNode.removeEdge(edge);\n        edgesToRemove.add(edge);\n      }\n    }\n  }\n\n  graph.nodes = graph.nodes.filter(node => !nodesToRemove.has(node));\n  graph.edges = graph.edges.filter(edge => !edgesToRemove.has(edge));\n\n  return graph;\n}\n\nfunction checkForErrors(graph, graphOptions, builder) {\n  return currentGraph => {\n    checkForNotFoundErrors(graph, currentGraph, graphOptions, builder);\n    checkForUnallowedRelationErrors(graph, builder);\n\n    if (graphOptions.isInsertOnly()) {\n      checkForHasManyRelateErrors(graph, currentGraph, graphOptions);\n    }\n\n    return currentGraph;\n  };\n}\n\nfunction checkForNotFoundErrors(graph, currentGraph, graphOptions, builder) {\n  for (const node of graph.nodes) {\n    if (\n      node.obj.$hasId() &&\n      !graphOptions.shouldInsertIgnoreDisable(node, currentGraph) &&\n      !graphOptions.shouldRelateIgnoreDisable(node, currentGraph) &&\n      !currentGraph.nodeForNode(node)\n    ) {\n      if (!node.parentNode) {\n        throw node.modelClass.createNotFoundError(builder.context(), {\n          message: `root model (id=${node.obj.$id()}) does not exist. If you want to insert it with an id, use the insertMissing option`,\n          dataPath: node.dataPath\n        });\n      } else {\n        throw node.modelClass.createNotFoundError(builder.context(), {\n          message: `model (id=${node.obj.$id()}) is not a child of model (id=${node.parentNode.obj.$id()}). If you want to relate it, use the relate option. If you want to insert it with an id, use the insertMissing option`,\n          dataPath: node.dataPath\n        });\n      }\n    }\n  }\n}\n\nfunction checkForUnallowedRelationErrors(graph, builder) {\n  const allowedExpression = builder.allowedUpsertExpression();\n\n  if (allowedExpression) {\n    const rootsObjs = graph.nodes.filter(node => !node.parentEdge).map(node => node.obj);\n    const expression = RelationExpression.fromModelGraph(rootsObjs);\n\n    if (!allowedExpression.isSubExpression(expression)) {\n      throw builder.modelClass().createValidationError({\n        type: ValidationErrorType.UnallowedRelation,\n        message: 'trying to upsert an unallowed relation'\n      });\n    }\n  }\n}\n\nfunction checkForHasManyRelateErrors(graph, currentGraph, graphOptions) {\n  for (const node of graph.nodes) {\n    if (\n      graphOptions.shouldRelate(node, currentGraph) &&\n      node.parentEdge.relation.isObjectionHasManyRelation\n    ) {\n      throw new Error(\n        'You cannot relate HasManyRelation or HasOneRelation using insertGraph, because those require update operations. Consider using upsertGraph instead.'\n      );\n    }\n  }\n}\n\nfunction executeOperations(graph, graphOptions, builder) {\n  const operations = graphOptions.isInsertOnly()\n    ? [GraphInsert]\n    : [GraphDelete, GraphInsert, GraphPatch, GraphRecursiveUpsert];\n\n  return currentGraph => {\n    return operations.reduce((promise, Operation) => {\n      const operation = new Operation({ graph, currentGraph, graphOptions });\n      const actions = operation.createActions();\n\n      return promise.then(() => executeActions(builder, actions));\n    }, Promise.resolve());\n  };\n}\n\nfunction executeActions(builder, actions) {\n  return actions.reduce(\n    (promise, action) => promise.then(() => action.run(builder)),\n    Promise.resolve()\n  );\n}\n\nfunction returnResult(objects, isArray) {\n  return () => (isArray ? objects : objects[0]);\n}\n\nmodule.exports = {\n  GraphUpsert\n};\n","'use strict';\n\nconst { GraphOperation } = require('../GraphOperation');\nconst { GraphDeleteAction } = require('./GraphDeleteAction');\n\nclass GraphDelete extends GraphOperation {\n  createActions() {\n    return [\n      new GraphDeleteAction({\n        nodes: this.currentGraph.nodes.filter(currentNode =>\n          this.graphOptions.shouldDeleteOrUnrelate(currentNode, this.graph)\n        ),\n\n        graph: this.graph,\n        graphOptions: this.graphOptions\n      })\n    ];\n  }\n}\n\nmodule.exports = {\n  GraphDelete\n};\n","'use strict';\n\nconst { GraphAction } = require('../GraphAction');\nconst { groupBy } = require('../../../utils/objectUtils');\nconst promiseUtils = require('../../../utils/promiseUtils');\n\nclass GraphDeleteAction extends GraphAction {\n  constructor({ nodes, graph, graphOptions }) {\n    super();\n\n    // Nodes to delete.\n    this.nodes = nodes;\n    this.graph = graph;\n    this.graphOptions = graphOptions;\n  }\n\n  run(builder) {\n    const nodesTodelete = this._filterOutBelongsToOneRelationUnrelates(this.nodes);\n    const builders = this._createDeleteBuilders(builder, nodesTodelete);\n\n    return promiseUtils.map(builders, builder => builder.execute(), {\n      concurrency: this._getConcurrency(builder, nodesTodelete)\n    });\n  }\n\n  _filterOutBelongsToOneRelationUnrelates(nodes) {\n    // `BelongsToOneRelation` unrelate is handled by `GraphPatch` because\n    // unrelating a `BelongsToOneRelation` is just a matter of updating\n    // one field of the parent node.\n    return nodes.filter(node => {\n      return !(\n        this.graphOptions.shouldUnrelate(node, this.graph) &&\n        node.parentEdge.relation.isObjectionBelongsToOneRelation\n      );\n    });\n  }\n\n  _createDeleteBuilders(parentBuilder, nodesTodelete) {\n    const nodesByRelation = groupBy(nodesTodelete, getRelation);\n    const builders = [];\n\n    nodesByRelation.forEach((nodes, relation) => {\n      const nodesByParent = groupBy(nodes, getParent);\n\n      nodesByParent.forEach((nodes, parentNode) => {\n        const shouldUnrelate = this.graphOptions.shouldUnrelate(nodes[0], this.graph);\n\n        const builder = parentNode.obj.$relatedQuery(relation.name).childQueryOf(parentBuilder);\n\n        if (!relation.isObjectionBelongsToOneRelation) {\n          // This is useless in case of BelongsToOneRelation.\n          builder.findByIds(nodes.map(node => node.obj.$id()));\n        }\n\n        for (const node of nodes) {\n          node.userData.deleted = true;\n        }\n\n        builders.push(shouldUnrelate ? builder.unrelate() : builder.delete());\n      });\n    });\n\n    return builders;\n  }\n}\n\nfunction getRelation(node) {\n  return node.parentEdge.relation;\n}\n\nfunction getParent(node) {\n  return node.parentNode;\n}\n\nmodule.exports = {\n  GraphDeleteAction\n};\n","'use strict';\n\nconst { JoinRowGraphInsertAction } = require('./JoinRowGraphInsertAction');\nconst { GraphInsertAction } = require('./GraphInsertAction');\nconst { GraphOperation } = require('../GraphOperation');\nconst { ModelGraphEdge } = require('../../../model/graph/ModelGraphEdge');\n\nclass GraphInsert extends GraphOperation {\n  constructor(...args) {\n    super(...args);\n    this.dependencies = this._createDependencyMap();\n  }\n\n  createActions() {\n    return [...this._createNormalActions(), ...this._createJoinRowActions()];\n  }\n\n  _createDependencyMap() {\n    const dependencies = new Map();\n\n    for (const edge of this.graph.edges) {\n      if (edge.type == ModelGraphEdge.Type.Relation) {\n        this._createRelationDependency(edge, dependencies);\n      } else {\n        this._createReferenceDependency(edge, dependencies);\n      }\n    }\n\n    return dependencies;\n  }\n\n  _createRelationDependency(edge, dependencies) {\n    if (edge.relation.isObjectionHasManyRelation) {\n      // In case of HasManyRelation the related node depends on the owner node\n      // because the related node has the foreign key.\n      this._addDependency(edge.relatedNode, edge, dependencies);\n    } else if (edge.relation.isObjectionBelongsToOneRelation) {\n      // In case of BelongsToOneRelation the owner node depends on the related\n      // node because the owner node has the foreign key.\n      this._addDependency(edge.ownerNode, edge, dependencies);\n    }\n  }\n\n  _createReferenceDependency(edge, dependencies) {\n    this._addDependency(edge.ownerNode, edge, dependencies);\n  }\n\n  _addDependency(node, edge, dependencies) {\n    let edges = dependencies.get(node);\n\n    if (!edges) {\n      edges = [];\n      dependencies.set(node, edges);\n    }\n\n    edges.push(edge);\n  }\n\n  _createNormalActions() {\n    const handledNodes = new Set();\n    const actions = [];\n\n    while (true) {\n      // At this point, don't care if the nodes have already been inserted before\n      // given to this class. `GraphInsertAction` will test that and only insert\n      // new ones. We need to pass all nodes to `GraphInsertActions` so that we\n      // can resolve all dependencies.\n      const nodesToInsert = this.graph.nodes.filter(node => {\n        return !this._isHandled(node, handledNodes) && !this._hasDependencies(node, handledNodes);\n      });\n\n      if (nodesToInsert.length === 0) {\n        break;\n      }\n\n      actions.push(\n        new GraphInsertAction({\n          nodes: nodesToInsert,\n          currentGraph: this.currentGraph,\n          dependencies: this.dependencies,\n          graphOptions: this.graphOptions\n        })\n      );\n\n      for (const node of nodesToInsert) {\n        this._markHandled(node, handledNodes);\n      }\n    }\n\n    if (handledNodes.size !== this.graph.nodes.length) {\n      throw new Error('the object graph contains cyclic references');\n    }\n\n    return actions;\n  }\n\n  _isHandled(node, handledNodes) {\n    return handledNodes.has(node);\n  }\n\n  _hasDependencies(node, handledNodes) {\n    if (!this.dependencies.has(node)) {\n      return false;\n    }\n\n    for (const edge of this.dependencies.get(node)) {\n      const dependencyNode = edge.getOtherNode(node);\n\n      if (!handledNodes.has(dependencyNode) && !this.currentGraph.nodeForNode(dependencyNode)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _markHandled(node, handledNodes) {\n    handledNodes.add(node);\n\n    // The referencing nodes are all references that don't\n    // represent any real entity. They are simply intermediate nodes\n    // that depend on this node. Once this node is handled, we can\n    // also mark those nodes as handled as there is nothing to actually\n    // insert.\n    for (const refNode of node.referencingNodes) {\n      this._markHandled(refNode, handledNodes);\n    }\n  }\n\n  _createJoinRowActions() {\n    return [\n      new JoinRowGraphInsertAction({\n        nodes: this.graph.nodes.filter(node => {\n          return (\n            this.currentGraph.nodeForNode(node) === null &&\n            node.parentEdge &&\n            node.parentEdge.relation.isObjectionManyToManyRelation\n          );\n        }),\n\n        currentGraph: this.currentGraph,\n        graphOptions: this.graphOptions\n      })\n    ];\n  }\n}\n\nmodule.exports = {\n  GraphInsert\n};\n","'use strict';\n\nconst { GraphAction } = require('../GraphAction');\nconst { groupBy, chunk, get, set } = require('../../../utils/objectUtils');\nconst { ModelGraphEdge } = require('../../../model/graph/ModelGraphEdge');\nconst promiseUtils = require('../../../utils/promiseUtils');\n\n/**\n * Inserts a batch of nodes for a GraphInsert.\n *\n * One of these is created for each batch of nodes that can be inserted at once.\n * However, the nodes can have a different table and not all databases support\n * batch inserts, so this class splits the inserts into further sub batches\n * when needed.\n */\nclass GraphInsertAction extends GraphAction {\n  constructor({ nodes, currentGraph, dependencies, graphOptions }) {\n    super();\n\n    // Nodes to insert.\n    this.nodes = nodes;\n    this.currentGraph = currentGraph;\n    this.dependencies = dependencies;\n    this.graphOptions = graphOptions;\n  }\n\n  run(builder) {\n    const batches = this._createInsertBatches(builder);\n    const concurrency = this._getConcurrency(builder, this.nodes);\n\n    return promiseUtils.map(batches, batch => this._insertBatch(builder, batch), { concurrency });\n  }\n\n  _createInsertBatches(builder) {\n    const batches = [];\n    const batchSize = this._getBatchSize(builder);\n    const nodesByModelClass = groupBy(this.nodes, getModelClass);\n\n    for (const nodes of nodesByModelClass.values()) {\n      for (const nodeBatch of chunk(nodes, batchSize)) {\n        batches.push(nodeBatch);\n      }\n    }\n\n    return batches;\n  }\n\n  _insertBatch(parentBuilder, nodes) {\n    return this._beforeInsert(nodes)\n      .then(() => this._insert(parentBuilder, nodes))\n      .then(() => this._afterInsert(nodes));\n  }\n\n  _beforeInsert(nodes) {\n    this._resolveDependencies(nodes);\n    this._omitManyToManyExtraProps(nodes);\n    this._copyRelationPropsFromCurrentIfNeeded(nodes);\n\n    return Promise.resolve();\n  }\n\n  _resolveDependencies(nodes) {\n    for (const node of nodes) {\n      const edges = this.dependencies.get(node);\n\n      if (edges) {\n        for (const edge of edges) {\n          // `node` needs `dependencyNode` to have been inserted (and it has been).\n          const dependencyNode = edge.getOtherNode(node);\n\n          this._resolveDependency(dependencyNode, edge);\n        }\n      }\n    }\n  }\n\n  _resolveDependency(dependencyNode, edge) {\n    if (edge.type === ModelGraphEdge.Type.Relation && !edge.relation.joinTable) {\n      this._resolveRelationDependency(dependencyNode, edge);\n    } else if (edge.refType === ModelGraphEdge.ReferenceType.Property) {\n      this._resolvePropertyReferenceNode(dependencyNode, edge);\n    }\n  }\n\n  _resolveRelationDependency(dependencyNode, edge) {\n    const dependentNode = edge.getOtherNode(dependencyNode);\n\n    let sourceProp;\n    let targetProp;\n\n    if (edge.isOwnerNode(dependencyNode)) {\n      sourceProp = edge.relation.ownerProp;\n      targetProp = edge.relation.relatedProp;\n    } else {\n      targetProp = edge.relation.ownerProp;\n      sourceProp = edge.relation.relatedProp;\n    }\n\n    this._resolveReferences(dependencyNode);\n\n    for (let i = 0, l = targetProp.size; i < l; ++i) {\n      targetProp.setProp(dependentNode.obj, i, sourceProp.getProp(dependencyNode.obj, i));\n    }\n  }\n\n  _resolvePropertyReferenceNode(dependencyNode, edge) {\n    const dependentNode = edge.getOtherNode(dependencyNode);\n\n    let sourcePath;\n    let targetPath;\n\n    if (edge.isOwnerNode(dependencyNode)) {\n      sourcePath = edge.refOwnerDataPath;\n      targetPath = edge.refRelatedDataPath;\n    } else {\n      targetPath = edge.refOwnerDataPath;\n      sourcePath = edge.refRelatedDataPath;\n    }\n\n    const sourceValue = get(dependencyNode.obj, sourcePath);\n    const targetValue = get(dependentNode.obj, targetPath);\n\n    if (targetValue === edge.refMatch) {\n      set(dependentNode.obj, targetPath, sourceValue);\n    } else {\n      set(dependentNode.obj, targetPath, targetValue.replace(edge.refMatch, sourceValue));\n    }\n  }\n\n  _omitManyToManyExtraProps(nodes) {\n    for (const node of nodes) {\n      if (\n        node.parentEdge &&\n        node.parentEdge.type === ModelGraphEdge.Type.Relation &&\n        node.parentEdge.relation.joinTableExtras.length > 0\n      ) {\n        node.parentEdge.relation.omitExtraProps([node.obj]);\n      }\n    }\n  }\n\n  _copyRelationPropsFromCurrentIfNeeded(nodes) {\n    for (const node of nodes) {\n      const currentNode = this.currentGraph.nodeForNode(node);\n\n      if (!currentNode) {\n        continue;\n      }\n\n      for (const edge of node.edges) {\n        if (edge.type !== ModelGraphEdge.Type.Relation) {\n          continue;\n        }\n\n        const prop = edge.isOwnerNode(node) ? edge.relation.ownerProp : edge.relation.relatedProp;\n\n        for (let i = 0, l = prop.size; i < l; ++i) {\n          const value = prop.getProp(node.obj, i);\n\n          if (value !== undefined) {\n            continue;\n          }\n\n          prop.setProp(node.obj, i, prop.getProp(currentNode.obj, i));\n        }\n      }\n    }\n  }\n\n  _insert(parentBuilder, nodes) {\n    const [{ modelClass }] = nodes;\n\n    nodes = nodes.filter(node => {\n      return this.graphOptions.shouldInsert(node, this.currentGraph);\n    });\n\n    for (const node of nodes) {\n      delete node.obj[modelClass.uidProp];\n      node.obj.$validate(null, { dataPath: node.dataPathKey });\n    }\n\n    if (nodes.length === 0) {\n      return;\n    }\n\n    for (const node of nodes) {\n      node.userData.inserted = true;\n    }\n\n    return this._runRelationBeforeInsertMethods(parentBuilder, nodes).then(() => {\n      return modelClass\n        .query()\n        .insert(nodes.map(node => node.obj))\n        .childQueryOf(parentBuilder)\n        .copyFrom(parentBuilder, GraphAction.ReturningAllSelector)\n        .execute();\n    });\n  }\n\n  _runRelationBeforeInsertMethods(parentBuilder, nodes) {\n    return Promise.all(\n      nodes.map(node => {\n        if (node.parentEdge) {\n          return node.parentEdge.relation.beforeInsert(node.obj, parentBuilder.context());\n        } else {\n          return null;\n        }\n      })\n    );\n  }\n\n  _afterInsert(nodes) {\n    for (const node of nodes) {\n      for (const refNode of node.referencingNodes) {\n        this._resolveDependency(refNode, refNode.parentEdge);\n      }\n    }\n  }\n}\n\nfunction getModelClass(node) {\n  return node.modelClass;\n}\n\nmodule.exports = {\n  GraphInsertAction\n};\n","'use strict';\n\nconst { GraphAction } = require('../GraphAction');\nconst { groupBy, chunk } = require('../../../utils/objectUtils');\nconst promiseUtils = require('../../../utils/promiseUtils');\n\nclass JoinRowGraphInsertAction extends GraphAction {\n  constructor({ nodes, currentGraph, graphOptions }) {\n    super();\n\n    this.nodes = nodes;\n    this.currentGraph = currentGraph;\n    this.graphOptions = graphOptions;\n  }\n\n  run(builder) {\n    const batches = this._createInsertBatches(builder);\n    const concurrency = this._getConcurrency(builder, this.nodes);\n\n    return promiseUtils.map(batches, batch => this._insertBatch(builder, batch), { concurrency });\n  }\n\n  _createInsertBatches(builder) {\n    const batches = [];\n    const batchSize = this._getBatchSize(builder);\n    const nodesByModel = groupBy(this.nodes, node => getJoinTableModel(builder, node));\n\n    for (const [joinTableModelClass, nodes] of nodesByModel.entries()) {\n      for (const nodeBatch of chunk(nodes, batchSize)) {\n        batches.push(this._createBatch(joinTableModelClass, nodeBatch));\n      }\n    }\n\n    return batches;\n  }\n\n  _createBatch(joinTableModelClass, nodes) {\n    return nodes\n      .filter(node => {\n        return this.graphOptions.shouldRelate(node, this.currentGraph) || node.userData.inserted;\n      })\n      .map(node => ({\n        node,\n        joinTableModelClass,\n        joinTableObj: this._createJoinTableObj(joinTableModelClass, node)\n      }));\n  }\n\n  _createJoinTableObj(joinTableModelClass, node) {\n    const { parentEdge, parentNode } = node;\n    const { relation } = parentEdge;\n\n    this._resolveReferences(node);\n\n    return joinTableModelClass.fromJson(\n      relation.createJoinModel(relation.ownerProp.getProps(parentNode.obj), node.obj)\n    );\n  }\n\n  _insertBatch(parentBuilder, batch) {\n    return this._beforeInsert(parentBuilder, batch).then(() => this._insert(parentBuilder, batch));\n  }\n\n  _beforeInsert(parentBuilder, batch) {\n    return Promise.all(\n      batch.map(({ node, joinTableObj }) => {\n        if (node.parentEdge) {\n          return node.parentEdge.relation.joinTableBeforeInsert(\n            joinTableObj,\n            parentBuilder.context()\n          );\n        } else {\n          return null;\n        }\n      })\n    );\n  }\n\n  _insert(parentBuilder, batch) {\n    if (batch.length > 0) {\n      return batch[0].joinTableModelClass\n        .query()\n        .childQueryOf(parentBuilder)\n        .insert(batch.map(it => it.joinTableObj));\n    }\n  }\n}\n\nfunction getJoinTableModel(builder, node) {\n  return node.parentEdge.relation.getJoinModelClass(builder.unsafeKnex());\n}\n\nmodule.exports = {\n  JoinRowGraphInsertAction\n};\n","'use strict';\n\nconst { GraphOperation } = require('../GraphOperation');\nconst { GraphPatchAction } = require('./GraphPatchAction');\n\nclass GraphPatch extends GraphOperation {\n  createActions() {\n    return [\n      new GraphPatchAction({\n        nodes: this.graph.nodes.filter(node =>\n          this.graphOptions.shouldPatchOrUpdateIgnoreDisable(node, this.currentGraph)\n        ),\n\n        graph: this.graph,\n        currentGraph: this.currentGraph,\n        graphOptions: this.graphOptions\n      })\n    ];\n  }\n}\n\nmodule.exports = {\n  GraphPatch\n};\n","'use strict';\n\nconst { GraphAction } = require('../GraphAction');\nconst { isInternalProp } = require('../../../utils/internalPropUtils');\nconst { union, difference, isObject, jsonEquals } = require('../../../utils/objectUtils');\nconst promiseUtils = require('../../../utils/promiseUtils');\n\nclass GraphPatchAction extends GraphAction {\n  constructor({ nodes, graph, currentGraph, graphOptions }) {\n    super();\n\n    // Nodes to patch.\n    this.nodes = nodes;\n    this.graph = graph;\n    this.currentGraph = currentGraph;\n    this.graphOptions = graphOptions;\n  }\n\n  run(builder) {\n    return promiseUtils.map(this.nodes, node => this._runForNode(builder, node), {\n      concurrency: this._getConcurrency(builder, this.nodes)\n    });\n  }\n\n  _runForNode(builder, node) {\n    const shouldPatch = this.graphOptions.shouldPatch(node, this.currentGraph);\n    const shouldUpdate = this.graphOptions.shouldUpdate(node, this.currentGraph);\n\n    // BelongsToOneRelation inserts and relates change the parent object's\n    // properties. That's why we handle them here.\n    const changedPropsBecauseOfBelongsToOneInsert = this._handleBelongsToOneInserts(node);\n\n    // BelongsToOneRelation deletes and unrelates change the parent object's\n    // properties. That's why we handle them here.\n    const changePropsBecauseOfBelongsToOneDelete = this._handleBelongsToOneDeletes(node);\n\n    const { changedProps, unchangedProps } = this._findChanges(node);\n    const allProps = union(changedProps, unchangedProps);\n\n    const propsToUpdate = difference(\n      shouldPatch || shouldUpdate\n        ? changedProps\n        : [...changedPropsBecauseOfBelongsToOneInsert, ...changePropsBecauseOfBelongsToOneDelete],\n\n      // Remove id properties from the props to update. With upsertGraph\n      // it never makes sense to change the id.\n      node.modelClass.getIdPropertyArray()\n    );\n\n    if (propsToUpdate.length === 0) {\n      return null;\n    }\n\n    delete node.obj[node.modelClass.uidProp];\n    delete node.obj[node.modelClass.uidRefProp];\n    delete node.obj[node.modelClass.dbRefProp];\n\n    node.obj.$validate(null, {\n      dataPath: node.dataPathKey,\n      patch: shouldPatch || (!shouldPatch && !shouldUpdate)\n    });\n\n    // Don't update the fields that we know not to change.\n    node.obj.$omitFromDatabaseJson(difference(allProps, propsToUpdate));\n    node.userData.updated = true;\n\n    const updateBuilder = this._createBuilder(node)\n      .childQueryOf(builder)\n      .copyFrom(builder, GraphAction.ReturningAllSelector);\n\n    if (shouldPatch) {\n      updateBuilder.patch(node.obj);\n    } else {\n      updateBuilder.update(node.obj);\n    }\n\n    return updateBuilder.execute().then(result => {\n      if (isObject(result) && result.$isObjectionModel) {\n        // Handle returning('*').\n        node.obj.$set(result);\n      }\n\n      return result;\n    });\n  }\n\n  _handleBelongsToOneInserts(node) {\n    const currentNode = this.currentGraph.nodeForNode(node);\n    const updatedProps = [];\n\n    for (const edge of node.edges) {\n      if (\n        edge.isOwnerNode(node) &&\n        edge.relation &&\n        edge.relation.isObjectionBelongsToOneRelation &&\n        edge.relation.relatedProp.hasProps(edge.relatedNode.obj)\n      ) {\n        const { relation } = edge;\n\n        for (let i = 0, l = relation.ownerProp.size; i < l; ++i) {\n          const currentValue = currentNode && relation.ownerProp.getProp(currentNode.obj, i);\n          const relatedValue = relation.relatedProp.getProp(edge.relatedNode.obj, i);\n\n          if (currentValue != relatedValue) {\n            relation.ownerProp.setProp(node.obj, i, relatedValue);\n            updatedProps.push(relation.ownerProp.props[i]);\n          }\n        }\n      }\n    }\n\n    return updatedProps;\n  }\n\n  _handleBelongsToOneDeletes(node) {\n    const currentNode = this.currentGraph.nodeForNode(node);\n    const updatedProps = [];\n\n    if (!currentNode) {\n      return updatedProps;\n    }\n\n    for (const edge of currentNode.edges) {\n      if (\n        edge.isOwnerNode(currentNode) &&\n        edge.relation.isObjectionBelongsToOneRelation &&\n        node.obj[edge.relation.name] === null &&\n        this.graphOptions.shouldDeleteOrUnrelate(edge.relatedNode, this.graph)\n      ) {\n        const { relation } = edge;\n\n        for (let i = 0, l = relation.ownerProp.size; i < l; ++i) {\n          const currentValue = relation.ownerProp.getProp(currentNode.obj, i);\n\n          if (currentValue != null) {\n            relation.ownerProp.setProp(node.obj, i, null);\n            updatedProps.push(relation.ownerProp.props[i]);\n          }\n        }\n      }\n    }\n\n    return updatedProps;\n  }\n\n  _findChanges(node) {\n    const obj = node.obj;\n    const currentNode = this.currentGraph.nodeForNode(node);\n    const currentObj = (currentNode && currentNode.obj) || {};\n    const relationNames = node.modelClass.getRelationNames();\n\n    const unchangedProps = [];\n    const changedProps = [];\n\n    for (const prop of Object.keys(obj)) {\n      if (isInternalProp(prop) || relationNames.includes(prop)) {\n        continue;\n      }\n\n      const value = obj[prop];\n      const currentValue = currentObj[prop];\n\n      // If the current object doesn't have the property, we have to assume\n      // it changes (we cannot know if it will). If the object does have the\n      // property, we test non-strict equality. See issue #732.\n      if (currentValue === undefined || !nonStrictEquals(currentValue, value)) {\n        changedProps.push(prop);\n      } else {\n        unchangedProps.push(prop);\n      }\n    }\n\n    // We cannot know if the query properties cause changes to the values.\n    // We must assume that they do.\n    if (obj.$$queryProps) {\n      changedProps.push(...Object.keys(obj.$$queryProps));\n    }\n\n    return {\n      changedProps,\n      unchangedProps\n    };\n  }\n\n  _createBuilder(node) {\n    if (node.parentEdge && !node.parentEdge.relation.isObjectionHasManyRelation) {\n      return this._createRelatedBuilder(node);\n    } else {\n      return this._createRootBuilder(node);\n    }\n  }\n\n  _createRelatedBuilder(node) {\n    return node.parentNode.obj\n      .$relatedQuery(node.parentEdge.relation.name)\n      .findById(node.obj.$id());\n  }\n\n  _createRootBuilder(node) {\n    return node.obj.$query();\n  }\n}\n\nfunction nonStrictEquals(val1, val2) {\n  if (val1 == val2) {\n    return true;\n  }\n\n  return jsonEquals(val1, val2);\n}\n\nmodule.exports = {\n  GraphPatchAction\n};\n","'use strict';\n\nconst { GraphOperation } = require('../GraphOperation');\nconst { GraphRecursiveUpsertAction } = require('./GraphRecursiveUpsertAction');\n\nclass GraphRecursiveUpsert extends GraphOperation {\n  createActions() {\n    return [\n      new GraphRecursiveUpsertAction({\n        nodes: this.graph.nodes.filter(node => {\n          const shouldRelate = this.graphOptions.shouldRelate(node, this.currentGraph);\n          return shouldRelate && hasRelations(node.obj);\n        }),\n\n        currentGraph: this.currentGraph,\n        graphOptions: this.graphOptions\n      })\n    ];\n  }\n}\n\nfunction hasRelations(obj) {\n  for (const relationName of obj.constructor.getRelationNames()) {\n    if (obj.hasOwnProperty(relationName)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  GraphRecursiveUpsert\n};\n","'use strict';\n\nconst { GraphAction } = require('../GraphAction');\nconst { groupBy } = require('../../../utils/objectUtils');\nconst promiseUtils = require('../../../utils/promiseUtils');\n\nclass GraphRecursiveUpsertAction extends GraphAction {\n  constructor({ nodes, graph, graphOptions }) {\n    super();\n\n    // Nodes to upsert.\n    this.nodes = nodes;\n    this.graph = graph;\n    this.graphOptions = graphOptions;\n  }\n\n  run(builder) {\n    const builders = this._createUpsertBuilders(builder, this.nodes);\n\n    return promiseUtils.map(builders, builder => builder.execute(), {\n      concurrency: this._getConcurrency(builder, this.nodes)\n    });\n  }\n\n  _createUpsertBuilders(parentBuilder, nodesToUpsert) {\n    const nodesByRelation = groupBy(nodesToUpsert, getRelation);\n    const builders = [];\n\n    nodesByRelation.forEach(nodes => {\n      const nodesByParent = groupBy(nodes, getParent);\n\n      nodesByParent.forEach(nodes => {\n        for (const node of nodes) {\n          node.userData.upserted = true;\n        }\n\n        builders.push(\n          nodes[0].modelClass\n            .query()\n            .childQueryOf(parentBuilder)\n            .copyFrom(parentBuilder, GraphAction.ReturningAllSelector)\n            .upsertGraph(nodes.map(node => node.obj), this.graphOptions.rebasedOptions(nodes[0]))\n        );\n      });\n    });\n\n    return builders;\n  }\n}\n\nfunction getRelation(node) {\n  return node.parentEdge.relation;\n}\n\nfunction getParent(node) {\n  return node.parentNode;\n}\n\nmodule.exports = {\n  GraphRecursiveUpsertAction\n};\n","'use strict';\n\nclass JoinResultColumn {\n  constructor({ columnAlias, tableNode, name }) {\n    this.columnAlias = columnAlias;\n    this.tableNode = tableNode;\n    this.name = name;\n  }\n\n  static create({ tableTree, columnAlias }) {\n    const tableNode = tableTree.getNodeForColumnAlias(columnAlias);\n\n    return new JoinResultColumn({\n      columnAlias,\n      tableNode,\n      name: tableNode.getColumnForColumnAlias(columnAlias)\n    });\n  }\n}\n\nmodule.exports = {\n  JoinResultColumn\n};\n","'use strict';\n\nconst { JoinResultColumn } = require('./JoinResultColumn');\nconst { groupBy } = require('../../utils/objectUtils');\n\nclass JoinResultParser {\n  constructor({ tableTree, omitColumnAliases = [] }) {\n    this.tableTree = tableTree;\n    this.omitColumnAliases = new Set(omitColumnAliases);\n\n    this.columnsByTableNode = null;\n    this.parentMap = null;\n    this.rootModels = null;\n  }\n\n  static create(args) {\n    return new JoinResultParser(args);\n  }\n\n  parse(flatRows) {\n    if (!Array.isArray(flatRows) || flatRows.length === 0) {\n      return flatRows;\n    }\n\n    this.columnsByTableNode = this._createColumns(flatRows[0]);\n    this.parentMap = new Map();\n    this.rootModels = [];\n\n    for (const flatRow of flatRows) {\n      this._parseNode(this.tableTree.rootNode, flatRow);\n    }\n\n    return this.rootModels;\n  }\n\n  _parseNode(tableNode, flatRow, parentModel = null, parentKey = null) {\n    const id = tableNode.getIdFromFlatRow(flatRow);\n\n    if (id === null) {\n      return;\n    }\n\n    const key = getKey(parentKey, id, tableNode);\n    let model = this.parentMap.get(key);\n\n    if (!model) {\n      model = this._createModel(tableNode, flatRow);\n\n      this._addToParent(tableNode, model, parentModel);\n      this.parentMap.set(key, model);\n    }\n\n    for (const childNode of tableNode.childNodes) {\n      this._parseNode(childNode, flatRow, model, key);\n    }\n  }\n\n  _createModel(tableNode, flatRow) {\n    const row = {};\n    const columns = this.columnsByTableNode.get(tableNode);\n\n    if (columns) {\n      for (const column of columns) {\n        if (!this.omitColumnAliases.has(column.columnAlias)) {\n          row[column.name] = flatRow[column.columnAlias];\n        }\n      }\n    }\n\n    const model = tableNode.modelClass.fromDatabaseJson(row);\n\n    for (const childNode of tableNode.childNodes) {\n      if (childNode.relation.isOneToOne()) {\n        model[childNode.relationProperty] = null;\n      } else {\n        model[childNode.relationProperty] = [];\n      }\n    }\n\n    return model;\n  }\n\n  _addToParent(tableNode, model, parentModel) {\n    if (tableNode.parentNode) {\n      if (tableNode.relation.isOneToOne()) {\n        parentModel[tableNode.relationProperty] = model;\n      } else {\n        parentModel[tableNode.relationProperty].push(model);\n      }\n    } else {\n      // Root model. Add to root list.\n      this.rootModels.push(model);\n    }\n  }\n\n  _createColumns(row) {\n    const columns = Object.keys(row).map(columnAlias =>\n      JoinResultColumn.create({ tableTree: this.tableTree, columnAlias })\n    );\n\n    return groupBy(columns, getTableNode);\n  }\n}\n\nfunction getTableNode(column) {\n  return column.tableNode;\n}\n\nfunction getKey(parentKey, id, tableNode) {\n  if (parentKey !== null) {\n    return `${parentKey}/${tableNode.relationProperty}/${id}`;\n  } else {\n    return `/${id}`;\n  }\n}\n\nmodule.exports = {\n  JoinResultParser\n};\n","'use strict';\n\nconst { uniqBy } = require('../../utils/objectUtils');\nconst { Selection } = require('../operations/select/Selection');\nconst { createModifier } = require('../../utils/createModifier');\nconst { map: mapPromise } = require('../../utils/promiseUtils');\nconst { ValidationErrorType } = require('../../model/ValidationError');\n\nconst { TableTree } = require('./TableTree');\nconst { JoinResultParser } = require('./JoinResultParser');\nconst { ID_LENGTH_LIMIT } = require('./utils');\n\n/**\n * Given a relation expression, builds a query using joins to fetch it.\n */\nclass RelationJoiner {\n  constructor({ modelClass }) {\n    this.rootModelClass = modelClass;\n\n    // The relation expression to join.\n    this.expression = null;\n\n    // Explicit modifiers for the relation expression.\n    this.modifiers = null;\n\n    this.options = defaultOptions();\n    this.tableTree = null;\n    this.internalSelections = null;\n  }\n\n  setExpression(expression) {\n    if (!this.expression) {\n      this.expression = expression;\n    }\n\n    return this;\n  }\n\n  setModifiers(modifiers) {\n    if (!this.modifiers) {\n      this.modifiers = modifiers;\n    }\n\n    return this;\n  }\n\n  setOptions(options) {\n    this.options = Object.assign(this.options, options);\n    return this;\n  }\n\n  /**\n   * Fetches the column information needed for building the select clauses.\n   *\n   * This must be called before calling `build(builder, true)`. `build(builder, false)`\n   * can be called without this since it doesn't build selects.\n   */\n  fetchColumnInfo(builder) {\n    const tableTree = this._getTableTree(builder);\n    const allModelClasses = new Set(tableTree.nodes.map(node => node.modelClass));\n\n    return mapPromise(\n      Array.from(allModelClasses),\n      modelClass => modelClass.fetchTableMetadata({ parentBuilder: builder }),\n      {\n        concurrency: this.rootModelClass.getConcurrency(builder.unsafeKnex())\n      }\n    );\n  }\n\n  build(builder, buildSelects = true) {\n    const rootTableNode = this._getTableTree(builder).rootNode;\n    const userSelectQueries = new Map([[rootTableNode, builder]]);\n\n    for (const tableNode of rootTableNode.childNodes) {\n      this._buildJoinsForNode({ builder, tableNode, userSelectQueries });\n    }\n\n    if (buildSelects) {\n      this._buildSelects({ builder, tableNode: rootTableNode, userSelectQueries });\n    }\n  }\n\n  parseResult(builder, flatRows) {\n    const parser = JoinResultParser.create({\n      tableTree: this._getTableTree(builder),\n      omitColumnAliases: this.internalSelections.map(it => it.alias)\n    });\n\n    return parser.parse(flatRows);\n  }\n\n  _getTableTree(builder) {\n    if (!this.tableTree) {\n      // Create the table tree lazily.\n      this.tableTree = TableTree.create({\n        rootModelClass: this.rootModelClass,\n        rootTableAlias: builder.tableRef(),\n        expression: this.expression,\n        options: this.options\n      });\n    }\n\n    return this.tableTree;\n  }\n\n  _buildJoinsForNode({ builder, tableNode, userSelectQueries }) {\n    const subqueryToJoin = createSubqueryToJoin({\n      builder,\n      tableNode,\n      modifiers: this.modifiers\n    });\n\n    const userSelectQuery = subqueryToJoin.clone();\n\n    // relation.join applies the relation modifier that can\n    // also contain selects.\n    userSelectQuery.modify(tableNode.relation.modify);\n\n    // Save the query that contains the user specified selects\n    // for later use.\n    userSelectQueries.set(tableNode, userSelectQuery);\n\n    tableNode.relation.join(builder, {\n      joinOperation: this.options.joinOperation,\n\n      ownerTable: tableNode.parentNode.alias,\n      relatedTableAlias: tableNode.alias,\n      joinTableAlias: tableNode.joinTableAlias,\n\n      relatedJoinSelectQuery: ensureIdAndRelationPropsAreSelected({\n        builder: subqueryToJoin,\n        tableNode\n      })\n    });\n\n    for (const childNode of tableNode.childNodes) {\n      this._buildJoinsForNode({ builder, tableNode: childNode, userSelectQueries });\n    }\n  }\n\n  _buildSelects({ builder, tableNode, userSelectQueries }) {\n    const { selections, internalSelections } = getSelectionsForNode({\n      builder,\n      tableNode,\n      userSelectQueries\n    });\n\n    for (const selection of selections) {\n      checkAliasLength(tableNode.modelClass, selection.name);\n    }\n\n    // Save the selections that were added internally (not by the user)\n    // so that we can later remove the corresponding properties when\n    // parsing the result.\n    this.internalSelections = internalSelections;\n\n    builder.select(selectionsToStrings(selections));\n  }\n}\n\nfunction defaultOptions() {\n  return {\n    joinOperation: 'leftJoin',\n    minimize: false,\n    separator: ':',\n    aliases: {}\n  };\n}\n\nfunction createSubqueryToJoin({ builder, tableNode, modifiers }) {\n  const { relation, expression, modelClass } = tableNode;\n  const modifierQuery = modelClass.query().childQueryOf(builder);\n\n  for (const modifierName of expression.node.$modify) {\n    const modifier = createModifier({\n      modifier: modifierName,\n      modelClass,\n      modifiers\n    });\n\n    try {\n      modifier(modifierQuery);\n    } catch (err) {\n      if (err instanceof modelClass.ModifierNotFoundError) {\n        throw modelClass.createValidationError({\n          type: ValidationErrorType.RelationExpression,\n          message: `could not find modifier \"${modifierName}\" for relation \"${relation.name}\"`\n        });\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  return modifierQuery;\n}\n\nfunction ensureIdAndRelationPropsAreSelected({ builder, tableNode }) {\n  const tableRef = builder.tableRef();\n\n  const cols = [\n    ...builder.modelClass().getIdColumnArray(),\n    ...tableNode.relation.relatedProp.cols,\n    ...tableNode.childNodes.reduce(\n      (cols, childNode) => [...cols, ...childNode.relation.ownerProp.cols],\n      []\n    )\n  ];\n\n  const selectStrings = uniqBy(cols)\n    .filter(col => !builder.hasSelectionAs(col, col))\n    .map(col => `${tableRef}.${col}`);\n\n  return builder.select(selectStrings);\n}\n\nfunction getSelectionsForNode({ builder, tableNode, userSelectQueries }) {\n  const userSelectQuery = userSelectQueries.get(tableNode);\n  const userSelections = userSelectQuery.findAllSelections();\n  const userSelectedAllColumns = isSelectAllSelectionSet(userSelections);\n\n  let selections = [];\n  let internalSelections = [];\n\n  if (tableNode.parentNode) {\n    selections = mapUserSelectionsFromSubqueryToMainQuery({ userSelections, tableNode });\n\n    if (userSelectedAllColumns && tableNode.relation.isObjectionManyToManyRelation) {\n      const extraSelections = getJoinTableExtraSelectionsForNode({ tableNode });\n      selections = selections.concat(extraSelections);\n    }\n  }\n\n  if (userSelectedAllColumns) {\n    const allColumnSelections = getAllColumnSelectionsForNode({ builder, tableNode });\n    selections = allColumnSelections.concat(selections);\n  } else {\n    const idSelections = getIdSelectionsForNode({ tableNode });\n\n    for (const idSelection of idSelections) {\n      if (!userSelectQuery.hasSelectionAs(idSelection.column, idSelection.column)) {\n        selections.push(idSelection);\n        internalSelections.push(idSelection);\n      }\n    }\n  }\n\n  for (const childNode of tableNode.childNodes) {\n    const childResult = getSelectionsForNode({ builder, tableNode: childNode, userSelectQueries });\n\n    selections = selections.concat(childResult.selections);\n    internalSelections = internalSelections.concat(childResult.internalSelections);\n  }\n\n  return {\n    selections,\n    internalSelections\n  };\n}\n\nfunction mapUserSelectionsFromSubqueryToMainQuery({ userSelections, tableNode }) {\n  return userSelections.filter(isNotSelectAll).map(selection => {\n    return new Selection(\n      tableNode.alias,\n      selection.name,\n      tableNode.getColumnAliasForColumn(selection.name)\n    );\n  });\n}\n\nfunction getJoinTableExtraSelectionsForNode({ tableNode }) {\n  return tableNode.relation.joinTableExtras.map(extra => {\n    return new Selection(\n      tableNode.joinTableAlias,\n      extra.joinTableCol,\n      tableNode.getColumnAliasForColumn(extra.aliasCol)\n    );\n  });\n}\n\nfunction getAllColumnSelectionsForNode({ builder, tableNode }) {\n  const table = builder.tableNameFor(tableNode.modelClass);\n\n  return tableNode.modelClass.tableMetadata({ table }).columns.map(columnName => {\n    return new Selection(\n      tableNode.alias,\n      columnName,\n      tableNode.getColumnAliasForColumn(columnName)\n    );\n  });\n}\n\nfunction getIdSelectionsForNode({ tableNode }) {\n  return tableNode.modelClass.getIdColumnArray().map(columnName => {\n    return new Selection(\n      tableNode.alias,\n      columnName,\n      tableNode.getColumnAliasForColumn(columnName)\n    );\n  });\n}\n\nfunction selectionsToStrings(selections) {\n  return selections.map(selection => {\n    const selectStr = `${selection.table}.${selection.column}`;\n    return `${selectStr} as ${selection.alias}`;\n  });\n}\n\nfunction isSelectAll(selection) {\n  return selection.column === '*';\n}\n\nfunction isNotSelectAll(selection) {\n  return selection.column !== '*';\n}\n\nfunction isSelectAllSelectionSet(selections) {\n  return selections.length === 0 || selections.some(isSelectAll);\n}\n\nfunction checkAliasLength(modelClass, alias) {\n  if (alias.length > ID_LENGTH_LIMIT) {\n    throw modelClass.createValidationError({\n      type: ValidationErrorType.RelationExpression,\n      message: `identifier ${alias} is over ${ID_LENGTH_LIMIT} characters long and would be truncated by the database engine.`\n    });\n  }\n}\n\nmodule.exports = {\n  RelationJoiner\n};\n","'use strict';\n\nclass TableNode {\n  constructor({ tableTree, modelClass, expression, parentNode = null, relation = null }) {\n    this.tableTree = tableTree;\n    this.modelClass = modelClass;\n    this.parentNode = parentNode;\n    this.relation = relation;\n    this.expression = expression;\n    this.childNodes = [];\n\n    this.alias = this._calculateAlias();\n    this.idGetter = this._createIdGetter();\n  }\n\n  static create(args) {\n    const node = new TableNode(args);\n\n    if (node.parentNode) {\n      node.parentNode.childNodes.push(node);\n    }\n\n    return node;\n  }\n\n  get options() {\n    return this.tableTree.options;\n  }\n\n  get relationProperty() {\n    return this.expression.node.$name;\n  }\n\n  get joinTableAlias() {\n    return this.modelClass.joinTableAlias(this.alias);\n  }\n\n  getReferenceForColumn(column) {\n    return `${this.alias}.${column}`;\n  }\n\n  getColumnAliasForColumn(column) {\n    if (this.parentNode) {\n      return `${this.alias}${this.options.separator}${column}`;\n    } else {\n      return column;\n    }\n  }\n\n  getColumnForColumnAlias(columnAlias) {\n    const lastSepIndex = columnAlias.lastIndexOf(this.options.separator);\n\n    if (lastSepIndex === -1) {\n      return columnAlias;\n    } else {\n      return columnAlias.slice(lastSepIndex + this.options.separator.length);\n    }\n  }\n\n  getIdFromFlatRow(flatRow) {\n    return this.idGetter(flatRow);\n  }\n\n  _calculateAlias() {\n    if (this.parentNode) {\n      const relationName = this.expression.node.$name;\n      const alias = this.options.aliases[relationName] || relationName;\n\n      if (this.options.minimize) {\n        return `_t${this.tableTree.createNextUid()}`;\n      } else if (this.parentNode.parentNode) {\n        return `${this.parentNode.alias}${this.options.separator}${alias}`;\n      } else {\n        return alias;\n      }\n    } else {\n      return this.tableTree.rootTableAlias;\n    }\n  }\n\n  _createIdGetter() {\n    const idColumns = this.modelClass.getIdColumnArray();\n    const columnAliases = idColumns.map(column => this.getColumnAliasForColumn(column));\n\n    if (idColumns.length === 1) {\n      return createIdGetter(columnAliases);\n    } else {\n      return createCompositeIdGetter(columnAliases);\n    }\n  }\n}\n\nfunction createIdGetter(columnAliases) {\n  const columnAlias = columnAliases[0];\n\n  return flatRow => {\n    const id = flatRow[columnAlias];\n\n    if (id === null) {\n      return null;\n    }\n\n    return `${id}`;\n  };\n}\n\nfunction createCompositeIdGetter(columnAliases) {\n  if (columnAliases.length === 2) {\n    return createTwoIdGetter(columnAliases);\n  } else {\n    return createMultiIdGetter(columnAliases);\n  }\n}\n\nfunction createTwoIdGetter(columnAliases) {\n  const columnAlias1 = columnAliases[0];\n  const columnAlias2 = columnAliases[1];\n\n  return flatRow => {\n    const id1 = flatRow[columnAlias1];\n    const id2 = flatRow[columnAlias2];\n\n    if (id1 === null || id2 === null) {\n      return null;\n    }\n\n    return `${id1},${id2}`;\n  };\n}\n\nfunction createMultiIdGetter(columnAliases) {\n  return flatRow => {\n    let idStr = '';\n\n    for (let i = 0, l = columnAliases.length; i < l; ++i) {\n      const columnAlias = columnAliases[i];\n      const id = flatRow[columnAlias];\n\n      if (id === null) {\n        return null;\n      }\n\n      idStr += id;\n\n      if (i !== l - 1) {\n        idStr += ',';\n      }\n    }\n\n    return idStr;\n  };\n}\n\nmodule.exports = {\n  TableNode\n};\n","'use strict';\n\nconst { forEachChildExpression } = require('./utils');\nconst { TableNode } = require('./TableNode');\n\nclass TableTree {\n  constructor({ expression, rootModelClass, rootTableAlias, options }) {\n    this.options = options;\n    this.rootModelClass = rootModelClass;\n    this.rootTableAlias = rootTableAlias;\n    this.nodes = [];\n    this.nodesByAlias = new Map();\n    this.uidCounter = 0;\n\n    this._createNodes({ expression, modelClass: rootModelClass });\n  }\n\n  static create(args) {\n    return new TableTree(args);\n  }\n\n  get rootNode() {\n    return this.nodes[0];\n  }\n\n  getNodeForColumnAlias(columnAlias) {\n    const lastSepIndex = columnAlias.lastIndexOf(this.options.separator);\n\n    if (lastSepIndex === -1) {\n      return this.rootNode;\n    } else {\n      const tableAlias = columnAlias.slice(0, lastSepIndex);\n      return this.nodesByAlias.get(tableAlias);\n    }\n  }\n\n  createNextUid() {\n    return this.uidCounter++;\n  }\n\n  _createNodes({ expression, modelClass }) {\n    const rootNode = this._createRootNode({ expression, modelClass });\n    this._createChildNodes({ expression, modelClass, parentNode: rootNode });\n\n    for (const node of this.nodes) {\n      this.nodesByAlias.set(node.alias, node);\n    }\n  }\n\n  _createRootNode({ expression, modelClass }) {\n    const node = TableNode.create({\n      tableTree: this,\n      modelClass,\n      expression\n    });\n\n    this.nodes.push(node);\n    return node;\n  }\n\n  _createChildNodes({ expression, modelClass, parentNode }) {\n    forEachChildExpression(expression, modelClass, (childExpr, relation) => {\n      const node = TableNode.create({\n        tableTree: this,\n        modelClass: relation.relatedModelClass,\n        expression: childExpr,\n\n        parentNode,\n        relation\n      });\n\n      this.nodes.push(node);\n\n      this._createChildNodes({\n        expression: childExpr,\n        modelClass: relation.relatedModelClass,\n        parentNode: node\n      });\n    });\n  }\n}\n\nmodule.exports = {\n  TableTree\n};\n","'use strict';\n\nconst { ValidationErrorType } = require('../../model/ValidationError');\n\nconst ID_LENGTH_LIMIT = 63;\nconst RELATION_RECURSION_LIMIT = 64;\n\n// Given a relation expression, goes through all first level children.\nfunction forEachChildExpression(expr, modelClass, callback) {\n  if (expr.node.$allRecursive || expr.maxRecursionDepth > RELATION_RECURSION_LIMIT) {\n    throw modelClass.createValidationError({\n      type: ValidationErrorType.RelationExpression,\n      message: `recursion depth of eager expression ${expr.toString()} too big for JoinEagerAlgorithm`\n    });\n  }\n\n  expr.forEachChildExpression(modelClass, callback);\n}\n\nmodule.exports = {\n  ID_LENGTH_LIMIT,\n  RELATION_RECURSION_LIMIT,\n\n  forEachChildExpression\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\n// Operation that simply delegates all calls to the operation passed\n// to to the constructor in `opt.delegate`.\nclass DelegateOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.delegate = opt.delegate;\n  }\n\n  is(OperationClass) {\n    return super.is(OperationClass) || this.delegate.is(OperationClass);\n  }\n\n  onAdd(builder, args) {\n    return this.delegate.onAdd(builder, args);\n  }\n\n  onBefore1(builder, result) {\n    return this.delegate.onBefore1(builder, result);\n  }\n\n  hasOnBefore1() {\n    return this.onBefore1 !== DelegateOperation.prototype.onBefore1 || this.delegate.hasOnBefore1();\n  }\n\n  onBefore2(builder, result) {\n    return this.delegate.onBefore2(builder, result);\n  }\n\n  hasOnBefore2() {\n    return this.onBefore2 !== DelegateOperation.prototype.onBefore2 || this.delegate.hasOnBefore2();\n  }\n\n  onBefore3(builder, result) {\n    return this.delegate.onBefore3(builder, result);\n  }\n\n  hasOnBefore3() {\n    return this.onBefore3 !== DelegateOperation.prototype.onBefore3 || this.delegate.hasOnBefore3();\n  }\n\n  onBuild(builder) {\n    return this.delegate.onBuild(builder);\n  }\n\n  hasOnBuild() {\n    return this.onBuild !== DelegateOperation.prototype.onBuild || this.delegate.hasOnBuild();\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    return this.delegate.onBuildKnex(knexBuilder, builder);\n  }\n\n  hasOnBuildKnex() {\n    return (\n      this.onBuildKnex !== DelegateOperation.prototype.onBuildKnex || this.delegate.hasOnBuildKnex()\n    );\n  }\n\n  onRawResult(builder, result) {\n    return this.delegate.onRawResult(builder, result);\n  }\n\n  hasOnRawResult() {\n    return (\n      this.onRawResult !== DelegateOperation.prototype.onRawResult || this.delegate.hasOnRawResult()\n    );\n  }\n\n  onAfter1(builder, result) {\n    return this.delegate.onAfter1(builder, result);\n  }\n\n  hasOnAfter1() {\n    return this.onAfter1 !== DelegateOperation.prototype.onAfter1 || this.delegate.hasOnAfter1();\n  }\n\n  onAfter2(builder, result) {\n    return this.delegate.onAfter2(builder, result);\n  }\n\n  hasOnAfter2() {\n    return this.onAfter2 !== DelegateOperation.prototype.onAfter2 || this.delegate.hasOnAfter2();\n  }\n\n  onAfter3(builder, result) {\n    return this.delegate.onAfter3(builder, result);\n  }\n\n  hasOnAfter3() {\n    return this.onAfter3 !== DelegateOperation.prototype.onAfter3 || this.delegate.hasOnAfter3();\n  }\n\n  queryExecutor(builder) {\n    return this.delegate.queryExecutor(builder);\n  }\n\n  hasQueryExecutor() {\n    return (\n      this.queryExecutor !== DelegateOperation.prototype.queryExecutor ||\n      this.delegate.hasQueryExecutor()\n    );\n  }\n\n  onError(builder, error) {\n    return this.delegate.onError(builder, error);\n  }\n\n  hasOnError() {\n    return this.onError !== DelegateOperation.prototype.onError || this.delegate.hasOnError();\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.delegate = this.delegate && this.delegate.clone();\n    return clone;\n  }\n}\n\nmodule.exports = {\n  DelegateOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { after, afterReturn } = require('../../utils/promiseUtils');\nconst { StaticHookArguments } = require('../StaticHookArguments');\n\nclass DeleteOperation extends QueryBuilderOperation {\n  onBefore2(builder, result) {\n    const maybePromise = callBeforeDelete(builder);\n    return afterReturn(maybePromise, result);\n  }\n\n  onBuildKnex(knexBuilder) {\n    knexBuilder.delete();\n  }\n\n  onAfter2(builder, result) {\n    return callAfterDelete(builder, result);\n  }\n}\n\nfunction callBeforeDelete(builder) {\n  return callStaticBeforeDelete(builder);\n}\n\nfunction callStaticBeforeDelete(builder) {\n  const args = StaticHookArguments.create({ builder });\n  return builder.modelClass().beforeDelete(args);\n}\n\nfunction callAfterDelete(builder, result) {\n  return callStaticAfterDelete(builder, result);\n}\n\nfunction callStaticAfterDelete(builder, result) {\n  const args = StaticHookArguments.create({ builder, result });\n  const maybePromise = builder.modelClass().afterDelete(args);\n\n  return after(maybePromise, maybeResult => {\n    if (maybeResult === undefined) {\n      return result;\n    } else {\n      return maybeResult;\n    }\n  });\n}\n\nmodule.exports = {\n  DeleteOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass FindByIdOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.id = null;\n  }\n\n  onAdd(builder, args) {\n    this.id = args[0];\n    return super.onAdd(builder, args);\n  }\n\n  onBuild(builder) {\n    builder.whereComposite(builder.fullIdColumn(), this.id);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.id = this.id;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  FindByIdOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass FindByIdsOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.ids = null;\n  }\n\n  onAdd(builder, args) {\n    this.ids = args[0];\n    return super.onAdd(builder, args);\n  }\n\n  onBuild(builder) {\n    builder.whereInComposite(builder.fullIdColumn(), this.ids);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.ids = this.ids;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  FindByIdsOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { StaticHookArguments } = require('../StaticHookArguments');\nconst { isPromise, after, afterReturn } = require('../../utils/promiseUtils');\nconst { isObject } = require('../../utils/objectUtils');\n\nclass FindOperation extends QueryBuilderOperation {\n  onBefore2(builder, result) {\n    return afterReturn(callStaticBeforeFind(builder), result);\n  }\n\n  onAfter3(builder, results) {\n    const opt = builder.findOptions();\n\n    if (opt.dontCallFindHooks) {\n      return results;\n    } else {\n      return callAfterFind(builder, results);\n    }\n  }\n}\n\nfunction callStaticBeforeFind(builder) {\n  const args = StaticHookArguments.create({ builder });\n  return builder.modelClass().beforeFind(args);\n}\n\nfunction callAfterFind(builder, result) {\n  const opt = builder.findOptions();\n  const maybePromise = callInstanceAfterFind(builder.context(), result, opt.callAfterFindDeeply);\n\n  return after(maybePromise, () => callStaticAfterFind(builder, result));\n}\n\nfunction callStaticAfterFind(builder, result) {\n  const args = StaticHookArguments.create({ builder, result });\n  const maybePromise = builder.modelClass().afterFind(args);\n\n  return after(maybePromise, maybeResult => {\n    if (maybeResult === undefined) {\n      return result;\n    } else {\n      return maybeResult;\n    }\n  });\n}\n\nfunction callInstanceAfterFind(ctx, results, deep) {\n  if (Array.isArray(results)) {\n    if (results.length === 1) {\n      return callAfterFindForOne(ctx, results[0], results, deep);\n    } else {\n      return callAfterFindArray(ctx, results, deep);\n    }\n  } else {\n    return callAfterFindForOne(ctx, results, results, deep);\n  }\n}\n\nfunction callAfterFindArray(ctx, results, deep) {\n  if (results.length === 0 || !isObject(results[0])) {\n    return results;\n  }\n\n  const mapped = new Array(results.length);\n  let containsPromise = false;\n\n  for (let i = 0, l = results.length; i < l; ++i) {\n    mapped[i] = callAfterFindForOne(ctx, results[i], results[i], deep);\n\n    if (isPromise(mapped[i])) {\n      containsPromise = true;\n    }\n  }\n\n  if (containsPromise) {\n    return Promise.all(mapped);\n  } else {\n    return mapped;\n  }\n}\n\nfunction callAfterFindForOne(ctx, model, result, deep) {\n  if (!isObject(model) || !model.$isObjectionModel) {\n    return result;\n  }\n\n  if (deep) {\n    const results = [];\n    const containsPromise = callAfterFindForRelations(ctx, model, results);\n\n    if (containsPromise) {\n      return Promise.all(results).then(() => {\n        return doCallAfterFind(ctx, model, result);\n      });\n    } else {\n      return doCallAfterFind(ctx, model, result);\n    }\n  } else {\n    return doCallAfterFind(ctx, model, result);\n  }\n}\n\nfunction callAfterFindForRelations(ctx, model, results) {\n  const keys = Object.keys(model);\n  let containsPromise = false;\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n    const value = model[key];\n\n    if (isRelation(value)) {\n      const maybePromise = callInstanceAfterFind(ctx, value, true);\n\n      if (isPromise(maybePromise)) {\n        containsPromise = true;\n      }\n\n      results.push(maybePromise);\n    }\n  }\n\n  return containsPromise;\n}\n\nfunction isRelation(value) {\n  return (\n    (isObject(value) && value.$isObjectionModel) ||\n    (isNonEmptyObjectArray(value) && value[0].$isObjectionModel)\n  );\n}\n\nfunction isNonEmptyObjectArray(value) {\n  return Array.isArray(value) && value.length > 0 && isObject(value[0]);\n}\n\nfunction doCallAfterFind(ctx, model, result) {\n  const afterFind = getAfterFindHook(model);\n\n  if (afterFind !== null) {\n    const maybePromise = afterFind.call(model, ctx);\n\n    if (isPromise(maybePromise)) {\n      return maybePromise.then(() => result);\n    } else {\n      return result;\n    }\n  } else {\n    return result;\n  }\n}\n\nfunction getAfterFindHook(model) {\n  if (model.$afterFind !== model.$objectionModelClass.prototype.$afterFind) {\n    return model.$afterFind;\n  } else if (model.$afterGet !== model.$objectionModelClass.prototype.$afterGet) {\n    return model.$afterGet;\n  } else {\n    return null;\n  }\n}\n\nmodule.exports = {\n  FindOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass FirstOperation extends QueryBuilderOperation {\n  onBuildKnex(knexBuilder, builder) {\n    const modelClass = builder.modelClass();\n\n    if (builder.isFind() && modelClass.useLimitInFirst) {\n      knexBuilder.limit(1);\n    }\n  }\n\n  onAfter3(_, result) {\n    if (Array.isArray(result)) {\n      return result[0];\n    } else {\n      return result;\n    }\n  }\n}\n\nmodule.exports = {\n  FirstOperation\n};\n","'use strict';\n\nconst { ObjectionToKnexConvertingOperation } = require('./ObjectionToKnexConvertingOperation');\nconst { isPlainObject, isString } = require('../../utils/objectUtils');\n\nconst ALIAS_REGEX = /\\s+as\\s+/i;\n\n// FromOperation corresponds to a `.from(args)` call. The call is delegated to\n// knex, but we first try to parse the arguments so that we can determine which\n// tables have been mentioned in a query's from clause. We only parse string\n// references and not `raw` or `ref` etc. references at this point thouhg.\nclass FromOperation extends ObjectionToKnexConvertingOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.table = null;\n    this.alias = null;\n  }\n\n  onAdd(builder, args) {\n    const ret = super.onAdd(builder, args);\n    const parsed = parseTableAndAlias(this.args[0], builder);\n\n    if (parsed.table) {\n      builder.tableName(parsed.table);\n      this.table = parsed.table;\n    }\n\n    if (parsed.alias) {\n      builder.aliasFor(builder.modelClass().getTableName(), parsed.alias);\n      this.alias = parsed.alias;\n    }\n\n    return ret;\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    // Simply call knex's from method with the converted arguments.\n    knexBuilder.from.apply(knexBuilder, this.getKnexArgs(builder));\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.table = this.table;\n    clone.alias = this.alias;\n\n    return clone;\n  }\n}\n\nfunction parseTableAndAlias(arg, builder) {\n  if (isString(arg)) {\n    return parseTableAndAliasFromString(arg);\n  } else if (isPlainObject(arg)) {\n    return parseTableAndAliasFromObject(arg, builder);\n  } else {\n    // Could not parse table and alias from the arguments.\n    return {\n      table: null,\n      alias: null\n    };\n  }\n}\n\nfunction parseTableAndAliasFromString(arg) {\n  if (ALIAS_REGEX.test(arg)) {\n    const parts = arg.split(ALIAS_REGEX);\n\n    return {\n      table: parts[0].trim(),\n      alias: parts[1].trim()\n    };\n  } else {\n    return {\n      table: arg.trim(),\n      alias: null\n    };\n  }\n}\n\nfunction parseTableAndAliasFromObject(arg, builder) {\n  for (const alias of Object.keys(arg)) {\n    const table = arg[alias].trim();\n\n    if (table === builder.modelClass().getTableName()) {\n      return {\n        alias,\n        table\n      };\n    }\n  }\n\n  throw new Error(\n    `one of the tables in ${JSON.stringify(arg)} must be the query's model class's table.`\n  );\n}\n\nmodule.exports = {\n  FromOperation\n};\n","'use strict';\n\nconst { InsertOperation } = require('./InsertOperation');\nconst { DelegateOperation } = require('./DelegateOperation');\nconst { keyByProps } = require('../../model/modelUtils');\nconst { asArray } = require('../../utils/objectUtils');\nconst { after } = require('../../utils/promiseUtils');\n\nclass InsertAndFetchOperation extends DelegateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    if (!this.delegate.is(InsertOperation)) {\n      throw new Error('Invalid delegate');\n    }\n  }\n\n  onAfter2(builder, inserted) {\n    const modelClass = builder.modelClass();\n    const maybePromise = super.onAfter2(builder, inserted);\n\n    return after(maybePromise, insertedModels => {\n      const insertedModelArray = asArray(insertedModels);\n      const idProps = modelClass.getIdPropertyArray();\n      const ids = insertedModelArray.map(model => model.$id());\n\n      return modelClass\n        .query()\n        .childQueryOf(builder)\n        .findByIds(ids)\n        .castTo(builder.resultModelClass())\n        .then(fetchedModels => {\n          const modelsById = keyByProps(fetchedModels, idProps);\n\n          // Instead of returning the freshly fetched models, update the input\n          // models with the fresh values.\n          insertedModelArray.forEach(insertedModel => {\n            insertedModel.$set(modelsById.get(insertedModel.$propKey(idProps)));\n          });\n\n          return insertedModels;\n        });\n    });\n  }\n}\n\nmodule.exports = {\n  InsertAndFetchOperation\n};\n","'use strict';\n\nconst { DelegateOperation } = require('./DelegateOperation');\nconst { InsertGraphOperation } = require('./InsertGraphOperation');\nconst { RelationExpression } = require('../RelationExpression');\n\nclass InsertGraphAndFetchOperation extends DelegateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    if (!this.delegate.is(InsertGraphOperation)) {\n      throw new Error('Invalid delegate');\n    }\n  }\n\n  get models() {\n    return this.delegate.models;\n  }\n\n  get isArray() {\n    return this.delegate.isArray;\n  }\n\n  onAfter2(builder) {\n    if (this.models.length === 0) {\n      return this.isArray ? [] : null;\n    }\n\n    const eager = RelationExpression.fromModelGraph(this.models);\n    const modelClass = this.models[0].constructor;\n    const ids = this.models.map(model => model.$id());\n\n    return modelClass\n      .query()\n      .childQueryOf(builder)\n      .findByIds(ids)\n      .eager(eager)\n      .then(models => {\n        return this.isArray ? models : models[0] || null;\n      });\n  }\n}\n\nmodule.exports = {\n  InsertGraphAndFetchOperation\n};\n","'use strict';\n\nconst { DelegateOperation } = require('./DelegateOperation');\nconst { InsertOperation } = require('./InsertOperation');\nconst { GraphUpsert } = require('../graph/GraphUpsert');\n\nclass InsertGraphOperation extends DelegateOperation {\n  constructor(name, opt = null) {\n    super(name, opt);\n\n    if (!this.delegate.is(InsertOperation)) {\n      throw new Error('Invalid delegate');\n    }\n\n    Object.assign(this.delegate.modelOptions, GraphUpsert.modelOptions);\n    this.upsertOptions = opt.opt || {};\n    this.upsert = null;\n  }\n\n  get models() {\n    return this.delegate.models;\n  }\n\n  get isArray() {\n    return this.delegate.isArray;\n  }\n\n  onAdd(builder, args) {\n    const retVal = super.onAdd(builder, args);\n\n    this.upsert = new GraphUpsert({\n      objects: this.models,\n      rootModelClass: builder.modelClass(),\n\n      upsertOptions: Object.assign({}, this.upsertOptions, {\n        noUpdate: true,\n        noDelete: true,\n        noUnrelate: true,\n        insertMissing: true\n      })\n    });\n\n    // We resolve this query here and will not execute it. This is because the root\n    // value may depend on other models in the graph and cannot be inserted first.\n    builder.resolve([]);\n\n    return retVal;\n  }\n\n  onBefore1() {\n    // Do nothing.\n  }\n\n  onBefore2() {\n    // Do nothing. We override this with empty implementation so that\n    // the $beforeInsert() hooks are not called twice for the root models.\n  }\n\n  onBefore3() {\n    // Do nothing.\n  }\n\n  onBuild() {\n    // Do nothing.\n  }\n\n  onBuildKnex() {\n    // Do nothing.\n  }\n\n  // We overrode all other hooks but this one and do all the work in here.\n  // This is a bit hacky.\n  onAfter1(builder, ...restArgs) {\n    return this.upsert.run(builder).then(() => super.onAfter1(builder, ...restArgs));\n  }\n\n  onAfter2() {\n    // We override this with empty implementation so that the $afterInsert() hooks\n    // are not called twice for the root models.\n    return this.isArray ? this.models : this.models[0] || null;\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.upsert = this.upsert;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  InsertGraphOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { StaticHookArguments } = require('../StaticHookArguments');\nconst { after, mapAfterAllReturn, afterReturn } = require('../../utils/promiseUtils');\nconst { isPostgres, isSqlite, isMySql } = require('../../utils/knexUtils');\nconst { isObject } = require('../../utils/objectUtils');\n\n// Base class for all insert operations.\nclass InsertOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.models = null;\n    this.isArray = false;\n    this.modelOptions = Object.assign({}, this.opt.modelOptions || {});\n  }\n\n  onAdd(builder, args) {\n    const json = args[0];\n    const modelClass = builder.modelClass();\n\n    this.isArray = Array.isArray(json);\n    this.models = modelClass.ensureModelArray(json, this.modelOptions);\n\n    return true;\n  }\n\n  onBefore2(builder, result) {\n    if (this.models.length > 1 && !isPostgres(builder.knex())) {\n      throw new Error('batch insert only works with Postgresql');\n    } else {\n      const maybePromise = callBeforeInsert(builder, this.models);\n      return afterReturn(maybePromise, result);\n    }\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    if (!isSqlite(builder.knex()) && !isMySql(builder.knex()) && !builder.has(/returning/)) {\n      // If the user hasn't specified a `returning` clause, we make sure\n      // that at least the identifier is returned.\n      knexBuilder.returning(builder.modelClass().getIdColumn());\n    }\n\n    knexBuilder.insert(this.models.map(model => model.$toDatabaseJson(builder)));\n  }\n\n  onAfter1(_, ret) {\n    if (!Array.isArray(ret) || !ret.length || ret === this.models) {\n      // Early exit if there is nothing to do.\n      return this.models;\n    }\n\n    if (isObject(ret[0])) {\n      // If the user specified a `returning` clause the result may be an array of objects.\n      // Merge all values of the objects to our models.\n      for (let i = 0, l = this.models.length; i < l; ++i) {\n        this.models[i].$set(ret[i]);\n      }\n    } else {\n      // If the return value is not an array of objects, we assume it is an array of identifiers.\n      for (let i = 0, l = this.models.length; i < l; ++i) {\n        const model = this.models[i];\n\n        // Don't set the id if the model already has one. MySQL and Sqlite don't return the correct\n        // primary key value if the id is not generated in db, but given explicitly.\n        if (!model.$id()) {\n          model.$id(ret[i]);\n        }\n      }\n    }\n\n    return this.models;\n  }\n\n  onAfter2(builder, models) {\n    const result = this.isArray ? models : models[0] || null;\n    return callAfterInsert(builder, this.models, result);\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.models = this.models;\n    clone.isArray = this.isArray;\n\n    return clone;\n  }\n}\n\nfunction callBeforeInsert(builder, models) {\n  const maybePromise = callInstanceBeforeInsert(builder, models);\n  return after(maybePromise, () => callStaticBeforeInsert(builder));\n}\n\nfunction callInstanceBeforeInsert(builder, models) {\n  return mapAfterAllReturn(models, model => model.$beforeInsert(builder.context()), models);\n}\n\nfunction callStaticBeforeInsert(builder) {\n  const args = StaticHookArguments.create({ builder });\n  return builder.modelClass().beforeInsert(args);\n}\n\nfunction callAfterInsert(builder, models, result) {\n  const maybePromise = callInstanceAfterInsert(builder, models);\n  return after(maybePromise, () => callStaticAfterInsert(builder, result));\n}\n\nfunction callInstanceAfterInsert(builder, models) {\n  return mapAfterAllReturn(models, model => model.$afterInsert(builder.context()), models);\n}\n\nfunction callStaticAfterInsert(builder, result) {\n  const args = StaticHookArguments.create({ builder, result });\n  const maybePromise = builder.modelClass().afterInsert(args);\n\n  return after(maybePromise, maybeResult => {\n    if (maybeResult === undefined) {\n      return result;\n    } else {\n      return maybeResult;\n    }\n  });\n}\n\nmodule.exports = {\n  InsertOperation\n};\n","'use strict';\n\nconst { DeleteOperation } = require('./DeleteOperation');\nconst { assertHasId } = require('../../utils/assert');\nconst { afterReturn, after } = require('../../utils/promiseUtils');\n\nclass InstanceDeleteOperation extends DeleteOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.instance = opt.instance;\n  }\n\n  onBefore2(builder, result) {\n    let maybePromise = this.instance.$beforeDelete(builder.context());\n    maybePromise = after(maybePromise, () => super.onBefore2(builder, result));\n    return afterReturn(maybePromise, result);\n  }\n\n  onBuild(builder) {\n    super.onBuild(builder);\n\n    assertHasId(this.instance);\n    builder.findById(this.instance.$id());\n  }\n\n  onAfter2(builder, result) {\n    // The result may be an object if `returning` was used.\n    if (Array.isArray(result)) {\n      result = result[0];\n    }\n\n    const maybePromise = this.instance.$afterDelete(builder.context());\n    return after(maybePromise, () => super.onAfter2(builder, result));\n  }\n}\n\nmodule.exports = {\n  InstanceDeleteOperation\n};\n","'use strict';\n\nconst { FindOperation } = require('./FindOperation');\nconst { assertHasId } = require('../../utils/assert');\n\nclass InstanceFindOperation extends FindOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.instance = opt.instance;\n  }\n\n  onBuild(builder) {\n    assertHasId(this.instance);\n    builder.findById(this.instance.$id());\n  }\n}\n\nmodule.exports = {\n  InstanceFindOperation\n};\n","'use strict';\n\nconst { InsertOperation } = require('./InsertOperation');\n\nclass InstanceInsertOperation extends InsertOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.instance = opt.instance;\n  }\n\n  onAdd(builder, args) {\n    if (!args || args.length === 0) {\n      args = [this.instance];\n    } else {\n      args[0] = this.instance;\n    }\n\n    return super.onAdd(builder, args);\n  }\n}\n\nmodule.exports = {\n  InstanceInsertOperation\n};\n","'use strict';\n\nconst { UpdateOperation } = require('./UpdateOperation');\nconst { assertHasId } = require('../../utils/assert');\nconst { isObject } = require('../../utils/objectUtils');\nconst { after } = require('../../utils/promiseUtils');\n\nclass InstanceUpdateOperation extends UpdateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.instance = opt.instance;\n    this.modelOptions.old = opt.instance;\n  }\n\n  onAdd(builder, args) {\n    const retVal = super.onAdd(builder, args);\n\n    if (!this.model) {\n      this.model = this.instance;\n    }\n\n    return retVal;\n  }\n\n  onBuild(builder) {\n    super.onBuild(builder);\n\n    assertHasId(this.instance);\n    builder.findById(this.instance.$id());\n  }\n\n  onAfter2(builder, result) {\n    // The result may be an object if `returning` was used.\n    if (Array.isArray(result)) {\n      result = result[0];\n    }\n\n    const maybePromise = super.onAfter2(builder, result);\n\n    return after(maybePromise, result => {\n      this.instance.$set(this.model);\n\n      if (isObject(result)) {\n        this.instance.$set(result);\n      }\n\n      return result;\n    });\n  }\n}\n\nmodule.exports = {\n  InstanceUpdateOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { RelationExpression } = require('../RelationExpression');\nconst { RelationJoiner } = require('../join/RelationJoiner');\nconst { isString } = require('../../utils/objectUtils');\n\nclass JoinRelationOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.calls = [];\n  }\n\n  get joinOperation() {\n    return this.opt.joinOperation;\n  }\n\n  addCall(call) {\n    this.calls.push(call);\n  }\n\n  onBuild(builder) {\n    const modelClass = builder.modelClass();\n    const joinOperation = this.joinOperation;\n    let mergedExpr = RelationExpression.create();\n\n    for (const call of this.calls) {\n      const expr = RelationExpression.create(call.expression).toPojo();\n      const childNames = expr.$childNames;\n      const options = call.options || {};\n\n      if (childNames.length === 1) {\n        applyAlias(expr, modelClass, builder, options);\n      }\n\n      if (options.aliases) {\n        applyAliases(expr, modelClass, options);\n      }\n\n      mergedExpr = mergedExpr.merge(expr);\n    }\n\n    const joiner = new RelationJoiner({\n      modelClass\n    });\n\n    joiner.setOptions({ joinOperation });\n    joiner.setExpression(mergedExpr);\n    joiner.build(builder, false);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.calls = this.calls.slice();\n    return clone;\n  }\n}\n\nfunction applyAlias(expr, modelClass, builder, options) {\n  const childNames = expr.$childNames;\n  const childName = childNames[0];\n  const childExpr = expr[childName];\n  const relation = modelClass.getRelation(childExpr.$relation);\n\n  let alias = childName;\n\n  if (options.alias === false) {\n    alias = builder.tableRefFor(relation.relatedModelClass.getTableName());\n  } else if (isString(options.alias)) {\n    alias = options.alias;\n  }\n\n  if (childName !== alias) {\n    renameRelationExpressionNode(expr, childName, alias);\n  }\n}\n\nfunction applyAliases(expr, modelClass, options) {\n  for (const childName of expr.$childNames) {\n    const childExpr = expr[childName];\n    const relation = modelClass.getRelation(childExpr.$relation);\n    const alias = options.aliases[childExpr.$relation];\n\n    if (alias && alias !== childName) {\n      renameRelationExpressionNode(expr, childName, alias);\n    }\n\n    applyAliases(childExpr, relation.relatedModelClass, options);\n  }\n}\n\nfunction renameRelationExpressionNode(expr, oldName, newName) {\n  const childExpr = expr[oldName];\n  delete expr[oldName];\n  expr[newName] = childExpr;\n  childExpr.$name = newName;\n  expr.$childNames = expr.$childNames.map(it => (it === oldName ? newName : it));\n}\n\nmodule.exports = {\n  JoinRelationOperation\n};\n","'use strict';\n\nconst { ObjectionToKnexConvertingOperation } = require('./ObjectionToKnexConvertingOperation');\n\n// An operation that simply calls the equivalent knex method.\nclass KnexOperation extends ObjectionToKnexConvertingOperation {\n  onBuildKnex(knexBuilder, builder) {\n    knexBuilder[this.name].apply(knexBuilder, this.getKnexArgs(builder));\n  }\n}\n\nmodule.exports = {\n  KnexOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { isPlainObject, isObject, isFunction, once } = require('../../utils/objectUtils');\nconst { isKnexQueryBuilder, isKnexJoinBuilder } = require('../../utils/knexUtils');\nconst getJoinBuilder = once(() => require('../JoinBuilder').JoinBuilder);\n\n// An abstract operation base class that converts all arguments from objection types\n// to knex types. For example objection query builders are converted into knex query\n// builders and objection RawBuilder instances are converted into knex Raw instances.\nclass ObjectionToKnexConvertingOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.args = null;\n  }\n\n  getKnexArgs(builder) {\n    return convertArgs(this.name, builder, this.args);\n  }\n\n  onAdd(builder, args) {\n    this.args = Array.from(args);\n    return shouldBeAdded(this.name, builder, this.args);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.args = this.args;\n    return clone;\n  }\n}\n\nfunction shouldBeAdded(opName, builder, args) {\n  const skipUndefined = builder.internalOptions().skipUndefined;\n\n  for (let i = 0, l = args.length; i < l; ++i) {\n    const arg = args[i];\n\n    if (isUndefined(arg)) {\n      if (skipUndefined) {\n        return false;\n      } else {\n        throw new Error(\n          `undefined passed as argument #${i} for '${opName}' operation. Call skipUndefined() method to ignore the undefined values.`\n        );\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction convertArgs(opName, builder, args) {\n  const skipUndefined = builder.internalOptions().skipUndefined;\n\n  return args.map((arg, i) => {\n    if (hasToKnexRawMethod(arg)) {\n      return convertToKnexRaw(arg, builder);\n    } else if (isObjectionQueryBuilderBase(arg)) {\n      return convertQueryBuilderBase(arg, builder);\n    } else if (isArray(arg)) {\n      return convertArray(arg, builder, i, opName, skipUndefined);\n    } else if (isFunction(arg)) {\n      return convertFunction(arg, builder);\n    } else if (isModel(arg)) {\n      return convertModel(arg);\n    } else if (isPlainObject(arg)) {\n      return convertPlainObject(arg, builder, i, opName, skipUndefined);\n    } else {\n      return arg;\n    }\n  });\n}\n\nfunction isUndefined(item) {\n  return item === undefined;\n}\n\nfunction hasToKnexRawMethod(item) {\n  return isObject(item) && isFunction(item.toKnexRaw);\n}\n\nfunction convertToKnexRaw(item, builder) {\n  return item.toKnexRaw(builder);\n}\n\nfunction isObjectionQueryBuilderBase(item) {\n  return isObject(item) && item.isObjectionQueryBuilderBase === true;\n}\n\nfunction convertQueryBuilderBase(item, builder) {\n  return item.subqueryOf(builder).toKnexQuery();\n}\n\nfunction isArray(item) {\n  return Array.isArray(item);\n}\n\nfunction convertArray(arr, builder, i, opName, skipUndefined) {\n  return arr.map(item => {\n    if (item === undefined) {\n      if (!skipUndefined) {\n        throw new Error(\n          `undefined passed as an item in argument #${i} for '${opName}' operation. Call skipUndefined() method to ignore the undefined values.`\n        );\n      }\n    } else if (hasToKnexRawMethod(item)) {\n      return convertToKnexRaw(item, builder);\n    } else if (isObjectionQueryBuilderBase(item)) {\n      return convertQueryBuilderBase(item);\n    } else {\n      return item;\n    }\n  });\n}\n\nfunction convertFunction(func, builder) {\n  return function convertedKnexArgumentFunction(...args) {\n    if (isKnexQueryBuilder(this)) {\n      convertQueryBuilderFunction(this, func, builder);\n    } else if (isKnexJoinBuilder(this)) {\n      convertJoinBuilderFunction(this, func, builder);\n    } else {\n      return func.apply(this, args);\n    }\n  };\n}\n\nfunction convertQueryBuilderFunction(knexQueryBuilder, func, builder) {\n  const convertedQueryBuilder = builder.constructor.forClass(builder.modelClass());\n\n  convertedQueryBuilder.subqueryOf(builder).isPartial(true);\n  func.call(convertedQueryBuilder, convertedQueryBuilder);\n\n  convertedQueryBuilder.toKnexQuery(knexQueryBuilder);\n}\n\nfunction convertJoinBuilderFunction(knexJoinBuilder, func, builder) {\n  const JoinBuilder = getJoinBuilder();\n  const joinClauseBuilder = JoinBuilder.forClass(builder.modelClass());\n\n  joinClauseBuilder.subqueryOf(builder).isPartial(true);\n  func.call(joinClauseBuilder, joinClauseBuilder);\n\n  joinClauseBuilder.toKnexQuery(knexJoinBuilder);\n}\n\nfunction isModel(item) {\n  return isObject(item) && item.$isObjectionModel;\n}\n\nfunction convertModel(model) {\n  return model.$toDatabaseJson();\n}\n\nfunction convertPlainObject(obj, builder, i, opName, skipUndefined) {\n  return Object.keys(obj).reduce((out, key) => {\n    const item = obj[key];\n\n    if (item === undefined) {\n      if (!skipUndefined) {\n        throw new Error(\n          `undefined passed as a property in argument #${i} for '${opName}' operation. Call skipUndefined() method to ignore the undefined values.`\n        );\n      }\n    } else if (hasToKnexRawMethod(item)) {\n      out[key] = convertToKnexRaw(item, builder);\n    } else if (isObjectionQueryBuilderBase(item)) {\n      out[key] = convertQueryBuilderBase(item, builder);\n    } else {\n      out[key] = item;\n    }\n\n    return out;\n  }, {});\n}\n\nmodule.exports = {\n  ObjectionToKnexConvertingOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass OnBuildKnexOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.func = null;\n  }\n\n  onAdd(_, args) {\n    this.func = args[0];\n    return true;\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    return this.func.call(knexBuilder, knexBuilder, builder);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.func = this.func;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  OnBuildKnexOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass OnBuildOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.func = null;\n  }\n\n  onAdd(_, args) {\n    this.func = args[0];\n    return true;\n  }\n\n  onBuild(builder) {\n    return this.func.call(builder, builder);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.func = this.func;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  OnBuildOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass OnErrorOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.func = null;\n  }\n\n  onAdd(_, args) {\n    this.func = args[0];\n    return true;\n  }\n\n  onError(builder, error) {\n    return this.func.call(builder, error, builder);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.func = this.func;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  OnErrorOperation\n};\n","'use strict';\n\nconst hookNameToHasMethodName = {\n  onAdd: 'hasOnAdd',\n  onBefore1: 'hasOnBefore1',\n  onBefore2: 'hasOnBefore2',\n  onBefore3: 'hasOnBefore3',\n  onBuild: 'hasOnBuild',\n  onBuildKnex: 'hasOnBuildKnex',\n  onRawResult: 'hasOnRawResult',\n  queryExecutor: 'hasQueryExecutor',\n  onAfter1: 'hasOnAfter1',\n  onAfter2: 'hasOnAfter2',\n  onAfter3: 'hasOnAfter3',\n  onError: 'hasOnError'\n};\n\n// An abstract base class for all query builder operations. QueryBuilderOperations almost always\n// correspond to a single query builder method call. For example SelectOperation could be added when\n// a `select` method is called.\n//\n// QueryBuilderOperation is just a bunch of query execution lifecycle hooks that subclasses\n// can (but don't have to) implement.\n//\n// Basically a query builder is nothing but an array of QueryBuilderOperations. When the query is\n// executed the hooks are called in the order explained below. The hooks are called so that a\n// certain hook is called for _all_ operations before the next hook is called. For example if\n// a builder has 5 operations, onBefore1 hook is called for each of them (and their results are awaited)\n// before onBefore2 hook is called for any of the operations.\nclass QueryBuilderOperation {\n  constructor(name = null, opt = {}) {\n    this.name = name;\n    this.opt = opt;\n\n    // From which hook was this operation added as a child\n    // operation.\n    this.adderHookName = null;\n\n    // The parent operation that added this operation.\n    this.parentOperation = null;\n\n    // Operations this operation added in any of its hooks.\n    this.childOperations = [];\n  }\n\n  is(OperationClass) {\n    return this instanceof OperationClass;\n  }\n\n  hasHook(hookName) {\n    return this[hookNameToHasMethodName[hookName]]();\n  }\n\n  // This is called immediately when a query builder method is called.\n  //\n  // This method must be synchronous.\n  // This method should never call any methods that add operations to the builder.\n  onAdd(builder, args) {\n    return true;\n  }\n  hasOnAdd() {\n    return true;\n  }\n\n  // This is called as the first thing when the query is executed but before\n  // the actual database operation (knex query) is executed.\n  //\n  // This method can be asynchronous.\n  // You may call methods that add operations to to the builder.\n  onBefore1(builder, result) {}\n  hasOnBefore1() {\n    return this.onBefore1 !== QueryBuilderOperation.prototype.onBefore1;\n  }\n\n  // This is called as the second thing when the query is executed but before\n  // the actual database operation (knex query) is executed.\n  //\n  // This method can be asynchronous.\n  // You may call methods that add operations to to the builder.\n  onBefore2(builder, result) {}\n  hasOnBefore2() {\n    return this.onBefore2 !== QueryBuilderOperation.prototype.onBefore2;\n  }\n\n  // This is called as the third thing when the query is executed but before\n  // the actual database operation (knex query) is executed.\n  //\n  // This method can be asynchronous.\n  // You may call methods that add operations to to the builder.\n  onBefore3(builder, result) {}\n  hasOnBefore3() {\n    return this.onBefore3 !== QueryBuilderOperation.prototype.onBefore3;\n  }\n\n  // This is called as the last thing when the query is executed but before\n  // the actual database operation (knex query) is executed. If your operation\n  // needs to call other query building operations (methods that add QueryBuilderOperations)\n  // this is the best and last place to do it.\n  //\n  // This method must be synchronous.\n  // You may call methods that add operations to to the builder.\n  onBuild(builder) {}\n  hasOnBuild() {\n    return this.onBuild !== QueryBuilderOperation.prototype.onBuild;\n  }\n\n  // This is called when the knex query is built. Here you should only call knex\n  // methods. You may call getters and other immutable methods of the `builder`\n  // but you should never call methods that add QueryBuilderOperations.\n  //\n  // This method must be synchronous.\n  // This method should never call any methods that add operations to the builder.\n  onBuildKnex(knexBuilder, builder) {}\n  hasOnBuildKnex() {\n    return this.onBuildKnex !== QueryBuilderOperation.prototype.onBuildKnex;\n  }\n\n  // The raw knex result is passed to this method right after the database query\n  // has finished. This method may modify it and return the modified rows. The\n  // rows are automatically converted to models (if possible) after this hook\n  // is called.\n  //\n  // This method can be asynchronous.\n  onRawResult(builder, rows) {\n    return rows;\n  }\n  hasOnRawResult() {\n    return this.onRawResult !== QueryBuilderOperation.prototype.onRawResult;\n  }\n\n  // This is called as the first thing after the query has been executed and\n  // rows have been converted to model instances.\n  //\n  // This method can be asynchronous.\n  onAfter1(builder, result) {\n    return result;\n  }\n  hasOnAfter1() {\n    return this.onAfter1 !== QueryBuilderOperation.prototype.onAfter1;\n  }\n\n  // This is called as the second thing after the query has been executed and\n  // rows have been converted to model instances.\n  //\n  // This method can be asynchronous.\n  onAfter2(builder, result) {\n    return result;\n  }\n  hasOnAfter2() {\n    return this.onAfter2 !== QueryBuilderOperation.prototype.onAfter2;\n  }\n\n  // This is called as the third thing after the query has been executed and\n  // rows have been converted to model instances.\n  //\n  // This method can be asynchronous.\n  onAfter3(builder, result) {\n    return result;\n  }\n  hasOnAfter3() {\n    return this.onAfter3 !== QueryBuilderOperation.prototype.onAfter3;\n  }\n\n  // This method can be implemented to return another operation that will replace\n  // this one. This method is called after all `onBeforeX` and `onBuildX` hooks\n  // but before the database query is executed.\n  //\n  // This method must return a QueryBuilder instance.\n  queryExecutor(builder) {}\n  hasQueryExecutor() {\n    return this.queryExecutor !== QueryBuilderOperation.prototype.queryExecutor;\n  }\n\n  // This is called if an error occurs in the query execution.\n  //\n  // This method must return a QueryBuilder instance.\n  onError(builder, error) {}\n  hasOnError() {\n    return this.onError !== QueryBuilderOperation.prototype.onError;\n  }\n\n  // Given a set of operations, returns true if any of this operation's\n  // ancestor operations are included in the set.\n  isAncestorInSet(operationSet) {\n    let ancestor = this.parentOperation;\n\n    while (ancestor) {\n      if (operationSet.has(ancestor)) {\n        return true;\n      }\n\n      ancestor = ancestor.parentOperation;\n    }\n\n    return false;\n  }\n\n  // Takes a deep clone of this operation.\n  clone() {\n    const clone = new this.constructor(this.name, this.opt);\n\n    clone.adderHookName = this.adderHookName;\n    clone.parentOperation = this.parentOperation;\n\n    clone.childOperations = this.childOperations.map(childOp => {\n      const childOpClone = childOp.clone();\n\n      childOpClone.parentOperation = clone;\n      return childOpClone;\n    });\n\n    return clone;\n  }\n\n  // Add an operation as a child operation. `hookName` must be the\n  // name of the parent operation's hook that called this method.\n  addChildOperation(hookName, operation) {\n    operation.adderHookName = hookName;\n    operation.parentOperation = this;\n\n    this.childOperations.push(operation);\n  }\n\n  // Removes a single child operation.\n  removeChildOperation(operation) {\n    const index = this.childOperations.indexOf(operation);\n\n    if (index !== -1) {\n      operation.parentOperation = null;\n      this.childOperations.splice(index, 1);\n    }\n  }\n\n  // Removes all child operations that were added from the `hookName` hook.\n  removeChildOperationsByHookName(hookName) {\n    this.childOperations = this.childOperations.filter(op => op.adderHookName !== hookName);\n  }\n\n  // Iterates through all descendant operations recursively.\n  forEachDescendantOperation(callback) {\n    for (const operation of this.childOperations) {\n      if (callback(operation) === false) {\n        return false;\n      }\n\n      if (operation.forEachDescendantOperation(callback) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nmodule.exports = {\n  QueryBuilderOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass RangeOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.resultSizeBuilder = null;\n  }\n\n  onAdd(builder, args) {\n    if (args.length === 2) {\n      const start = args[0];\n      const end = args[1];\n\n      // Need to set these here instead of `onBuildKnex` so that they\n      // don't end up in the resultSize query.\n      builder.limit(end - start + 1).offset(start);\n    }\n\n    return true;\n  }\n\n  onBefore1(builder, result) {\n    this.resultSizeBuilder = builder.clone();\n    return super.onBefore1(builder, result);\n  }\n\n  onAfter3(_, results) {\n    return this.resultSizeBuilder.resultSize().then(resultSize => {\n      return {\n        results,\n        total: parseInt(resultSize, 10)\n      };\n    });\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.resultSizeBuilder = this.resultSizeBuilder;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  RangeOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass RelateOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n    this.input = null;\n    this.ids = null;\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.input = this.input;\n    clone.ids = this.ids;\n\n    return clone;\n  }\n}\n\nmodule.exports = {\n  RelateOperation\n};\n","'use strict';\n\nconst { flatten } = require('../../utils/objectUtils');\nconst { ObjectionToKnexConvertingOperation } = require('./ObjectionToKnexConvertingOperation');\n\n// This class's only purpose is to normalize the arguments into an array.\n//\n// In knex, if a single column is given to `returning` it returns an array with the that column's value\n// in it. If an array is given with a one item inside, the return value is an object.\nclass ReturningOperation extends ObjectionToKnexConvertingOperation {\n  onAdd(builder, args) {\n    args = flatten(args);\n\n    // Don't add an empty returning list.\n    if (args.length === 0) {\n      return false;\n    }\n\n    return super.onAdd(builder, args);\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    // Always pass an array of columns to knex.returning.\n    knexBuilder.returning(this.getKnexArgs(builder));\n  }\n}\n\nmodule.exports = {\n  ReturningOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass RunAfterOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.func = null;\n  }\n\n  onAdd(_, args) {\n    this.func = args[0];\n    return true;\n  }\n\n  onAfter3(builder, result) {\n    return this.func.call(builder, result, builder);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.func = this.func;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  RunAfterOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass RunBeforeOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.func = null;\n  }\n\n  onAdd(_, args) {\n    this.func = args[0];\n    return true;\n  }\n\n  onBefore1(builder, result) {\n    return this.func.call(builder, result, builder);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.func = this.func;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  RunBeforeOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\n\nclass UnrelateOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n    this.ids = null;\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.ids = this.ids;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  UnrelateOperation\n};\n","'use strict';\n\nconst { DelegateOperation } = require('./DelegateOperation');\nconst { UpdateOperation } = require('./UpdateOperation');\nconst { afterReturn } = require('../../utils/promiseUtils');\n\nclass UpdateAndFetchOperation extends DelegateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    if (!this.delegate.is(UpdateOperation)) {\n      throw new Error('Invalid delegate');\n    }\n\n    this.id = null;\n    this.skipIdWhere = false;\n  }\n\n  get model() {\n    return this.delegate.model;\n  }\n\n  onAdd(builder, args) {\n    this.id = args[0];\n    return this.delegate.onAdd(builder, args.slice(1));\n  }\n\n  onBuild(builder) {\n    super.onBuild(builder);\n\n    if (!this.skipIdWhere) {\n      builder.findById(this.id);\n    }\n  }\n\n  onAfter2(builder, numUpdated) {\n    if (numUpdated == 0) {\n      // If nothing was updated, we should fetch nothing.\n      return afterReturn(super.onAfter2(builder, numUpdated), undefined);\n    }\n\n    return builder\n      .modelClass()\n      .query()\n      .childQueryOf(builder)\n      .findById(this.id)\n      .castTo(builder.resultModelClass())\n      .then(fetched => {\n        let retVal = undefined;\n\n        if (fetched) {\n          this.model.$set(fetched);\n          retVal = this.model;\n        }\n\n        return afterReturn(super.onAfter2(builder, numUpdated), retVal);\n      });\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.id = this.id;\n    clone.skipIdWhere = this.skipIdWhere;\n\n    return clone;\n  }\n}\n\nmodule.exports = {\n  UpdateAndFetchOperation\n};\n","'use strict';\n\nconst { ref } = require('../../queryBuilder/ReferenceBuilder');\nconst { isEmpty } = require('../../utils/objectUtils');\nconst { after, afterReturn } = require('../../utils/promiseUtils');\nconst { isKnexRaw, isKnexQueryBuilder } = require('../../utils/knexUtils');\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { StaticHookArguments } = require('../StaticHookArguments');\n\nclass UpdateOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.model = null;\n    this.modelOptions = Object.assign({}, this.opt.modelOptions || {});\n  }\n\n  onAdd(builder, args) {\n    const json = args[0];\n    const modelClass = builder.modelClass();\n\n    this.model = modelClass.ensureModel(json, this.modelOptions);\n    return true;\n  }\n\n  onBefore2(builder, result) {\n    const maybePromise = callBeforeUpdate(builder, this.model, this.modelOptions);\n    return afterReturn(maybePromise, result);\n  }\n\n  onBefore3(builder) {\n    const row = this.model.$toDatabaseJson(builder);\n\n    if (isEmpty(row)) {\n      // Resolve the query if there is nothing to update.\n      builder.resolve(0);\n    }\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    const json = this.model.$toDatabaseJson(builder);\n    const convertedJson = this.convertFieldExpressionsToRaw(builder, json);\n\n    knexBuilder.update(convertedJson);\n  }\n\n  onAfter2(builder, numUpdated) {\n    return callAfterUpdate(builder, this.model, this.modelOptions, numUpdated);\n  }\n\n  convertFieldExpressionsToRaw(builder, json) {\n    const knex = builder.knex();\n    const modelClass = builder.modelClass();\n    const convertedJson = {};\n\n    for (const key of Object.keys(json)) {\n      let val = json[key];\n\n      if (key.indexOf(':') > -1) {\n        // 'col:attr' : ref('other:lol') is transformed to\n        // \"col\" : raw(`jsonb_set(\"col\", '{attr}', to_jsonb(\"other\"#>'{lol}'), true)`)\n\n        let parsed = ref(key);\n        let jsonRefs = '{' + parsed.parsedExpr.access.map(it => it.ref).join(',') + '}';\n        let valuePlaceholder = '?';\n\n        if (isKnexQueryBuilder(val) || isKnexRaw(val)) {\n          valuePlaceholder = 'to_jsonb(?)';\n        } else {\n          val = JSON.stringify(val);\n        }\n\n        convertedJson[parsed.column] = knex.raw(\n          `jsonb_set(??, '${jsonRefs}', ${valuePlaceholder}, true)`,\n          [convertedJson[parsed.column] || parsed.column, val]\n        );\n      } else {\n        convertedJson[key] = val;\n      }\n    }\n\n    return convertedJson;\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.model = this.model;\n    return clone;\n  }\n}\n\nfunction callBeforeUpdate(builder, model, modelOptions) {\n  const maybePromise = callInstanceBeforeUpdate(builder, model, modelOptions);\n  return after(maybePromise, () => callStaticBeforeUpdate(builder));\n}\n\nfunction callInstanceBeforeUpdate(builder, model, modelOptions) {\n  return model.$beforeUpdate(modelOptions, builder.context());\n}\n\nfunction callStaticBeforeUpdate(builder) {\n  const args = StaticHookArguments.create({ builder });\n  return builder.modelClass().beforeUpdate(args);\n}\n\nfunction callAfterUpdate(builder, model, modelOptions, result) {\n  const maybePromise = callInstanceAfterUpdate(builder, model, modelOptions);\n  return after(maybePromise, () => callStaticAfterUpdate(builder, result));\n}\n\nfunction callInstanceAfterUpdate(builder, model, modelOptions) {\n  return model.$afterUpdate(modelOptions, builder.context());\n}\n\nfunction callStaticAfterUpdate(builder, result) {\n  const args = StaticHookArguments.create({ builder, result });\n  const maybePromise = builder.modelClass().afterUpdate(args);\n\n  return after(maybePromise, maybeResult => {\n    if (maybeResult === undefined) {\n      return result;\n    } else {\n      return maybeResult;\n    }\n  });\n}\n\nmodule.exports = {\n  UpdateOperation\n};\n","'use strict';\n\nconst { DelegateOperation } = require('./DelegateOperation');\nconst { UpsertGraphOperation } = require('./UpsertGraphOperation');\nconst { RelationExpression } = require('../RelationExpression');\n\nclass UpsertGraphAndFetchOperation extends DelegateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    if (!this.delegate.is(UpsertGraphOperation)) {\n      throw new Error('Invalid delegate');\n    }\n  }\n\n  get models() {\n    return this.delegate.models;\n  }\n\n  get isArray() {\n    return this.delegate.isArray;\n  }\n\n  onAfter3(builder) {\n    if (this.models.length === 0) {\n      return this.isArray ? [] : null;\n    }\n\n    const eager = RelationExpression.fromModelGraph(this.models);\n    const modelClass = this.models[0].constructor;\n    const ids = this.models.map(model => model.$id());\n\n    return modelClass\n      .query()\n      .childQueryOf(builder)\n      .findByIds(ids)\n      .eager(eager)\n      .then(models => {\n        return this.isArray ? models : models[0] || null;\n      });\n  }\n}\n\nmodule.exports = {\n  UpsertGraphAndFetchOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('./QueryBuilderOperation');\nconst { GraphUpsert } = require('../graph/GraphUpsert');\n\nclass UpsertGraphOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(\n      name,\n      Object.assign({}, opt, {\n        upsertOptions: {}\n      })\n    );\n\n    this.upsertOptions = opt.upsertOptions || {};\n    this.upsert = null;\n  }\n\n  get models() {\n    return this.upsert.objects;\n  }\n\n  get isArray() {\n    return this.upsert.isArray;\n  }\n\n  onAdd(builder, args) {\n    const [objects] = args;\n\n    this.upsert = new GraphUpsert({\n      objects,\n      rootModelClass: builder.modelClass(),\n      upsertOptions: this.upsertOptions\n    });\n\n    // Never execute this builder.\n    builder.resolve([]);\n\n    return true;\n  }\n\n  onAfter1(builder) {\n    return this.upsert.run(builder);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.upsert = this.upsert;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  UpsertGraphOperation\n};\n","'use strict';\n\nconst { ObjectionToKnexConvertingOperation } = require('./ObjectionToKnexConvertingOperation');\nconst { asSingle } = require('../../utils/objectUtils');\n\nclass WhereCompositeOperation extends ObjectionToKnexConvertingOperation {\n  onBuildKnex(knexBuilder, builder) {\n    const args = this.getKnexArgs(builder);\n\n    if (args.length === 2) {\n      // Convert whereComposite('foo', 1) into whereComposite('foo', '=', 1)\n      args.splice(1, 0, '=');\n    } else if (args.length !== 3) {\n      throw new Error(`invalid number of arguments ${args.length}`);\n    }\n\n    knexBuilder.where(...buildWhereArgs(...args));\n  }\n}\n\nfunction buildWhereArgs(cols, op, values) {\n  if (isNormalWhere(cols, values)) {\n    return buildNormalWhereArgs(cols, op, values);\n  } else if (isCompositeWhere(cols, values)) {\n    return buildCompositeWhereArgs(cols, op, values);\n  } else {\n    throw new Error(`both cols and values must have same dimensions`);\n  }\n}\n\nfunction isNormalWhere(cols, values) {\n  return (\n    (!Array.isArray(cols) || cols.length === 1) && (!Array.isArray(values) || values.length === 1)\n  );\n}\n\nfunction buildNormalWhereArgs(cols, op, values) {\n  return [asSingle(cols), op, asSingle(values)];\n}\n\nfunction isCompositeWhere(cols, values) {\n  return Array.isArray(cols) && Array.isArray(values) && cols.length === values.length;\n}\n\nfunction buildCompositeWhereArgs(cols, op, values) {\n  return [\n    builder => {\n      for (let i = 0, l = cols.length; i < l; ++i) {\n        builder.where(cols[i], op, values[i]);\n      }\n    }\n  ];\n}\n\nmodule.exports = {\n  WhereCompositeOperation\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('../QueryBuilderOperation');\nconst { RelationExpression } = require('../../RelationExpression');\n\nclass EagerOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.expression = RelationExpression.create();\n    this.modifiers = {};\n    this.modifiersAtPath = [];\n    this.allowedExpression = null;\n    this.eagerOptions = this.opt.defaultEagerOptions;\n  }\n\n  get finalExpression() {\n    const expression = this.expression.clone();\n\n    this.modifiersAtPath.forEach((modifier, i) => {\n      const modifierName = getModifierName(i);\n\n      expression.expressionsAtPath(modifier.path).forEach(expr => {\n        expr.node.$modify.push(modifierName);\n      });\n    });\n\n    return expression;\n  }\n\n  get finalModifiers() {\n    const modifiers = Object.assign({}, this.modifiers);\n\n    this.modifiersAtPath.forEach((modifier, i) => {\n      const modifierName = getModifierName(i);\n\n      modifiers[modifierName] = modifier.modifier;\n    });\n\n    return modifiers;\n  }\n\n  cloneFrom(eagerOp) {\n    this.expression = eagerOp.expression.clone();\n    this.modifiers = Object.assign({}, eagerOp.modifiers);\n    this.modifiersAtPath = eagerOp.modifiersAtPath.slice();\n    this.allowedExpression = eagerOp.allowedExpression && eagerOp.allowedExpression.clone();\n    this.eagerOptions = Object.assign({}, eagerOp.eagerOptions);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.cloneFrom(this);\n    return clone;\n  }\n}\n\nfunction getModifierName(index) {\n  return `_f${index}_`;\n}\n\nmodule.exports = {\n  EagerOperation\n};\n","'use strict';\n\nconst { EagerOperation } = require('./EagerOperation');\nconst { RelationJoiner } = require('../../join/RelationJoiner');\n\nclass JoinEagerOperation extends EagerOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.joiner = null;\n  }\n\n  onAdd(builder) {\n    builder.findOptions({ callAfterFindDeeply: true });\n\n    this.joiner = new RelationJoiner({\n      modelClass: builder.modelClass()\n    });\n\n    return true;\n  }\n\n  onBefore3(builder) {\n    return this.joiner\n      .setExpression(this.finalExpression)\n      .setModifiers(this.finalModifiers)\n      .setOptions(this.eagerOptions)\n      .fetchColumnInfo(builder);\n  }\n\n  onBuild(builder) {\n    this.joiner\n      .setExpression(this.finalExpression)\n      .setModifiers(this.finalModifiers)\n      .setOptions(this.eagerOptions)\n      .build(builder);\n  }\n\n  onRawResult(builder, rows) {\n    return this.joiner.parseResult(builder, rows);\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.joiner = this.joiner;\n    return clone;\n  }\n}\n\nmodule.exports = {\n  JoinEagerOperation\n};\n","'use strict';\n\nconst { WhereInEagerOperation } = require('./WhereInEagerOperation');\n\nclass NaiveEagerOperation extends WhereInEagerOperation {\n  batchSize() {\n    return 1;\n  }\n}\n\nmodule.exports = {\n  NaiveEagerOperation\n};\n","'use strict';\n\nconst promiseUtils = require('../../../utils/promiseUtils');\n\nconst { EagerOperation } = require('./EagerOperation');\nconst { isMsSql, isOracle } = require('../../../utils/knexUtils');\nconst { asArray, flatten, chunk } = require('../../../utils/objectUtils');\nconst { ValidationErrorType } = require('../../../model/ValidationError');\nconst { createModifier } = require('../../../utils/createModifier');\nconst { RelationDoesNotExistError } = require('../../../model/RelationDoesNotExistError');\n\nclass WhereInEagerOperation extends EagerOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relationsToFetch = [];\n    this.omitProps = [];\n  }\n\n  batchSize(knex) {\n    if (isMsSql(knex)) {\n      // On MSSQL the parameter limit is actually 2100, but since I couldn't figure out\n      // if the limit is for all parameters in a query or for individual clauses, we set\n      // the limit to 2000 to leave 100 parameters for where clauses etc.\n      return 2000;\n    } else if (isOracle(knex)) {\n      return 1000;\n    } else {\n      // I'm sure there is some kind of limit for other databases too, but let's lower\n      // this if someone ever hits those limits.\n      return 10000;\n    }\n  }\n\n  onBuild(builder) {\n    const relationsToFetch = findRelationsToFetch(builder, this.finalExpression);\n    const { selectionsToAdd, selectedProps } = findRelationPropsToSelect(builder, relationsToFetch);\n\n    if (selectionsToAdd.length) {\n      builder.select(selectionsToAdd);\n    }\n\n    this.relationsToFetch = relationsToFetch;\n    this.omitProps = selectedProps;\n  }\n\n  onAfter2(builder, result) {\n    const modelClass = builder.resultModelClass();\n\n    if (!result) {\n      return result;\n    }\n\n    const models = asArray(result);\n\n    if (!models.length || !(models[0] instanceof modelClass)) {\n      return result;\n    }\n\n    const promise = promiseUtils.map(\n      this.relationsToFetch,\n      it => this.fetchRelation(builder, models, it.relation, it.childExpression),\n      { concurrency: modelClass.getConcurrency(builder.unsafeKnex()) }\n    );\n\n    return promise.then(() => {\n      const intOpt = builder.internalOptions();\n\n      if (!this.omitProps.length || intOpt.keepImplicitJoinProps) {\n        return result;\n      }\n\n      // Now that relations have been fetched for `models` we can omit the\n      // columns that were implicitly selected by this class.\n      for (let i = 0, l = result.length; i < l; ++i) {\n        const model = result[i];\n\n        for (let c = 0, lc = this.omitProps.length; c < lc; ++c) {\n          modelClass.omitImpl(model, this.omitProps[c]);\n        }\n      }\n\n      return result;\n    });\n  }\n\n  fetchRelation(builder, models, relation, expr) {\n    const modelClass = builder.resultModelClass();\n    const batchSize = this.batchSize(builder.knex());\n    const modelBatches = chunk(models, batchSize);\n\n    return promiseUtils\n      .map(modelBatches, batch => this.fetchRelationBatch(builder, batch, relation, expr), {\n        concurrency: modelClass.getConcurrency(builder.unsafeKnex())\n      })\n      .then(flatten);\n  }\n\n  fetchRelationBatch(builder, models, relation, expr) {\n    const queryBuilder = this.createRelationQuery(builder, relation, expr);\n    const findOperation = relation.find(queryBuilder, models);\n\n    findOperation.alwaysReturnArray = true;\n    findOperation.assignResultToOwner = true;\n    findOperation.relationProperty = expr.node.$name;\n\n    queryBuilder.addOperation(findOperation, []);\n\n    for (const modifierName of expr.node.$modify) {\n      const modifier = createModifier({\n        modifier: modifierName,\n        modelClass: relation.relatedModelClass,\n        modifiers: this.finalModifiers\n      });\n\n      try {\n        modifier(queryBuilder);\n      } catch (err) {\n        const modelClass = builder.modelClass();\n\n        if (err instanceof modelClass.ModifierNotFoundError) {\n          throw modelClass.createValidationError({\n            type: ValidationErrorType.RelationExpression,\n            message: `could not find modifier \"${modifierName}\" for relation \"${relation.name}\"`\n          });\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    return queryBuilder;\n  }\n\n  createRelationQuery(builder, relation, childExpression) {\n    return relation.relatedModelClass\n      .query()\n      .childQueryOf(builder)\n      .eagerOptions(this.eagerOptions)\n      .eager(childExpression, this.finalModifiers);\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.relationsToFetch = this.relationsToFetch.slice();\n    clone.omitProps = this.omitProps.slice();\n\n    return clone;\n  }\n}\n\nfunction findRelationsToFetch(builder, eagerExpression) {\n  const relationsToFetch = [];\n  const modelClass = builder.modelClass();\n\n  try {\n    eagerExpression.forEachChildExpression(modelClass, (childExpression, relation) => {\n      relationsToFetch.push({\n        childExpression,\n        relation\n      });\n    });\n  } catch (err) {\n    if (err instanceof RelationDoesNotExistError) {\n      throw modelClass.createValidationError({\n        type: ValidationErrorType.RelationExpression,\n        message: `unknown relation \"${err.relationName}\" in an eager expression`\n      });\n    }\n    throw err;\n  }\n\n  return relationsToFetch;\n}\n\nfunction findRelationPropsToSelect(builder, relationsToFetch) {\n  const selectionsToAdd = [];\n  const selectedProps = [];\n\n  // Collect columns that need to be selected for the eager fetch\n  // to work that are not currently selected.\n  for (const { relation } of relationsToFetch) {\n    const ownerProp = relation.ownerProp;\n\n    for (let c = 0, lc = ownerProp.size; c < lc; ++c) {\n      const fullCol = ownerProp.ref(builder, c).fullColumn(builder);\n      const prop = ownerProp.props[c];\n      const col = ownerProp.cols[c];\n\n      if (!builder.hasSelectionAs(fullCol, col) && selectionsToAdd.indexOf(fullCol) === -1) {\n        selectedProps.push(prop);\n        selectionsToAdd.push(fullCol);\n      }\n    }\n  }\n\n  return {\n    selectionsToAdd,\n    selectedProps\n  };\n}\n\nmodule.exports = {\n  WhereInEagerOperation\n};\n","'use strict';\n\nconst jsonApi = require('./postgresJsonApi');\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\n\nclass WhereJsonHasPostgresOperation extends ObjectionToKnexConvertingOperation {\n  onBuildKnex(knexBuilder, builder) {\n    const args = this.getKnexArgs(builder);\n\n    const sql = jsonApi.whereJsonFieldRightStringArrayOnLeftQuery(\n      builder.knex(),\n      args[0],\n      this.opt.operator,\n      args[1]\n    );\n\n    if (this.opt.bool === 'or') {\n      knexBuilder.orWhereRaw(sql);\n    } else {\n      knexBuilder.whereRaw(sql);\n    }\n  }\n}\n\nmodule.exports = {\n  WhereJsonHasPostgresOperation\n};\n","'use strict';\n\nconst jsonApi = require('./postgresJsonApi');\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\n\nclass WhereJsonNotObjectPostgresOperation extends ObjectionToKnexConvertingOperation {\n  onBuildKnex(knexBuilder, builder) {\n    this.whereJsonNotObject(knexBuilder, builder.knex(), this.getKnexArgs(builder)[0]);\n  }\n\n  whereJsonNotObject(knexBuilder, knex, fieldExpression) {\n    const innerQuery = innerQuery => {\n      const builder = jsonApi.whereJsonbRefOnLeftJsonbValOrRefOnRight(\n        innerQuery,\n        fieldExpression,\n        '@>',\n        this.opt.compareValue,\n        'not'\n      );\n\n      builder.orWhereRaw(jsonApi.whereJsonFieldQuery(knex, fieldExpression, 'IS', null));\n    };\n\n    if (this.opt.bool === 'or') {\n      knexBuilder.orWhere(innerQuery);\n    } else {\n      knexBuilder.where(innerQuery);\n    }\n  }\n}\n\nmodule.exports = {\n  WhereJsonNotObjectPostgresOperation\n};\n","'use strict';\n\nconst jsonApi = require('./postgresJsonApi');\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\n\nclass WhereJsonPostgresOperation extends ObjectionToKnexConvertingOperation {\n  onBuildKnex(knexBuilder, builder) {\n    const args = this.getKnexArgs(builder);\n\n    const rawArgs = jsonApi.whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(\n      args[0],\n      this.opt.operator,\n      args[1],\n      this.opt.prefix\n    );\n\n    if (this.opt.bool === 'or') {\n      knexBuilder.orWhereRaw.apply(knexBuilder, rawArgs);\n    } else {\n      knexBuilder.whereRaw.apply(knexBuilder, rawArgs);\n    }\n  }\n}\n\nmodule.exports = {\n  WhereJsonPostgresOperation\n};\n","'use strict';\n\nconst parser = require('../../../utils/parseFieldExpression');\nconst { asArray, isObject, isString } = require('../../../utils/objectUtils');\n\n/**\n * @typedef {String} FieldExpression\n *\n * Field expressions allow one to refer to separate JSONB fields inside columns.\n *\n * Syntax: <column reference>[:<json field reference>]\n *\n * e.g. `Person.jsonColumnName:details.names[1]` would refer to value `'Second'`\n * in column `Person.jsonColumnName` which has\n * `{ details: { names: ['First', 'Second', 'Last'] } }` object stored in it.\n *\n * First part `<column reference>` is compatible with column references used in\n * knex e.g. `MyFancyTable.tributeToThBestColumnNameEver`.\n *\n * Second part describes a path to an attribute inside the referred column.\n * It is optional and it always starts with colon which follows directly with\n * first path element. e.g. `Table.jsonObjectColumnName:jsonFieldName` or\n * `Table.jsonArrayColumn:[321]`.\n *\n * Syntax supports `[<key or index>]` and `.<key or index>` flavors of reference\n * to json keys / array indexes:\n *\n * e.g. both `Table.myColumn:[1][3]` and `Table.myColumn:1.3` would access correctly\n * both of the following objects `[null, [null,null,null, \"I was accessed\"]]` and\n * `{ \"1\": { \"3\" : \"I was accessed\" } }`\n *\n * Caveats when using special characters in keys:\n *\n * 1. `objectColumn.key` This is the most common syntax, good if you are\n *    not using dots or square brackets `[]` in your json object key name.\n * 2. Keys containing dots `objectColumn:[keywith.dots]` Column `{ \"keywith.dots\" : \"I was referred\" }`\n * 3. Keys containing square brackets `column['[]']` `{ \"[]\" : \"This is getting ridiculous...\" }`\n * 4. Keys containing square brackets and quotes\n *    `objectColumn:['Double.\"Quote\".[]']` and `objectColumn:[\"Sinlge.'Quote'.[]\"]`\n *    Column `{ \"Double.\\\"Quote\\\".[]\" : \"I was referred\",  \"Single.'Quote'.[]\" : \"Mee too!\" }`\n * 99. Keys containing dots, square brackets, single quotes and double quotes in one json key is\n *     not currently supported\n */\n\nfunction parseFieldExpression(expression, extractAsText) {\n  let parsed = parser.parseFieldExpression(expression);\n  let jsonRefs = parsed.access.map(it => it.ref).join(',');\n  let extractor = extractAsText ? '#>>' : '#>';\n  let middleQuotedColumnName = parsed.columnName.split('.').join('\".\"');\n  return `\"${middleQuotedColumnName}\"${extractor}'{${jsonRefs}}'`;\n}\n\nfunction whereJsonbRefOnLeftJsonbValOrRefOnRight(\n  builder,\n  fieldExpression,\n  operator,\n  jsonObjectOrFieldExpression,\n  queryPrefix\n) {\n  let queryParams = whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(\n    fieldExpression,\n    operator,\n    jsonObjectOrFieldExpression,\n    queryPrefix\n  );\n  return builder.whereRaw.apply(builder, queryParams);\n}\n\nfunction whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams(\n  fieldExpression,\n  operator,\n  jsonObjectOrFieldExpression,\n  queryPrefix\n) {\n  let fieldReference = parseFieldExpression(fieldExpression);\n\n  if (isString(jsonObjectOrFieldExpression)) {\n    let rightHandReference = parseFieldExpression(jsonObjectOrFieldExpression);\n    let refRefQuery = [\n      '(',\n      fieldReference,\n      ')::jsonb',\n      operator,\n      '(',\n      rightHandReference,\n      ')::jsonb'\n    ];\n    if (queryPrefix) {\n      refRefQuery.unshift(queryPrefix);\n    }\n    return [refRefQuery.join(' ')];\n  } else if (isObject(jsonObjectOrFieldExpression)) {\n    let refValQuery = ['(', fieldReference, ')::jsonb', operator, '?::jsonb'];\n    if (queryPrefix) {\n      refValQuery.unshift(queryPrefix);\n    }\n    return [refValQuery.join(' '), JSON.stringify(jsonObjectOrFieldExpression)];\n  }\n\n  throw new Error('Invalid right hand expression.');\n}\n\nfunction whereJsonFieldRightStringArrayOnLeftQuery(knex, fieldExpression, operator, keys) {\n  let fieldReference = parseFieldExpression(fieldExpression);\n  keys = asArray(keys);\n\n  let questionMarksArray = keys.map(key => {\n    if (!isString(key)) {\n      throw new Error('All keys to find must be strings.');\n    }\n    return '?';\n  });\n\n  let rawSqlTemplateString = 'array[' + questionMarksArray.join(',') + ']';\n  let rightHandExpression = knex.raw(rawSqlTemplateString, keys);\n\n  return `${fieldReference} ${operator.replace('?', '\\\\?')} ${rightHandExpression}`;\n}\n\nfunction whereJsonFieldQuery(knex, fieldExpression, operator, value) {\n  let fieldReference = parseFieldExpression(fieldExpression, true);\n  let normalizedOperator = normalizeOperator(knex, operator);\n\n  // json type comparison takes json type in string format\n  let cast;\n  let escapedValue = knex.raw(' ?', [value]);\n  let type = typeof value;\n\n  if (type === 'number') {\n    cast = '::NUMERIC';\n  } else if (type === 'boolean') {\n    cast = '::BOOLEAN';\n  } else if (type === 'string') {\n    cast = '::TEXT';\n  } else if (value === null) {\n    cast = '::TEXT';\n    escapedValue = 'NULL';\n  } else {\n    throw new Error('Value must be string, number, boolean or null.');\n  }\n\n  return `(${fieldReference})${cast} ${normalizedOperator} ${escapedValue}`;\n}\n\nfunction normalizeOperator(knex, operator) {\n  let trimmedLowerCase = operator.trim().toLowerCase();\n\n  switch (trimmedLowerCase) {\n    case 'is':\n    case 'is not':\n      return trimmedLowerCase;\n    default:\n      return knex.client.formatter().operator(operator);\n  }\n}\n\nmodule.exports = {\n  parseFieldExpression: parseFieldExpression,\n  whereJsonbRefOnLeftJsonbValOrRefOnRight: whereJsonbRefOnLeftJsonbValOrRefOnRight,\n  whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams: whereJsonbRefOnLeftJsonbValOrRefOnRightRawQueryParams,\n  whereJsonFieldRightStringArrayOnLeftQuery: whereJsonFieldRightStringArrayOnLeftQuery,\n  whereJsonFieldQuery: whereJsonFieldQuery\n};\n","'use strict';\n\nconst { flatten } = require('../../../utils/objectUtils');\nconst { Selection } = require('./Selection');\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\n\nconst COUNT_REGEX = /count/i;\n\nclass SelectOperation extends ObjectionToKnexConvertingOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.selections = [];\n  }\n\n  onAdd(builder, args) {\n    const selections = flatten(args);\n\n    // Don't add an empty selection. Empty list is accepted for `count`, `countDistinct`\n    // etc. because knex apparently supports it.\n    if (selections.length === 0 && !COUNT_REGEX.test(this.name)) {\n      return false;\n    }\n\n    const ret = super.onAdd(builder, selections);\n\n    for (const selection of selections) {\n      const selectionInstance = Selection.create(selection);\n\n      if (selectionInstance) {\n        this.selections.push(selectionInstance);\n      }\n    }\n\n    return ret;\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    knexBuilder[this.name].apply(knexBuilder, this.getKnexArgs(builder));\n  }\n\n  findSelection(builder, selectionToFind) {\n    const selectionInstanceToFind = Selection.create(selectionToFind);\n\n    if (!selectionInstanceToFind) {\n      return null;\n    }\n\n    for (const selection of this.selections) {\n      if (Selection.doesSelect(builder, selection, selectionInstanceToFind)) {\n        return selection;\n      }\n    }\n\n    return null;\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.selections = this.selections.slice();\n    return clone;\n  }\n}\n\nmodule.exports = {\n  SelectOperation\n};\n","'use strict';\n\nconst { isString, isObject } = require('../../../utils/objectUtils');\n\nconst ALIAS_REGEX = /\\s+as\\s+/i;\n\nclass Selection {\n  constructor(table, column, alias) {\n    this.table = table;\n    this.column = column;\n    this.alias = alias;\n  }\n\n  get name() {\n    return this.alias || this.column;\n  }\n\n  static create(selection) {\n    if (isObject(selection)) {\n      if (selection.isObjectionSelection) {\n        return selection;\n      } else if (selection.isObjectionReferenceBuilder) {\n        return createSelectionFromReference(selection);\n      } else if (selection.isObjectionRawBuilder) {\n        return createSelectionFromRaw(selection);\n      } else {\n        return null;\n      }\n    } else if (isString(selection)) {\n      return createSelectionFromString(selection);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns true if `selectionInBuilder` causes `selectionToTest` to be selected.\n   *\n   * Examples that return true:\n   *\n   * doesSelect(Person.query(), '*', 'name')\n   * doesSelect(Person.query(), 'Person.*', 'name')\n   * doesSelect(Person.query(), 'name', 'name')\n   * doesSelect(Person.query(), 'name', 'Person.name')\n   */\n  static doesSelect(builder, selectionInBuilder, selectionToTest) {\n    selectionInBuilder = Selection.create(selectionInBuilder);\n    selectionToTest = Selection.create(selectionToTest);\n\n    if (selectionInBuilder.column === '*') {\n      if (selectionInBuilder.table) {\n        if (selectionToTest.column === '*') {\n          return selectionToTest.table === selectionInBuilder.table;\n        } else {\n          return (\n            selectionToTest.table === null || selectionToTest.table === selectionInBuilder.table\n          );\n        }\n      } else {\n        return true;\n      }\n    } else {\n      const selectionInBuilderTable = selectionInBuilder.table || builder.tableRef();\n\n      if (selectionToTest.column === '*') {\n        return false;\n      } else {\n        return (\n          selectionToTest.column === selectionInBuilder.column &&\n          (selectionToTest.table === null || selectionToTest.table === selectionInBuilderTable)\n        );\n      }\n    }\n  }\n}\n\nObject.defineProperties(Selection.prototype, {\n  isObjectionSelection: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nfunction createSelectionFromReference(ref) {\n  return new Selection(ref.tableName, ref.column, ref.alias);\n}\n\nfunction createSelectionFromRaw(raw) {\n  if (raw.alias) {\n    return new Selection(null, null, raw.alias);\n  } else {\n    return null;\n  }\n}\n\nfunction createSelectionFromString(selection) {\n  let table = null;\n  let column = null;\n  let alias = null;\n\n  if (ALIAS_REGEX.test(selection)) {\n    const parts = selection.split(ALIAS_REGEX);\n\n    selection = parts[0].trim();\n    alias = parts[1].trim();\n  }\n\n  const dotIdx = selection.lastIndexOf('.');\n\n  if (dotIdx !== -1) {\n    table = selection.substr(0, dotIdx);\n    column = selection.substr(dotIdx + 1);\n  } else {\n    column = selection;\n  }\n\n  return new Selection(table, column, alias);\n}\n\nmodule.exports = {\n  Selection\n};\n","'use strict';\n\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\nconst { flatten, zipObject, isString } = require('../../../utils/objectUtils');\nconst { getTempColumn } = require('../../../utils/tmpColumnUtils');\n\nclass WhereInCompositeMsSqlOperation extends ObjectionToKnexConvertingOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.prefix = this.opt.prefix || null;\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    const args = this.getKnexArgs(builder);\n    this.build(builder.knex(), knexBuilder, args[0], args[1]);\n  }\n\n  build(knex, knexBuilder, columns, values) {\n    let isCompositeKey = Array.isArray(columns) && columns.length > 1;\n\n    if (isCompositeKey) {\n      this.buildComposite(knex, knexBuilder, columns, values);\n    } else {\n      this.buildNonComposite(knexBuilder, columns, values);\n    }\n  }\n\n  buildComposite(knex, knexBuilder, columns, values) {\n    const helperColumns = columns.map((_, index) => getTempColumn(index));\n\n    if (Array.isArray(values)) {\n      this.buildCompositeValue(knex, knexBuilder, columns, helperColumns, values);\n    } else {\n      this.buildCompositeSubquery(\n        knex,\n        knexBuilder,\n        columns,\n        helperColumns,\n        values.as(knex.raw(`V(${helperColumns.map(_ => '??')})`, helperColumns))\n      );\n    }\n  }\n\n  buildCompositeValue(knex, knexBuilder, columns, helperColumns, values) {\n    return this.buildCompositeSubquery(\n      knex,\n      knexBuilder,\n      columns,\n      helperColumns,\n      knex.raw(\n        `(VALUES ${values\n          .map(value => `(${value.map(_ => '?').join(',')})`)\n          .join(',')}) AS V(${helperColumns.map(_ => '??').join(',')})`,\n        flatten(values).concat(helperColumns)\n      )\n    );\n  }\n\n  buildCompositeSubquery(knex, knexBuilder, columns, helperColumns, subQuery) {\n    const wrapperQuery = knex\n      .from(subQuery)\n      .where(zipObject(helperColumns, columns.map(column => knex.raw('??', column))));\n\n    if (this.prefix === 'not') {\n      return knexBuilder.whereNotExists(wrapperQuery);\n    } else {\n      return knexBuilder.whereExists(wrapperQuery);\n    }\n  }\n\n  buildNonComposite(knexBuilder, columns, values) {\n    const col = isString(columns) ? columns : columns[0];\n\n    if (Array.isArray(values)) {\n      values = pickNonNull(values, []);\n    } else {\n      values = [values];\n    }\n\n    this.whereIn(knexBuilder, col, values);\n  }\n\n  whereIn(knexBuilder, col, val) {\n    if (this.prefix === 'not') {\n      knexBuilder.whereNotIn(col, val);\n    } else {\n      knexBuilder.whereIn(col, val);\n    }\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.prefix = this.prefix;\n    return clone;\n  }\n}\n\nfunction pickNonNull(values, output) {\n  for (let i = 0, l = values.length; i < l; ++i) {\n    const val = values[i];\n\n    if (Array.isArray(val)) {\n      pickNonNull(val, output);\n    } else if (val !== null && val !== undefined) {\n      output.push(val);\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = {\n  WhereInCompositeMsSqlOperation\n};\n","'use strict';\n\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\nconst { isObject, asSingle } = require('../../../utils/objectUtils');\nconst { isKnexQueryBuilder } = require('../../../utils/knexUtils');\n\nclass WhereInCompositeOperation extends ObjectionToKnexConvertingOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.prefix = this.opt.prefix || null;\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    const whereInArgs = buildWhereInArgs(builder.knex(), ...this.getKnexArgs(builder));\n\n    if (this.prefix === 'not') {\n      return knexBuilder.whereNotIn(...whereInArgs);\n    } else {\n      return knexBuilder.whereIn(...whereInArgs);\n    }\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.prefix = this.prefix;\n    return clone;\n  }\n}\n\nfunction buildWhereInArgs(knex, columns, values) {\n  if (isCompositeKey(columns)) {\n    return buildCompositeArgs(knex, columns, values);\n  } else {\n    return buildNonCompositeArgs(columns, values);\n  }\n}\n\nfunction isCompositeKey(columns) {\n  return Array.isArray(columns) && columns.length > 1;\n}\n\nfunction buildCompositeArgs(knex, columns, values) {\n  if (Array.isArray(values)) {\n    return buildCompositeValueArgs(columns, values);\n  } else {\n    return buildCompositeSubqueryArgs(knex, columns, values);\n  }\n}\n\nfunction buildCompositeValueArgs(columns, values) {\n  return [columns, values];\n}\n\nfunction buildCompositeSubqueryArgs(knex, columns, subquery) {\n  const sql = `(${columns\n    .map(col => {\n      // On older versions of knex, raw doesn't work\n      // with `??`. We use `?` for those.\n      if (isObject(col)) {\n        return '?';\n      } else {\n        return '??';\n      }\n    })\n    .join(',')})`;\n\n  return [knex.raw(sql, columns), subquery];\n}\n\nfunction buildNonCompositeArgs(columns, values) {\n  if (Array.isArray(values)) {\n    values = pickNonNull(values, []);\n  } else if (!isKnexQueryBuilder(values)) {\n    values = [values];\n  }\n\n  return [asSingle(columns), values];\n}\n\nfunction pickNonNull(values, output) {\n  for (let i = 0, l = values.length; i < l; ++i) {\n    const val = values[i];\n\n    if (Array.isArray(val)) {\n      pickNonNull(val, output);\n    } else if (val !== null && val !== undefined) {\n      output.push(val);\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = {\n  WhereInCompositeOperation\n};\n","'use strict';\n\nconst { ObjectionToKnexConvertingOperation } = require('../ObjectionToKnexConvertingOperation');\nconst { isKnexQueryBuilder } = require('../../../utils/knexUtils');\nconst { asSingle } = require('../../../utils/objectUtils');\n\nclass WhereInCompositeSqliteOperation extends ObjectionToKnexConvertingOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.prefix = this.opt.prefix || null;\n  }\n\n  onBuildKnex(knexBuilder, builder) {\n    const { method, args } = buildWhereArgs(...this.getKnexArgs(builder));\n\n    if (method === 'where') {\n      if (this.prefix === 'not') {\n        return knexBuilder.whereNot(...args);\n      } else {\n        return knexBuilder.where(...args);\n      }\n    } else {\n      if (this.prefix === 'not') {\n        return knexBuilder.whereNotIn(...args);\n      } else {\n        return knexBuilder.whereIn(...args);\n      }\n    }\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.prefix = this.prefix;\n    return clone;\n  }\n}\n\nfunction buildWhereArgs(columns, values) {\n  if (isCompositeKey(columns)) {\n    return buildCompositeArgs(columns, values);\n  } else {\n    return buildNonCompositeArgs(columns, values);\n  }\n}\n\nfunction isCompositeKey(columns) {\n  return Array.isArray(columns) && columns.length > 1;\n}\n\nfunction buildCompositeArgs(columns, values) {\n  if (!Array.isArray(values)) {\n    // If the `values` is not an array of values but a function or a subquery\n    // we have no way to implement this method.\n    throw new Error(`sqlite doesn't support multi-column where in clauses`);\n  }\n\n  // Sqlite doesn't support the `where in` syntax for multiple columns but\n  // we can emulate it using grouped `or` clauses.\n  return {\n    method: 'where',\n    args: [\n      builder => {\n        values.forEach(val => {\n          builder.orWhere(builder => {\n            columns.forEach((col, idx) => {\n              builder.andWhere(col, val[idx]);\n            });\n          });\n        });\n      }\n    ]\n  };\n}\n\nfunction buildNonCompositeArgs(columns, values) {\n  if (Array.isArray(values)) {\n    values = pickNonNull(values, []);\n  } else if (!isKnexQueryBuilder(values)) {\n    values = [values];\n  }\n\n  return {\n    method: 'whereIn',\n    args: [asSingle(columns), values]\n  };\n}\n\nfunction pickNonNull(values, output) {\n  for (let i = 0, l = values.length; i < l; ++i) {\n    const val = values[i];\n\n    if (Array.isArray(val)) {\n      pickNonNull(val, output);\n    } else if (val !== null && val !== undefined) {\n      output.push(val);\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = {\n  WhereInCompositeSqliteOperation\n};\n","'use strict';\n\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = 'SyntaxError';\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"';\n    },\n\n    class: function(expectation) {\n      var escapedParts = '',\n        i;\n\n      for (i = 0; i < expectation.parts.length; i++) {\n        escapedParts +=\n          expectation.parts[i] instanceof Array\n            ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])\n            : classEscape(expectation.parts[i]);\n      }\n\n      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';\n    },\n\n    any: function(expectation) {\n      return 'any character';\n    },\n\n    end: function(expectation) {\n      return 'end of input';\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch\n      .charCodeAt(0)\n      .toString(16)\n      .toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function(ch) {\n        return '\\\\x0' + hex(ch);\n      })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return '\\\\x' + hex(ch);\n      });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g, '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function(ch) {\n        return '\\\\x0' + hex(ch);\n      })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return '\\\\x' + hex(ch);\n      });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n      i,\n      j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + ' or ' + descriptions[1];\n\n      default:\n        return (\n          descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1]\n        );\n    }\n  }\n\n  function describeFound(found) {\n    return found ? '\"' + literalEscape(found) + '\"' : 'end of input';\n  }\n\n  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n    peg$startRuleFunctions = { start: peg$parsestart },\n    peg$startRuleFunction = peg$parsestart,\n    peg$c0 = ':',\n    peg$c1 = peg$literalExpectation(':', false),\n    peg$c2 = function(column, refs) {\n      var access = [];\n      if (refs) {\n        var firstAccess = refs[1];\n        access = refs[2];\n        access.unshift(firstAccess);\n      }\n      return { columnName: column, access: access };\n    },\n    peg$c3 = '[',\n    peg$c4 = peg$literalExpectation('[', false),\n    peg$c5 = '\"',\n    peg$c6 = peg$literalExpectation('\"', false),\n    peg$c7 = \"'\",\n    peg$c8 = peg$literalExpectation(\"'\", false),\n    peg$c9 = ']',\n    peg$c10 = peg$literalExpectation(']', false),\n    peg$c11 = function(key) {\n      return { type: 'object', ref: Array.isArray(key) ? key[1] : key };\n    },\n    peg$c12 = function(index) {\n      return { type: 'array', ref: parseInt(index, 10) };\n    },\n    peg$c13 = function(key) {\n      return { type: 'object', ref: key };\n    },\n    peg$c14 = '.',\n    peg$c15 = peg$literalExpectation('.', false),\n    peg$c16 = /^[^\\][]/,\n    peg$c17 = peg$classExpectation([']', '['], true, false),\n    peg$c18 = function(chars) {\n      return chars.join('');\n    },\n    peg$c19 = /^[^:]/,\n    peg$c20 = peg$classExpectation([':'], true, false),\n    peg$c21 = /^[^\"]/,\n    peg$c22 = peg$classExpectation(['\"'], true, false),\n    peg$c23 = /^[^']/,\n    peg$c24 = peg$classExpectation([\"'\"], true, false),\n    peg$c25 = /^[^.\\][]/,\n    peg$c26 = peg$classExpectation(['.', ']', '['], true, false),\n    peg$c27 = /^[0-9]/,\n    peg$c28 = peg$classExpectation([['0', '9']], false, false),\n    peg$c29 = function(digits) {\n      return digits.join('');\n    },\n    peg$currPos = 0,\n    peg$savedPos = 0,\n    peg$posDetailsCache = [{ line: 1, column: 1 }],\n    peg$maxFailPos = 0,\n    peg$maxFailExpected = [],\n    peg$silentFails = 0,\n    peg$result;\n\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error('Can\\'t start parsing from rule \"' + options.startRule + '\".');\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: 'literal', text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: 'any' };\n  }\n\n  function peg$endExpectation() {\n    return { type: 'end' };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: 'other', description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos],\n      p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n      endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) {\n      return;\n    }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestringWithoutColon();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s3 = peg$c0;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c1);\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsebracketIndexRef();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parsebracketStringRef();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parsecolonReference();\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          s6 = peg$parsebracketIndexRef();\n          if (s6 === peg$FAILED) {\n            s6 = peg$parsebracketStringRef();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parsedotReference();\n            }\n          }\n          while (s6 !== peg$FAILED) {\n            s5.push(s6);\n            s6 = peg$parsebracketIndexRef();\n            if (s6 === peg$FAILED) {\n              s6 = peg$parsebracketStringRef();\n              if (s6 === peg$FAILED) {\n                s6 = peg$parsedotReference();\n              }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebracketStringRef() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c3;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c4);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c5;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c6);\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsestringWithoutDoubleQuotes();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s5 = peg$c5;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c6);\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c8);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsestringWithoutSingleQuotes();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s5 = peg$c7;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c8);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s3 = [s3, s4, s5];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 === peg$FAILED) {\n          s2 = peg$parsestringWithoutSquareBrackets();\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c9;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c10);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c11(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsebracketIndexRef() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c3;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c4);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseinteger();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c9;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c10);\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c12(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolonReference() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestringWithoutSquareBracketsOrDots();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c13(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsedotReference() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c14;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c15);\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsestringWithoutSquareBracketsOrDots();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c13(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestringWithoutSquareBrackets() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c17);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c16.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c17);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c18(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsestringWithoutColon() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c19.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c20);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c19.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c20);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c18(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsestringWithoutDoubleQuotes() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c21.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c22);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c21.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c22);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c18(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsestringWithoutSingleQuotes() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c24);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c23.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c24);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c18(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsestringWithoutSquareBracketsOrDots() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c25.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c26);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c25.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c26);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c18(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseinteger() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c27.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c28);\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c27.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c28);\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c29(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n'use strict';\n\nfunction peg$subclass(child, parent) {\n  function ctor() {\n    this.constructor = child;\n  }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = 'SyntaxError';\n\n  if (typeof Error.captureStackTrace === 'function') {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"';\n    },\n\n    class: function(expectation) {\n      var escapedParts = '',\n        i;\n\n      for (i = 0; i < expectation.parts.length; i++) {\n        escapedParts +=\n          expectation.parts[i] instanceof Array\n            ? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])\n            : classEscape(expectation.parts[i]);\n      }\n\n      return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';\n    },\n\n    any: function(expectation) {\n      return 'any character';\n    },\n\n    end: function(expectation) {\n      return 'end of input';\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch\n      .charCodeAt(0)\n      .toString(16)\n      .toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function(ch) {\n        return '\\\\x0' + hex(ch);\n      })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return '\\\\x' + hex(ch);\n      });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g, '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g, function(ch) {\n        return '\\\\x0' + hex(ch);\n      })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n        return '\\\\x' + hex(ch);\n      });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n      i,\n      j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + ' or ' + descriptions[1];\n\n      default:\n        return (\n          descriptions.slice(0, -1).join(', ') + ', or ' + descriptions[descriptions.length - 1]\n        );\n    }\n  }\n\n  function describeFound(found) {\n    return found ? '\"' + literalEscape(found) + '\"' : 'end of input';\n  }\n\n  return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n    peg$startRuleFunctions = { start: peg$parsestart },\n    peg$startRuleFunction = peg$parsestart,\n    peg$c0 = function(expr) {\n      const node = newNode();\n\n      if (expr.$name === '*') {\n        node.$allRecursive = true;\n      } else {\n        assertDuplicateRelation(node, expr);\n        node[expr.$name] = expr;\n        node.$childNames.push(expr.$name);\n      }\n\n      return node;\n    },\n    peg$c1 = function(list) {\n      const node = newNode();\n\n      list.forEach(expr => {\n        assertDuplicateRelation(node, expr);\n        node[expr.$name] = expr;\n        node.$childNames.push(expr.$name);\n      });\n\n      return node;\n    },\n    peg$c2 = function(name, args, alias, list) {\n      const node = newNode();\n\n      node.$name = alias || name;\n      node.$relation = name;\n      node.$modify = args || [];\n\n      list.forEach(expr => {\n        assertDuplicateRelation(node, expr);\n        node[expr.$name] = expr;\n        node.$childNames.push(expr.$name);\n      });\n\n      return node;\n    },\n    peg$c3 = function(name, args, alias, expr) {\n      const node = newNode();\n\n      node.$name = alias || name;\n      node.$relation = name;\n      node.$modify = args || [];\n\n      if (expr) {\n        const match = /^\\^(\\d*)$/.exec(expr.$name);\n\n        if (match) {\n          if (match[1]) {\n            node.$recursive = parseInt(match[1], 10);\n          } else {\n            node.$recursive = true;\n          }\n        } else if (expr.$name === '*') {\n          node.$allRecursive = true;\n        } else {\n          assertDuplicateRelation(node, expr);\n          node[expr.$name] = expr;\n          node.$childNames.push(expr.$name);\n        }\n      }\n\n      return node;\n    },\n    peg$c4 = 'as',\n    peg$c5 = peg$literalExpectation('as', false),\n    peg$c6 = function(alias) {\n      return alias;\n    },\n    peg$c7 = function(name) {\n      return name.join('');\n    },\n    peg$c8 = /^[^[\\](),. \\t\\r\\n]/,\n    peg$c9 = peg$classExpectation(\n      ['[', ']', '(', ')', ',', '.', ' ', '\\t', '\\r', '\\n'],\n      true,\n      false\n    ),\n    peg$c10 = '(',\n    peg$c11 = peg$literalExpectation('(', false),\n    peg$c12 = ')',\n    peg$c13 = peg$literalExpectation(')', false),\n    peg$c14 = function(args) {\n      return args;\n    },\n    peg$c15 = ',',\n    peg$c16 = peg$literalExpectation(',', false),\n    peg$c17 = function(arg) {\n      return arg;\n    },\n    peg$c18 = /^[ \\t\\r\\n]/,\n    peg$c19 = peg$classExpectation([' ', '\\t', '\\r', '\\n'], false, false),\n    peg$c20 = '.',\n    peg$c21 = peg$literalExpectation('.', false),\n    peg$c22 = function(list) {\n      return list;\n    },\n    peg$c23 = '[',\n    peg$c24 = peg$literalExpectation('[', false),\n    peg$c25 = ']',\n    peg$c26 = peg$literalExpectation(']', false),\n    peg$c27 = function(items) {\n      return items;\n    },\n    peg$c28 = function(expr) {\n      return expr;\n    },\n    peg$c29 = function(sub) {\n      return sub;\n    },\n    peg$currPos = 0,\n    peg$savedPos = 0,\n    peg$posDetailsCache = [{ line: 1, column: 1 }],\n    peg$maxFailPos = 0,\n    peg$maxFailExpected = [],\n    peg$silentFails = 0,\n    peg$result;\n\n  if ('startRule' in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error('Can\\'t start parsing from rule \"' + options.startRule + '\".');\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: 'literal', text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: 'any' };\n  }\n\n  function peg$endExpectation() {\n    return { type: 'end' };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: 'other', description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos],\n      p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n      endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) {\n      return;\n    }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseexpression();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c0(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parselistExpression();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseexpression() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsename();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseargs();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsealias();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesubListExpression();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c2(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsename();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseargs();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsealias();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesubExpression();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c3(s1, s2, s3, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsealias() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsews();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c4) {\n        s2 = peg$c4;\n        peg$currPos += 2;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c5);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parsews();\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsename();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c6(s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsename() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsechar();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsechar();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsechar() {\n    var s0;\n\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c9);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseargs() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsews();\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s2 = peg$c10;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c11);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseargListItem();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseargListItem();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsews();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsews();\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s5 = peg$c12;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c13);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c14(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseargListItem() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsews();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsename();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c16);\n            }\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c17(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsews() {\n    var s0;\n\n    if (peg$c18.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) {\n        peg$fail(peg$c19);\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubListExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsews();\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s2 = peg$c20;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c21);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselistExpression();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselistExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsews();\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c23;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c24);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parselistExpressionItem();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parselistExpressionItem();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsews();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsews();\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s5 = peg$c25;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c26);\n              }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = [];\n              s7 = peg$parsews();\n              while (s7 !== peg$FAILED) {\n                s6.push(s7);\n                s7 = peg$parsews();\n              }\n              if (s6 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c27(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselistExpressionItem() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsews();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexpression();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s4 = peg$c15;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c16);\n            }\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c28(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubExpression() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsews();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsews();\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s2 = peg$c20;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c21);\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsews();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsews();\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseexpression();\n          if (s4 !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parsews();\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parsews();\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c29(s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function assertDuplicateRelation(node, expr) {\n    if (expr.$name in node) {\n      console.warn(\n        `Duplicate relation \"${\n          expr.$name\n        }\" in a relation expression. You should use \"a.[b, c]\" instead of \"[a.b, a.c]\". This will cause an error in objection 2.0`\n      );\n\n      // TODO: enable for v2.0.\n      // const err = new Error();\n      // err.duplicateRelationName = expr.$name;\n      // throw err;\n    }\n  }\n\n  function newNode() {\n    return {\n      $name: null,\n      $relation: null,\n      $modify: [],\n      $recursive: false,\n      $allRecursive: false,\n      $childNames: []\n    };\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","'use strict';\n\nconst { RelationProperty } = require('./RelationProperty');\nconst getModel = () => require('../model/Model').Model;\n\nconst { RelationFindOperation } = require('./RelationFindOperation');\nconst { RelationUpdateOperation } = require('./RelationUpdateOperation');\nconst { RelationDeleteOperation } = require('./RelationDeleteOperation');\nconst { RelationSubqueryOperation } = require('./RelationSubqueryOperation');\n\nconst { ref } = require('../queryBuilder/ReferenceBuilder');\nconst { isSubclassOf } = require('../utils/classUtils');\nconst { resolveModel } = require('../utils/resolveModel');\nconst { get, isFunction } = require('../utils/objectUtils');\nconst { mapAfterAllReturn } = require('../utils/promiseUtils');\nconst { createModifier } = require('../utils/createModifier');\n\nclass Relation {\n  constructor(relationName, OwnerClass) {\n    this.name = relationName;\n    this.ownerModelClass = OwnerClass;\n    this.relatedModelClass = null;\n\n    this.ownerProp = null;\n    this.relatedProp = null;\n\n    this.joinTableModelClass = null;\n    this.joinTableOwnerProp = null;\n    this.joinTableRelatedProp = null;\n    this.joinTableBeforeInsert = null;\n    this.joinTableExtras = [];\n\n    this.modify = null;\n    this.beforeInsert = null;\n  }\n\n  setMapping(mapping) {\n    let ctx = {\n      name: this.name,\n      mapping,\n      ownerModelClass: this.ownerModelClass,\n      relatedModelClass: null,\n      relatedProp: null,\n      ownerProp: null,\n      modify: null,\n      beforeInsert: null,\n      forbiddenMappingProperties: this.forbiddenMappingProperties,\n      createError: msg => this.createError(msg)\n    };\n\n    ctx = checkForbiddenProperties(ctx);\n    ctx = checkOwnerModelClass(ctx);\n    ctx = checkRelatedModelClass(ctx);\n    ctx = resolveRelatedModelClass(ctx);\n    ctx = checkRelation(ctx);\n    ctx = createJoinProperties(ctx);\n    ctx = parseModify(ctx);\n    ctx = parseBeforeInsert(ctx);\n\n    this.relatedModelClass = ctx.relatedModelClass;\n    this.ownerProp = ctx.ownerProp;\n    this.relatedProp = ctx.relatedProp;\n    this.modify = ctx.modify;\n    this.beforeInsert = ctx.beforeInsert;\n  }\n\n  get forbiddenMappingProperties() {\n    return ['join.through'];\n  }\n\n  get joinTable() {\n    return this.joinTableModelClass ? this.joinTableModelClass.getTableName() : null;\n  }\n\n  get joinModelClass() {\n    return this.getJoinModelClass(this.ownerModelClass.knex());\n  }\n\n  getJoinModelClass(knex) {\n    return this.joinTableModelClass && knex !== this.joinTableModelClass.knex()\n      ? this.joinTableModelClass.bindKnex(knex)\n      : this.joinTableModelClass;\n  }\n\n  isOneToOne() {\n    return false;\n  }\n\n  clone() {\n    const relation = new this.constructor(this.name, this.ownerModelClass);\n\n    relation.relatedModelClass = this.relatedModelClass;\n    relation.ownerProp = this.ownerProp;\n    relation.relatedProp = this.relatedProp;\n    relation.modify = this.modify;\n    relation.beforeInsert = this.beforeInsert;\n\n    relation.joinTableModelClass = this.joinTableModelClass;\n    relation.joinTableOwnerProp = this.joinTableOwnerProp;\n    relation.joinTableRelatedProp = this.joinTableRelatedProp;\n    relation.joinTableBeforeInsert = this.joinTableBeforeInsert;\n    relation.joinTableExtras = this.joinTableExtras;\n\n    return relation;\n  }\n\n  bindKnex(knex) {\n    const bound = this.clone();\n\n    bound.relatedModelClass = this.relatedModelClass.bindKnex(knex);\n    bound.ownerModelClass = this.ownerModelClass.bindKnex(knex);\n\n    if (this.joinTableModelClass) {\n      bound.joinTableModelClass = this.joinTableModelClass.bindKnex(knex);\n    }\n\n    return bound;\n  }\n\n  findQuery(builder, opt) {\n    const relatedRefs = this.relatedProp.refs(builder);\n\n    if (opt.isColumnRef) {\n      for (let i = 0, l = relatedRefs.length; i < l; ++i) {\n        builder.where(relatedRefs[i], ref(opt.ownerIds[i]));\n      }\n    } else if (containsNonNull(opt.ownerIds)) {\n      builder.whereInComposite(relatedRefs, opt.ownerIds);\n    } else {\n      builder.resolve([]);\n    }\n\n    try {\n      return builder.modify(this.modify);\n    } catch (err) {\n      if (err instanceof this.relatedModelClass.ModifierNotFoundError) {\n        throw this.createError(err.message);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  join(\n    builder,\n    {\n      joinOperation = 'join',\n      relatedTableAlias = builder.tableRefFor(this.relatedModelClass.getTableName()),\n      relatedJoinSelectQuery = this.relatedModelClass.query().childQueryOf(builder),\n      relatedTable = builder.tableNameFor(this.relatedModelClass.getTableName()),\n      ownerTable = builder.tableRefFor(this.ownerModelClass.getTableName())\n    } = {}\n  ) {\n    let relatedSelect = relatedJoinSelectQuery.modify(this.modify).as(relatedTableAlias);\n\n    if (relatedSelect.isSelectAll()) {\n      // No need to join a subquery if the query is `select * from \"RelatedTable\"`.\n      relatedSelect = aliasedTableName(relatedTable, relatedTableAlias);\n    }\n\n    return builder[joinOperation](relatedSelect, join => {\n      const relatedProp = this.relatedProp;\n      const ownerProp = this.ownerProp;\n\n      for (let i = 0, l = relatedProp.size; i < l; ++i) {\n        const relatedRef = relatedProp.ref(builder, i).table(relatedTableAlias);\n        const ownerRef = ownerProp.ref(builder, i).table(ownerTable);\n\n        join.on(relatedRef, ownerRef);\n      }\n    });\n  }\n\n  insert(builder, owner) {\n    /* istanbul ignore next */\n    throw this.createError('not implemented');\n  }\n\n  update(builder, owner) {\n    return new RelationUpdateOperation('update', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  patch(builder, owner) {\n    return new RelationUpdateOperation('patch', {\n      relation: this,\n      owner: owner,\n      modelOptions: { patch: true }\n    });\n  }\n\n  find(builder, owners) {\n    return new RelationFindOperation('find', {\n      relation: this,\n      owners: owners\n    });\n  }\n\n  subQuery(builder) {\n    return new RelationSubqueryOperation('subQuery', {\n      relation: this\n    });\n  }\n\n  delete(builder, owner) {\n    return new RelationDeleteOperation('delete', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  relate(builder, owner) {\n    /* istanbul ignore next */\n    throw this.createError('not implemented');\n  }\n\n  unrelate(builder, owner) {\n    /* istanbul ignore next */\n    throw this.createError('not implemented');\n  }\n\n  hasRelateProp(model) {\n    return model.$hasProps(this.relatedProp.props);\n  }\n\n  setRelateProp(model, values) {\n    for (let i = 0, l = this.relatedProp.size; i < l; ++i) {\n      this.relatedProp.setProp(model, i, values[i]);\n    }\n  }\n\n  executeBeforeInsert(models, queryContext, result) {\n    return mapAfterAllReturn(models, model => this.beforeInsert(model, queryContext), result);\n  }\n\n  createError(message) {\n    if (this.ownerModelClass && this.ownerModelClass.name && this.name) {\n      return new Error(`${this.ownerModelClass.name}.relationMappings.${this.name}: ${message}`);\n    } else {\n      return new Error(`${this.constructor.name}: ${message}`);\n    }\n  }\n}\n\nObject.defineProperties(Relation.prototype, {\n  isObjectionRelation: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nfunction checkForbiddenProperties(ctx) {\n  ctx.forbiddenMappingProperties.forEach(prop => {\n    if (get(ctx.mapping, prop.split('.')) !== undefined) {\n      throw ctx.createError(`Property ${prop} is not supported for this relation type.`);\n    }\n  });\n\n  return ctx;\n}\n\nfunction checkOwnerModelClass(ctx) {\n  if (!isSubclassOf(ctx.ownerModelClass, getModel())) {\n    throw ctx.createError(`Relation's owner is not a subclass of Model`);\n  }\n\n  return ctx;\n}\n\nfunction checkRelatedModelClass(ctx) {\n  if (!ctx.mapping.modelClass) {\n    throw ctx.createError('modelClass is not defined');\n  }\n\n  return ctx;\n}\n\nfunction resolveRelatedModelClass(ctx) {\n  let relatedModelClass;\n\n  try {\n    relatedModelClass = resolveModel(\n      ctx.mapping.modelClass,\n      ctx.ownerModelClass.modelPaths,\n      'modelClass'\n    );\n  } catch (err) {\n    throw ctx.createError(err.message);\n  }\n\n  return Object.assign(ctx, { relatedModelClass });\n}\n\nfunction checkRelation(ctx) {\n  if (!ctx.mapping.relation) {\n    throw ctx.createError('relation is not defined');\n  }\n\n  if (!isSubclassOf(ctx.mapping.relation, Relation)) {\n    throw ctx.createError('relation is not a subclass of Relation');\n  }\n\n  return ctx;\n}\n\nfunction createJoinProperties(ctx) {\n  const mapping = ctx.mapping;\n\n  if (!mapping.join || !mapping.join.from || !mapping.join.to) {\n    throw ctx.createError(\n      'join must be an object that maps the columns of the related models together. For example: {from: \"SomeTable.id\", to: \"SomeOtherTable.someModelId\"}'\n    );\n  }\n\n  const fromProp = createRelationProperty(ctx, mapping.join.from, 'join.from');\n  const toProp = createRelationProperty(ctx, mapping.join.to, 'join.to');\n\n  let ownerProp;\n  let relatedProp;\n\n  if (fromProp.modelClass.getTableName() === ctx.ownerModelClass.getTableName()) {\n    ownerProp = fromProp;\n    relatedProp = toProp;\n  } else if (toProp.modelClass.getTableName() === ctx.ownerModelClass.getTableName()) {\n    ownerProp = toProp;\n    relatedProp = fromProp;\n  } else {\n    throw ctx.createError('join: either `from` or `to` must point to the owner model table.');\n  }\n\n  if (ownerProp.props.some(it => it === ctx.name)) {\n    throw ctx.createError(\n      `join: relation name and join property '${\n        ctx.name\n      }' cannot have the same name. If you cannot change one or the other, you can use $parseDatabaseJson and $formatDatabaseJson methods to convert the column name.`\n    );\n  }\n\n  if (relatedProp.modelClass.getTableName() !== ctx.relatedModelClass.getTableName()) {\n    throw ctx.createError('join: either `from` or `to` must point to the related model table.');\n  }\n\n  return Object.assign(ctx, { ownerProp, relatedProp });\n}\n\nfunction createRelationProperty(ctx, refString, propName) {\n  try {\n    return new RelationProperty(refString, table => {\n      return [ctx.ownerModelClass, ctx.relatedModelClass].find(it => it.getTableName() === table);\n    });\n  } catch (err) {\n    if (err instanceof RelationProperty.ModelNotFoundError) {\n      throw ctx.createError(\n        `join: either \\`from\\` or \\`to\\` must point to the owner model table and the other one to the related table. It might be that specified table '${\n          err.tableName\n        }' is not correct`\n      );\n    } else if (err instanceof RelationProperty.InvalidReferenceError) {\n      throw ctx.createError(\n        `${propName} must have format TableName.columnName. For example \"SomeTable.id\" or in case of composite key [\"SomeTable.a\", \"SomeTable.b\"].`\n      );\n    } else {\n      throw err;\n    }\n  }\n}\n\nfunction parseModify(ctx) {\n  const mapping = ctx.mapping;\n  const modifier = mapping.modify || mapping.filter;\n  const modify =\n    modifier &&\n    createModifier({\n      modifier,\n      modelClass: ctx.relatedModelClass\n    });\n\n  return Object.assign(ctx, { modify });\n}\n\nfunction parseBeforeInsert(ctx) {\n  let beforeInsert;\n\n  if (isFunction(ctx.mapping.beforeInsert)) {\n    beforeInsert = ctx.mapping.beforeInsert;\n  } else {\n    beforeInsert = model => model;\n  }\n\n  return Object.assign(ctx, { beforeInsert });\n}\n\nfunction containsNonNull(arr) {\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    const val = arr[i];\n\n    if (Array.isArray(val)) {\n      if (containsNonNull(val)) {\n        return true;\n      }\n    } else if (val !== null && val !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction aliasedTableName(tableName, alias) {\n  if (tableName === alias) {\n    return tableName;\n  } else {\n    return `${tableName} as ${alias}`;\n  }\n}\n\nmodule.exports = {\n  Relation\n};\n","'use strict';\n\nconst { DeleteOperation } = require('../queryBuilder/operations/DeleteOperation');\n\nclass RelationDeleteOperation extends DeleteOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n  }\n\n  onBuild(builder) {\n    super.onBuild(builder);\n\n    this.relation.findQuery(builder, {\n      ownerIds: [this.relation.ownerProp.getProps(this.owner)]\n    });\n  }\n}\n\nmodule.exports = {\n  RelationDeleteOperation\n};\n","'use strict';\n\nconst { FindOperation } = require('../queryBuilder/operations/FindOperation');\nconst { uniqBy } = require('../utils/objectUtils');\n\nclass RelationFindOperation extends FindOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owners = opt.owners;\n    this.alwaysReturnArray = false;\n    this.assignResultToOwner = true;\n    this.relationProperty = opt.relationProperty || this.relation.name;\n    this.omitProps = [];\n  }\n\n  onBuild(builder) {\n    let ids = new Array(this.owners.length);\n\n    for (let i = 0, l = this.owners.length; i < l; ++i) {\n      ids[i] = this.relation.ownerProp.getProps(this.owners[i]);\n    }\n\n    this.relation.findQuery(builder, {\n      ownerIds: uniqBy(ids, join)\n    });\n\n    this.selectMissingJoinColumns(builder);\n  }\n\n  onAfter2(_, related) {\n    const isOneToOne = this.relation.isOneToOne();\n\n    if (this.assignResultToOwner) {\n      const owners = this.owners;\n      const relatedByOwnerId = new Map();\n\n      for (let i = 0, l = related.length; i < l; ++i) {\n        const rel = related[i];\n        const key = this.relation.relatedProp.propKey(rel);\n        let arr = relatedByOwnerId.get(key);\n\n        if (!arr) {\n          arr = [];\n          relatedByOwnerId.set(key, arr);\n        }\n\n        arr.push(rel);\n      }\n\n      for (let i = 0, l = owners.length; i < l; ++i) {\n        const own = owners[i];\n        const key = this.relation.ownerProp.propKey(own);\n        const related = relatedByOwnerId.get(key);\n\n        if (isOneToOne) {\n          own[this.relationProperty] = (related && related[0]) || null;\n        } else {\n          own[this.relationProperty] = related || [];\n        }\n      }\n    }\n\n    return related;\n  }\n\n  onAfter3(builder, related) {\n    const isOneToOne = this.relation.isOneToOne();\n    const intOpt = builder.internalOptions();\n\n    if (!intOpt.keepImplicitJoinProps) {\n      this.omitImplicitJoinProps(related);\n    }\n\n    if (!this.alwaysReturnArray && isOneToOne && related.length <= 1) {\n      related = related[0] || undefined;\n    }\n\n    return super.onAfter3(builder, related);\n  }\n\n  selectMissingJoinColumns(builder) {\n    const relatedProp = this.relation.relatedProp;\n    const addedSelects = [];\n\n    for (let c = 0, lc = relatedProp.size; c < lc; ++c) {\n      const fullCol = relatedProp.ref(builder, c).fullColumn(builder);\n      const prop = relatedProp.props[c];\n      const col = relatedProp.cols[c];\n\n      if (!builder.hasSelectionAs(fullCol, col) && addedSelects.indexOf(fullCol) === -1) {\n        this.omitProps.push(prop);\n        addedSelects.push(fullCol);\n      }\n    }\n\n    if (addedSelects.length) {\n      builder.select(addedSelects);\n    }\n  }\n\n  omitImplicitJoinProps(related) {\n    const relatedModelClass = this.relation.relatedModelClass;\n\n    if (!this.omitProps.length || !related) {\n      return related;\n    }\n\n    if (!Array.isArray(related)) {\n      return this.omitImplicitJoinPropsFromOne(relatedModelClass, related);\n    }\n\n    if (!related.length) {\n      return related;\n    }\n\n    for (let i = 0, l = related.length; i < l; ++i) {\n      this.omitImplicitJoinPropsFromOne(relatedModelClass, related[i]);\n    }\n\n    return related;\n  }\n\n  omitImplicitJoinPropsFromOne(relatedModelClass, model) {\n    for (let c = 0, lc = this.omitProps.length; c < lc; ++c) {\n      relatedModelClass.omitImpl(model, this.omitProps[c]);\n    }\n\n    return model;\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.alwaysReturnArray = this.alwaysReturnArray;\n    clone.assignResultToOwner = this.assignResultToOwner;\n    clone.relationProperty = this.relationProperty;\n    clone.omitProps = this.omitProps.slice();\n\n    return clone;\n  }\n}\n\nfunction join(arr) {\n  return arr.join();\n}\n\nmodule.exports = {\n  RelationFindOperation\n};\n","'use strict';\n\nconst { after } = require('../utils/promiseUtils');\nconst { InsertOperation } = require('../queryBuilder/operations/InsertOperation');\n\nclass RelationInsertOperation extends InsertOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n    this.assignResultToOwner = true;\n  }\n\n  onBefore2(builder, result) {\n    const queryContext = builder.context();\n    const maybePromise = this.relation.executeBeforeInsert(this.models, queryContext, result);\n\n    return after(maybePromise, result => super.onBefore2(builder, result));\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.relation = this.relation;\n    clone.owner = this.owner;\n    clone.assignResultToOwner = this.assignResultToOwner;\n\n    return clone;\n  }\n}\n\nmodule.exports = {\n  RelationInsertOperation\n};\n","'use strict';\n\nconst { asArray, isObject, uniqBy, get, set } = require('../utils/objectUtils');\nconst { ref: createRef } = require('../queryBuilder/ReferenceBuilder');\nconst { propToStr, PROP_KEY_PREFIX } = require('../model/modelValues');\n\nclass ModelNotFoundError extends Error {\n  constructor(tableName) {\n    super();\n    this.name = this.constructor.name;\n    this.tableName = tableName;\n  }\n}\n\nclass InvalidReferenceError extends Error {\n  constructor() {\n    super();\n    this.name = this.constructor.name;\n  }\n}\n\n// A pair of these define how two tables are related to each other.\n// Both the owner and the related table have one of these.\n//\n// A relation property can be a single column, an array of columns\n// (composite key) a json column reference, an array of json column\n// references or any combination of the above.\nclass RelationProperty {\n  // references must be a reference string like `Table.column:maybe.some.json[1].path`.\n  // or an array of such references (composite key).\n  //\n  // modelClassResolver must be a function that takes a table name\n  // and returns a model class.\n  constructor(references, modelClassResolver) {\n    const refs = createRefs(asArray(references));\n    const paths = createPaths(refs, modelClassResolver);\n    const modelClass = resolveModelClass(paths);\n\n    this._refs = refs.map(ref => ref.model(modelClass));\n    this._modelClass = modelClass;\n    this._props = paths.map(it => it.path[0]);\n    this._cols = refs.map(it => it.column);\n    this._propGetters = paths.map(it => createGetter(it.path));\n    this._propSetters = paths.map(it => createSetter(it.path));\n    this._patchers = refs.map(it => createPatcher(it));\n  }\n\n  static get ModelNotFoundError() {\n    return ModelNotFoundError;\n  }\n\n  static get InvalidReferenceError() {\n    return InvalidReferenceError;\n  }\n\n  // The number of columns.\n  get size() {\n    return this._refs.length;\n  }\n\n  // The model class that owns the property.\n  get modelClass() {\n    return this._modelClass;\n  }\n\n  // An array of property names. Contains multiple values in case of composite key.\n  // This may be different from `cols` if the model class has some kind of conversion\n  // between database and \"external\" formats, for example a snake_case to camelCase\n  // conversion.\n  get props() {\n    return this._props;\n  }\n\n  // An array of column names. Contains multiple values in case of composite key.\n  // This may be different from `props` if the model class has some kind of conversion\n  // between database and \"external\" formats, for example a snake_case to camelCase\n  // conversion.\n  get cols() {\n    return this._cols;\n  }\n\n  // Creates a concatenated string from the property values of the given object.\n  propKey(obj) {\n    const size = this.size;\n    let key = PROP_KEY_PREFIX;\n\n    for (let i = 0; i < size; ++i) {\n      key += propToStr(this.getProp(obj, i));\n\n      if (i !== size - 1) {\n        key += ',';\n      }\n    }\n\n    return key;\n  }\n\n  // Returns the property values of the given object as an array.\n  getProps(obj) {\n    const size = this.size;\n    const props = new Array(size);\n\n    for (let i = 0; i < size; ++i) {\n      props[i] = this.getProp(obj, i);\n    }\n\n    return props;\n  }\n\n  // Returns true if the given object has a non-null value in all properties.\n  hasProps(obj) {\n    const size = this.size;\n\n    for (let i = 0; i < size; ++i) {\n      const prop = this.getProp(obj, i);\n\n      if (prop === null || prop === undefined) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Returns the index:th property value of the given object.\n  getProp(obj, index) {\n    return this._propGetters[index](obj);\n  }\n\n  // Sets the index:th property value of the given object.\n  setProp(obj, index, value) {\n    return this._propSetters[index](obj, value);\n  }\n\n  // Returns an instance of ReferenceBuilder that points to the index:th\n  // value of a row.\n  ref(builder, index) {\n    const table = builder.tableRefFor(this.modelClass.getTableName());\n\n    return this._refs[index].clone().table(table);\n  }\n\n  // Returns an array of reference builders. `ref(builder, i)` for each i.\n  refs(builder) {\n    const refs = new Array(this.size);\n\n    for (let i = 0, l = refs.length; i < l; ++i) {\n      refs[i] = this.ref(builder, i);\n    }\n\n    return refs;\n  }\n\n  // Appends an update operation for the index:th column into `patch` object.\n  patch(patch, index, value) {\n    return this._patchers[index](patch, value);\n  }\n\n  // String representation of this property's index:th column for logging.\n  propDescription(index) {\n    return this._refs[index].expression;\n  }\n}\n\nfunction createRefs(refs) {\n  try {\n    return refs.map(it => {\n      if (!isObject(it) || !it.isObjectionReferenceBuilder) {\n        return createRef(it);\n      } else {\n        return it;\n      }\n    });\n  } catch (err) {\n    throw new InvalidReferenceError();\n  }\n}\n\nfunction createPaths(refs, modelClassResolver) {\n  return refs.map(ref => {\n    if (!ref.tableName) {\n      throw new InvalidReferenceError();\n    }\n\n    const modelClass = modelClassResolver(ref.tableName);\n\n    if (!modelClass) {\n      throw new ModelNotFoundError(ref.tableName);\n    }\n\n    const prop = modelClass.columnNameToPropertyName(ref.column);\n    const jsonPath = ref.parsedExpr.access.map(it => it.ref);\n\n    return {\n      path: [prop].concat(jsonPath),\n      modelClass\n    };\n  });\n}\n\nfunction resolveModelClass(paths) {\n  const modelClasses = paths.map(it => it.modelClass);\n  const uniqueModelClasses = uniqBy(modelClasses);\n\n  if (uniqueModelClasses.length !== 1) {\n    throw new InvalidReferenceError();\n  }\n\n  return modelClasses[0];\n}\n\nfunction createGetter(path) {\n  if (path.length === 1) {\n    const prop = path[0];\n    return obj => obj[prop];\n  } else {\n    return obj => get(obj, path);\n  }\n}\n\nfunction createSetter(path) {\n  if (path.length === 1) {\n    const prop = path[0];\n    return (obj, value) => (obj[prop] = value);\n  } else {\n    return (obj, value) => set(obj, path, value);\n  }\n}\n\nfunction createPatcher(ref) {\n  if (ref.isPlainColumnRef) {\n    return (patch, value) => (patch[ref.column] = value);\n  } else {\n    // Objection `patch`, `update` etc. methods understand field expressions.\n    return (patch, value) => (patch[ref.expression] = value);\n  }\n}\n\nmodule.exports = {\n  RelationProperty\n};\n","'use strict';\n\nconst { QueryBuilderOperation } = require('../queryBuilder/operations/QueryBuilderOperation');\n\nclass RelationSubqueryOperation extends QueryBuilderOperation {\n  constructor(name, opt) {\n    super(name, opt);\n    this.relation = opt.relation;\n  }\n\n  onBuild(builder) {\n    return this.relation.findQuery(builder, {\n      isColumnRef: true,\n      ownerIds: this.relation.ownerProp.refs(findFirstNonPartialAncestorQuery(builder))\n    });\n  }\n}\n\nfunction findFirstNonPartialAncestorQuery(builder) {\n  builder = builder.parentQuery();\n\n  while (builder.isPartial()) {\n    if (!builder.parentQuery()) {\n      break;\n    }\n\n    builder = builder.parentQuery();\n  }\n\n  return builder;\n}\n\nmodule.exports = {\n  RelationSubqueryOperation\n};\n","'use strict';\n\nconst { UpdateOperation } = require('../queryBuilder/operations/UpdateOperation');\n\nclass RelationUpdateOperation extends UpdateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n  }\n\n  onBuild(builder) {\n    super.onBuild(builder);\n\n    this.relation.findQuery(builder, {\n      ownerIds: [this.relation.ownerProp.getProps(this.owner)]\n    });\n  }\n}\n\nmodule.exports = {\n  RelationUpdateOperation\n};\n","'use strict';\n\nconst { RelationDeleteOperation } = require('../RelationDeleteOperation');\n\nclass BelongsToOneDeleteOperation extends RelationDeleteOperation {\n  onAfter1(_, result) {\n    const ownerProp = this.relation.ownerProp;\n\n    for (let i = 0, l = ownerProp.size; i < l; ++i) {\n      ownerProp.setProp(this.owner, i, null);\n    }\n\n    return result;\n  }\n}\n\nmodule.exports = {\n  BelongsToOneDeleteOperation\n};\n","'use strict';\n\nconst { RelationInsertOperation } = require('../RelationInsertOperation');\nconst { after } = require('../../utils/promiseUtils');\n\nclass BelongsToOneInsertOperation extends RelationInsertOperation {\n  onAdd(builder, args) {\n    const retVal = super.onAdd(builder, args);\n\n    if (this.models.length > 1) {\n      throw this.relation.createError('can only insert one model to a BelongsToOneRelation');\n    }\n\n    return retVal;\n  }\n\n  onAfter1(builder, ret) {\n    const maybePromise = super.onAfter1(builder, ret);\n    const owner = this.owner;\n\n    const ownerProp = this.relation.ownerProp;\n    const relatedProp = this.relation.relatedProp;\n\n    return after(maybePromise, inserted => {\n      const patch = {};\n\n      for (let i = 0, l = ownerProp.size; i < l; ++i) {\n        const relatedValue = relatedProp.getProp(inserted[0], i);\n\n        ownerProp.setProp(this.owner, i, relatedValue);\n        ownerProp.patch(patch, i, relatedValue);\n      }\n\n      if (this.assignResultToOwner) {\n        owner.$setRelated(this.relation, inserted);\n      }\n\n      return this.owner\n        .$query()\n        .childQueryOf(builder)\n        .patch(patch)\n        .then(() => inserted);\n    });\n  }\n}\n\nmodule.exports = {\n  BelongsToOneInsertOperation\n};\n","'use strict';\n\nconst { normalizeIds } = require('../../utils/normalizeIds');\nconst { RelateOperation } = require('../../queryBuilder/operations/RelateOperation');\n\nclass BelongsToOneRelateOperation extends RelateOperation {\n  onAdd(_, args) {\n    this.input = args[0];\n    this.ids = normalizeIds(args[0], this.relation.relatedProp, { arrayOutput: true });\n\n    if (this.ids.length > 1) {\n      throw this.relation.createError('can only relate one model to a BelongsToOneRelation');\n    }\n\n    return true;\n  }\n\n  queryExecutor(builder) {\n    const patch = {};\n    const ownerProp = this.relation.ownerProp;\n\n    for (let i = 0, l = ownerProp.size; i < l; ++i) {\n      const relatedValue = this.ids[0][i];\n\n      ownerProp.setProp(this.owner, i, relatedValue);\n      ownerProp.patch(patch, i, relatedValue);\n    }\n\n    return this.relation.ownerModelClass\n      .query()\n      .childQueryOf(builder)\n      .copyFrom(builder, builder.constructor.JoinSelector)\n      .copyFrom(builder, builder.constructor.WhereSelector)\n      .patch(patch)\n      .findById(this.owner.$id());\n  }\n}\n\nmodule.exports = {\n  BelongsToOneRelateOperation\n};\n","'use strict';\n\nconst { Relation } = require('../Relation');\nconst { BelongsToOneInsertOperation } = require('./BelongsToOneInsertOperation');\nconst { BelongsToOneDeleteOperation } = require('./BelongsToOneDeleteOperation');\nconst { BelongsToOneRelateOperation } = require('./BelongsToOneRelateOperation');\nconst { BelongsToOneUnrelateOperation } = require('./BelongsToOneUnrelateOperation');\n\nclass BelongsToOneRelation extends Relation {\n  isOneToOne() {\n    return true;\n  }\n\n  insert(builder, owner) {\n    return new BelongsToOneInsertOperation('insert', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  delete(builder, owner) {\n    return new BelongsToOneDeleteOperation('delete', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  relate(builder, owner) {\n    return new BelongsToOneRelateOperation('relate', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  unrelate(builder, owner) {\n    return new BelongsToOneUnrelateOperation('unrelate', {\n      relation: this,\n      owner: owner\n    });\n  }\n}\n\nObject.defineProperties(BelongsToOneRelation.prototype, {\n  isObjectionBelongsToOneRelation: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nmodule.exports = {\n  BelongsToOneRelation\n};\n","'use strict';\n\nconst { UnrelateOperation } = require('../../queryBuilder/operations/UnrelateOperation');\n\nclass BelongsToOneUnrelateOperation extends UnrelateOperation {\n  onAdd() {\n    const ids = new Array(this.relation.ownerProp.size);\n\n    for (let i = 0, l = this.relation.ownerProp.size; i < l; ++i) {\n      ids[i] = null;\n    }\n\n    this.ids = [ids];\n    return true;\n  }\n\n  queryExecutor(builder) {\n    const patch = {};\n    const ownerProp = this.relation.ownerProp;\n\n    for (let i = 0, l = ownerProp.size; i < l; ++i) {\n      const relatedValue = this.ids[0][i];\n\n      ownerProp.setProp(this.owner, i, relatedValue);\n      ownerProp.patch(patch, i, relatedValue);\n    }\n\n    return this.relation.ownerModelClass\n      .query()\n      .childQueryOf(builder)\n      .copyFrom(builder, builder.constructor.JoinSelector)\n      .copyFrom(builder, builder.constructor.WhereSelector)\n      .patch(patch)\n      .findById(this.owner.$id());\n  }\n}\n\nmodule.exports = {\n  BelongsToOneUnrelateOperation\n};\n","'use strict';\n\nconst { RelationInsertOperation } = require('../RelationInsertOperation');\nconst { after } = require('../../utils/promiseUtils');\n\nclass HasManyInsertOperation extends RelationInsertOperation {\n  onAdd(builder, args) {\n    const retVal = super.onAdd(builder, args);\n    const ownerProp = this.relation.ownerProp;\n    const relatedProp = this.relation.relatedProp;\n\n    for (let i = 0, lm = this.models.length; i < lm; ++i) {\n      const model = this.models[i];\n\n      for (let j = 0, lp = relatedProp.size; j < lp; ++j) {\n        relatedProp.setProp(model, j, ownerProp.getProp(this.owner, j));\n      }\n    }\n\n    return retVal;\n  }\n\n  onAfter1(builder, ret) {\n    const maybePromise = super.onAfter1(builder, ret);\n\n    if (!this.assignResultToOwner) {\n      return maybePromise;\n    }\n\n    return after(maybePromise, inserted => {\n      this.owner.$appendRelated(this.relation, inserted);\n      return inserted;\n    });\n  }\n}\n\nmodule.exports = {\n  HasManyInsertOperation\n};\n","'use strict';\n\nconst { normalizeIds } = require('../../utils/normalizeIds');\nconst { RelateOperation } = require('../../queryBuilder/operations/RelateOperation');\n\nclass HasManyRelateOperation extends RelateOperation {\n  onAdd(_, args) {\n    this.input = args[0];\n    this.ids = normalizeIds(args[0], this.relation.relatedModelClass.getIdRelationProperty(), {\n      arrayOutput: true\n    });\n    return true;\n  }\n\n  queryExecutor(builder) {\n    const patch = {};\n    const ownerProp = this.relation.ownerProp;\n    const relatedProp = this.relation.relatedProp;\n\n    for (let i = 0, l = relatedProp.size; i < l; ++i) {\n      relatedProp.patch(patch, i, ownerProp.getProp(this.owner, i));\n    }\n\n    return this.relation.relatedModelClass\n      .query()\n      .childQueryOf(builder)\n      .patch(patch)\n      .copyFrom(builder, builder.constructor.JoinSelector)\n      .copyFrom(builder, builder.constructor.WhereSelector)\n      .findByIds(this.ids)\n      .modify(this.relation.modify);\n  }\n}\n\nmodule.exports = {\n  HasManyRelateOperation\n};\n","'use strict';\n\nconst { Relation } = require('../Relation');\nconst { HasManyInsertOperation } = require('./HasManyInsertOperation');\nconst { HasManyRelateOperation } = require('./HasManyRelateOperation');\nconst { HasManyUnrelateOperation } = require('./HasManyUnrelateOperation');\n\nclass HasManyRelation extends Relation {\n  insert(_, owner) {\n    return new HasManyInsertOperation('insert', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  relate(_, owner) {\n    return new HasManyRelateOperation('relate', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  unrelate(_, owner) {\n    return new HasManyUnrelateOperation('unrelate', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  hasRelateProp(model) {\n    return model.$hasId();\n  }\n\n  setRelateProp(model, values) {\n    model.$id(values);\n  }\n}\n\nObject.defineProperties(HasManyRelation.prototype, {\n  isObjectionHasManyRelation: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nmodule.exports = {\n  HasManyRelation\n};\n","'use strict';\n\nconst { UnrelateOperation } = require('../../queryBuilder/operations/UnrelateOperation');\n\nclass HasManyUnrelateOperation extends UnrelateOperation {\n  queryExecutor(builder) {\n    const patch = {};\n    const ownerProp = this.relation.ownerProp;\n    const relatedProp = this.relation.relatedProp;\n    const ownerValues = ownerProp.getProps(this.owner);\n    const relatedRefs = relatedProp.refs(builder);\n\n    for (let i = 0, l = relatedProp.size; i < l; ++i) {\n      relatedProp.patch(patch, i, null);\n    }\n\n    return this.relation.relatedModelClass\n      .query()\n      .childQueryOf(builder)\n      .patch(patch)\n      .copyFrom(builder, builder.constructor.JoinSelector)\n      .copyFrom(builder, builder.constructor.WhereSelector)\n      .whereComposite(relatedRefs, ownerValues)\n      .modify(this.relation.modify);\n  }\n}\n\nmodule.exports = {\n  HasManyUnrelateOperation\n};\n","'use strict';\n\nconst { HasManyRelation } = require('../hasMany/HasManyRelation');\n\nclass HasOneRelation extends HasManyRelation {\n  isOneToOne() {\n    return true;\n  }\n}\n\nmodule.exports = {\n  HasOneRelation\n};\n","'use strict';\n\nconst { ManyToManyRelation } = require('../manyToMany/ManyToManyRelation');\n\nclass HasOneThroughRelation extends ManyToManyRelation {\n  isOneToOne() {\n    return true;\n  }\n}\n\nmodule.exports = {\n  HasOneThroughRelation\n};\n","'use strict';\n\n// This mixin contains the shared code for all modify operations (update, delete, relate, unrelate)\n// for ManyToManyRelation operations.\n//\n// The most important thing this mixin does is that it moves the filters from the main query\n// into a subquery and then adds a single where clause that uses the subquery. This is done so\n// that we are able to `innerJoin` the join table to the query. Most SQL engines don't allow\n// joins in updates or deletes. Join table is joined so that queries can reference the join\n// table columns.\nconst ManyToManyModifyMixin = Operation => {\n  return class extends Operation {\n    constructor(...args) {\n      super(...args);\n      this.modifyFilterSubquery = null;\n    }\n\n    get modifyMainQuery() {\n      return true;\n    }\n\n    // At this point `builder` should only have the user's own wheres and joins. There can\n    // be other operations (like orderBy) too, but those are meaningless with modify operations.\n    onBuild(builder) {\n      this.modifyFilterSubquery = this.createModifyFilterSubquery(builder);\n\n      if (this.modifyMainQuery) {\n        // We can now remove the where and join statements from the main query.\n        this.removeFiltersFromMainQuery(builder);\n\n        // Add a single where clause that uses the created subquery.\n        this.applyModifyFilterForRelatedTable(builder);\n      }\n\n      return super.onBuild(builder);\n    }\n\n    createModifyFilterSubquery(builder) {\n      const relatedModelClass = this.relation.relatedModelClass;\n      const builderClass = builder.constructor;\n      const ownerProp = this.relation.ownerProp;\n      const ownerIds = [ownerProp.getProps(this.owner)];\n\n      // Create an empty subquery.\n      const modifyFilterSubquery = relatedModelClass.query().childQueryOf(builder);\n\n      // Add the necessary joins and wheres so that only rows related to\n      // `this.owner` are selected.\n      this.relation.findQuery(modifyFilterSubquery, { ownerIds });\n\n      // Copy all where and join statements from the main query to the subquery.\n      modifyFilterSubquery\n        .copyFrom(builder, builderClass.WhereSelector)\n        .copyFrom(builder, builderClass.JoinSelector);\n\n      return modifyFilterSubquery.clearSelect();\n    }\n\n    removeFiltersFromMainQuery(builder) {\n      const builderClass = builder.constructor;\n\n      builder.clear(builderClass.WhereSelector);\n      builder.clear(builderClass.JoinSelector);\n    }\n\n    applyModifyFilterForRelatedTable(builder) {\n      const idRefs = this.relation.relatedModelClass.getIdRelationProperty().refs(builder);\n      const subquery = this.modifyFilterSubquery.clone().select(idRefs);\n\n      return builder.whereInComposite(idRefs, subquery);\n    }\n\n    applyModifyFilterForJoinTable(builder) {\n      const joinTableOwnerRefs = this.relation.joinTableOwnerProp.refs(builder);\n      const joinTableRelatedRefs = this.relation.joinTableRelatedProp.refs(builder);\n\n      const relatedRefs = this.relation.relatedProp.refs(builder);\n      const ownerIds = this.relation.ownerProp.getProps(this.owner);\n\n      const subquery = this.modifyFilterSubquery.clone().select(relatedRefs);\n\n      return builder\n        .whereInComposite(joinTableRelatedRefs, subquery)\n        .whereComposite(joinTableOwnerRefs, ownerIds);\n    }\n\n    clone() {\n      const clone = super.clone();\n      clone.modifyFilterSubquery = this.modifyFilterSubquery;\n      return clone;\n    }\n  };\n};\n\nmodule.exports = {\n  ManyToManyModifyMixin\n};\n","'use strict';\n\nconst { ManyToManyModifyMixin } = require('./ManyToManyModifyMixin');\n\n// We need to override this mixin for mysql because mysql doesn't\n// allow referencing the updated/deleted table directly in a subquery.\n// We need to wrap the subquery into yet another subquery (sigh).\nconst ManyToManyMySqlModifyMixin = Operation => {\n  return class extends ManyToManyModifyMixin(Operation) {\n    createModifyFilterSubquery(builder) {\n      const modifyFilterSubquery = super.createModifyFilterSubquery(builder);\n      return this.wrapIntoYetAnotherSubquery(builder, modifyFilterSubquery);\n    }\n\n    wrapIntoYetAnotherSubquery(builder, modifyFilterSubquery) {\n      const relatedModelClass = this.relation.relatedModelClass;\n      const tableRef = builder.tableRefFor(relatedModelClass.getTableName());\n\n      return relatedModelClass\n        .query()\n        .childQueryOf(builder)\n        .from(modifyFilterSubquery.as(tableRef));\n    }\n  };\n};\n\nmodule.exports = {\n  ManyToManyMySqlModifyMixin\n};\n","'use strict';\n\nconst getModel = () => require('../../model/Model').Model;\nconst { Relation } = require('../Relation');\nconst { RelationProperty } = require('../RelationProperty');\n\nconst { ref } = require('../../queryBuilder/ReferenceBuilder');\nconst { isSqlite, isMySql } = require('../../utils/knexUtils');\nconst { inheritModel } = require('../../model/inheritModel');\nconst { resolveModel } = require('../../utils/resolveModel');\nconst { mapAfterAllReturn } = require('../../utils/promiseUtils');\nconst { isFunction, isObject } = require('../../utils/objectUtils');\n\nconst { ManyToManyFindOperation } = require('./find/ManyToManyFindOperation');\nconst { ManyToManyInsertOperation } = require('./insert/ManyToManyInsertOperation');\nconst { ManyToManyRelateOperation } = require('./relate/ManyToManyRelateOperation');\n\nconst { ManyToManyUnrelateOperation } = require('./unrelate/ManyToManyUnrelateOperation');\nconst { ManyToManyUnrelateMySqlOperation } = require('./unrelate/ManyToManyUnrelateMySqlOperation');\nconst {\n  ManyToManyUnrelateSqliteOperation\n} = require('./unrelate/ManyToManyUnrelateSqliteOperation');\n\nconst { ManyToManyUpdateOperation } = require('./update/ManyToManyUpdateOperation');\nconst { ManyToManyUpdateMySqlOperation } = require('./update/ManyToManyUpdateMySqlOperation');\nconst { ManyToManyUpdateSqliteOperation } = require('./update/ManyToManyUpdateSqliteOperation');\n\nconst { ManyToManyDeleteOperation } = require('./delete/ManyToManyDeleteOperation');\nconst { ManyToManyDeleteMySqlOperation } = require('./delete/ManyToManyDeleteMySqlOperation');\nconst { ManyToManyDeleteSqliteOperation } = require('./delete/ManyToManyDeleteSqliteOperation');\n\nclass ManyToManyRelation extends Relation {\n  setMapping(mapping) {\n    const retVal = super.setMapping(mapping);\n\n    let ctx = {\n      mapping,\n      ownerModelClass: this.ownerModelClass,\n      relatedModelClass: this.relatedModelClass,\n      ownerProp: this.ownerProp,\n      relatedProp: this.relatedProp,\n\n      joinTableModelClass: null,\n      joinTableOwnerProp: null,\n      joinTableRelatedProp: null,\n      joinTableBeforeInsert: null,\n      joinTableExtras: [],\n\n      createError: msg => this.createError(msg)\n    };\n\n    ctx = checkThroughObject(ctx);\n    ctx = resolveJoinModelClassIfDefined(ctx);\n    ctx = createJoinProperties(ctx);\n    ctx = parseExtras(ctx);\n    ctx = parseBeforeInsert(ctx);\n    ctx = finalizeJoinModelClass(ctx);\n\n    this.joinTableExtras = ctx.joinTableExtras;\n    this.joinTableModelClass = ctx.joinTableModelClass;\n    this.joinTableOwnerProp = ctx.joinTableOwnerProp;\n    this.joinTableRelatedProp = ctx.joinTableRelatedProp;\n    this.joinTableBeforeInsert = ctx.joinTableBeforeInsert;\n\n    return retVal;\n  }\n\n  get forbiddenMappingProperties() {\n    return [];\n  }\n\n  findQuery(builder, opt) {\n    const joinTableOwnerRefs = this.joinTableOwnerProp.refs(builder);\n    const joinTable = builder.tableNameFor(this.joinTable);\n    const joinTableAlias = builder.tableRefFor(this.joinTable);\n\n    builder.join(aliasedTableName(joinTable, joinTableAlias), join => {\n      for (let i = 0, l = this.relatedProp.size; i < l; ++i) {\n        const relatedRef = this.relatedProp.ref(builder, i);\n        const joinTableRelatedRef = this.joinTableRelatedProp.ref(builder, i);\n\n        join.on(relatedRef, joinTableRelatedRef);\n      }\n    });\n\n    if (opt.isColumnRef) {\n      for (let i = 0, l = joinTableOwnerRefs.length; i < l; ++i) {\n        builder.where(joinTableOwnerRefs[i], ref(opt.ownerIds[i]));\n      }\n    } else if (containsNonNull(opt.ownerIds)) {\n      builder.whereInComposite(joinTableOwnerRefs, opt.ownerIds);\n    } else {\n      builder.resolve([]);\n    }\n\n    return builder.modify(this.modify);\n  }\n\n  join(\n    builder,\n    {\n      joinOperation = defaultJoinOperation(this, builder),\n      relatedTableAlias = defaultRelatedTablealias(this, builder),\n      relatedJoinSelectQuery = defaultRelatedJoinSelectQuery(this, builder),\n      relatedTable = defaultRelatedTable(this, builder),\n      ownerTable = defaultOwnerTable(this, builder),\n      joinTableAlias = defaultJoinTableAlias(this, relatedTableAlias, builder)\n    } = {}\n  ) {\n    let relatedJoinSelect = relatedJoinSelectQuery.modify(this.modify).as(relatedTableAlias);\n\n    if (relatedJoinSelect.isSelectAll()) {\n      // No need to join a subquery if the query is `select * from \"RelatedTable\"`.\n      relatedJoinSelect = aliasedTableName(relatedTable, relatedTableAlias);\n    }\n\n    return builder[joinOperation](aliasedTableName(this.joinTable, joinTableAlias), join => {\n      const ownerProp = this.ownerProp;\n      const joinTableOwnerProp = this.joinTableOwnerProp;\n\n      for (let i = 0, l = ownerProp.size; i < l; ++i) {\n        const joinTableOwnerRef = joinTableOwnerProp.ref(builder, i).table(joinTableAlias);\n        const ownerRef = ownerProp.ref(builder, i).table(ownerTable);\n\n        join.on(joinTableOwnerRef, ownerRef);\n      }\n    })[joinOperation](relatedJoinSelect, join => {\n      const relatedProp = this.relatedProp;\n      const joinTableRelatedProp = this.joinTableRelatedProp;\n\n      for (let i = 0, l = relatedProp.size; i < l; ++i) {\n        const joinTableRelatedRef = joinTableRelatedProp.ref(builder, i).table(joinTableAlias);\n        const relatedRef = relatedProp.ref(builder, i).table(relatedTableAlias);\n\n        join.on(joinTableRelatedRef, relatedRef);\n      }\n    });\n  }\n\n  find(builder, owners) {\n    return new ManyToManyFindOperation('find', {\n      relation: this,\n      owners: owners\n    });\n  }\n\n  insert(builder, owner) {\n    return new ManyToManyInsertOperation('insert', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  update(builder, owner) {\n    if (isSqlite(builder.knex())) {\n      return new ManyToManyUpdateSqliteOperation('update', {\n        relation: this,\n        owner: owner\n      });\n    } else if (isMySql(builder.knex())) {\n      return new ManyToManyUpdateMySqlOperation('update', {\n        relation: this,\n        owner: owner\n      });\n    } else {\n      return new ManyToManyUpdateOperation('update', {\n        relation: this,\n        owner: owner\n      });\n    }\n  }\n\n  patch(builder, owner) {\n    if (isSqlite(builder.knex())) {\n      return new ManyToManyUpdateSqliteOperation('patch', {\n        modelOptions: { patch: true },\n        relation: this,\n        owner: owner\n      });\n    } else if (isMySql(builder.knex())) {\n      return new ManyToManyUpdateMySqlOperation('patch', {\n        modelOptions: { patch: true },\n        relation: this,\n        owner: owner\n      });\n    } else {\n      return new ManyToManyUpdateOperation('patch', {\n        modelOptions: { patch: true },\n        relation: this,\n        owner: owner\n      });\n    }\n  }\n\n  delete(builder, owner) {\n    if (isSqlite(builder.knex())) {\n      return new ManyToManyDeleteSqliteOperation('delete', {\n        relation: this,\n        owner: owner\n      });\n    } else if (isMySql(builder.knex())) {\n      return new ManyToManyDeleteMySqlOperation('delete', {\n        relation: this,\n        owner: owner\n      });\n    } else {\n      return new ManyToManyDeleteOperation('delete', {\n        relation: this,\n        owner: owner\n      });\n    }\n  }\n\n  relate(builder, owner) {\n    return new ManyToManyRelateOperation('relate', {\n      relation: this,\n      owner: owner\n    });\n  }\n\n  unrelate(builder, owner) {\n    if (isSqlite(builder.knex())) {\n      return new ManyToManyUnrelateSqliteOperation('unrelate', {\n        relation: this,\n        owner: owner\n      });\n    } else if (isMySql(builder.knex())) {\n      return new ManyToManyUnrelateMySqlOperation('unrelate', {\n        relation: this,\n        owner: owner\n      });\n    } else {\n      return new ManyToManyUnrelateOperation('unrelate', {\n        relation: this,\n        owner: owner\n      });\n    }\n  }\n\n  createJoinModels(ownerId, related) {\n    const joinModels = new Array(related.length);\n\n    for (let i = 0, lr = related.length; i < lr; ++i) {\n      joinModels[i] = this.createJoinModel(ownerId, related[i]);\n    }\n\n    return joinModels;\n  }\n\n  createJoinModel(ownerId, rel) {\n    let joinModel = {};\n\n    for (let j = 0, lp = this.joinTableOwnerProp.size; j < lp; ++j) {\n      this.joinTableOwnerProp.setProp(joinModel, j, ownerId[j]);\n    }\n\n    for (let j = 0, lp = this.joinTableRelatedProp.size; j < lp; ++j) {\n      const value = this.relatedProp.getProp(rel, j);\n\n      if (value !== undefined) {\n        this.joinTableRelatedProp.setProp(joinModel, j, value);\n      }\n    }\n\n    for (const extra of this.joinTableExtras) {\n      let extraValue = rel[extra.aliasProp];\n\n      if (extraValue === undefined && rel.$$queryProps) {\n        extraValue = rel.$$queryProps[extra.aliasProp];\n      }\n\n      if (extraValue !== undefined) {\n        joinModel[extra.joinTableProp] = extraValue;\n      }\n    }\n\n    return joinModel;\n  }\n\n  omitExtraProps(models) {\n    if (this.joinTableExtras && this.joinTableExtras.length) {\n      const props = this.joinTableExtras.map(extra => extra.aliasProp);\n\n      for (const model of models) {\n        // Omit extra properties instead of deleting them from the models so that they can\n        // be used in the `$before` and `$after` hooks.\n        model.$omitFromDatabaseJson(props);\n      }\n    }\n  }\n\n  executeJoinTableBeforeInsert(models, queryContext, result) {\n    return mapAfterAllReturn(\n      models,\n      model => this.joinTableBeforeInsert(model, queryContext),\n      result\n    );\n  }\n}\n\nObject.defineProperties(ManyToManyRelation.prototype, {\n  isObjectionManyToManyRelation: {\n    enumerable: false,\n    writable: false,\n    value: true\n  }\n});\n\nfunction defaultJoinOperation() {\n  return 'join';\n}\n\nfunction defaultRelatedTablealias(relation, builder) {\n  return builder.tableRefFor(relation.relatedModelClass.getTableName());\n}\n\nfunction defaultRelatedJoinSelectQuery(relation, builder) {\n  return relation.relatedModelClass.query().childQueryOf(builder);\n}\n\nfunction defaultRelatedTable(relation, builder) {\n  return builder.tableNameFor(relation.relatedModelClass.getTableName());\n}\n\nfunction defaultOwnerTable(relation, builder) {\n  return builder.tableRefFor(relation.ownerModelClass.getTableName());\n}\n\nfunction defaultJoinTableAlias(relation, relatedTableAlias, builder) {\n  const alias = builder.tableRefFor(relation.joinTable);\n\n  if (alias === relation.joinTable) {\n    return relation.ownerModelClass.joinTableAlias(relatedTableAlias);\n  } else {\n    return alias;\n  }\n}\n\nfunction aliasedTableName(tableName, alias) {\n  if (tableName === alias) {\n    return tableName;\n  } else {\n    return `${tableName} as ${alias}`;\n  }\n}\n\nfunction checkThroughObject(ctx) {\n  const mapping = ctx.mapping;\n\n  if (!isObject(mapping.join.through)) {\n    throw ctx.createError('join must have a `through` object that describes the join table.');\n  }\n\n  if (!mapping.join.through.from || !mapping.join.through.to) {\n    throw ctx.createError(\n      'join.through must be an object that describes the join table. For example: {from: \"JoinTable.someId\", to: \"JoinTable.someOtherId\"}'\n    );\n  }\n\n  return ctx;\n}\n\nfunction resolveJoinModelClassIfDefined(ctx) {\n  let joinTableModelClass = null;\n\n  if (ctx.mapping.join.through.modelClass) {\n    try {\n      joinTableModelClass = resolveModel(\n        ctx.mapping.join.through.modelClass,\n        ctx.ownerModelClass.modelPaths,\n        'join.through.modelClass'\n      );\n    } catch (err) {\n      throw ctx.createError(err.message);\n    }\n  }\n\n  return Object.assign(ctx, { joinTableModelClass });\n}\n\nfunction createJoinProperties(ctx) {\n  let ret;\n\n  let fromProp;\n  let toProp;\n\n  let relatedProp;\n  let ownerProp;\n\n  ret = createRelationProperty(ctx, ctx.mapping.join.through.from, 'join.through.from');\n  fromProp = ret.prop;\n  ctx = ret.ctx;\n\n  ret = createRelationProperty(ctx, ctx.mapping.join.through.to, 'join.through.to');\n  toProp = ret.prop;\n  ctx = ret.ctx;\n\n  if (fromProp.modelClass.getTableName() !== toProp.modelClass.getTableName()) {\n    throw ctx.createError('join.through `from` and `to` must point to the same join table.');\n  }\n\n  if (ctx.relatedProp.modelClass.getTableName() === fromProp.modelClass.getTableName()) {\n    relatedProp = fromProp;\n    ownerProp = toProp;\n  } else {\n    relatedProp = toProp;\n    ownerProp = fromProp;\n  }\n\n  return Object.assign(ctx, {\n    joinTableOwnerProp: ownerProp,\n    joinTableRelatedProp: relatedProp\n  });\n}\n\nfunction createRelationProperty(ctx, refString, messagePrefix) {\n  let prop = null;\n  let joinTableModelClass = ctx.joinTableModelClass;\n\n  const resolveModelClass = table => {\n    if (joinTableModelClass === null) {\n      joinTableModelClass = inheritModel(getModel());\n      joinTableModelClass.tableName = table;\n      joinTableModelClass.idColumn = null;\n      joinTableModelClass.concurrency = ctx.ownerModelClass.concurrency;\n    }\n\n    if (joinTableModelClass.getTableName() === table) {\n      return joinTableModelClass;\n    } else {\n      return null;\n    }\n  };\n\n  try {\n    prop = new RelationProperty(refString, resolveModelClass);\n  } catch (err) {\n    if (err instanceof RelationProperty.ModelNotFoundError) {\n      throw ctx.createError('join.through `from` and `to` must point to the same join table.');\n    } else {\n      throw ctx.createError(\n        `${messagePrefix} must have format JoinTable.columnName. For example \"JoinTable.someId\" or in case of composite key [\"JoinTable.a\", \"JoinTable.b\"].`\n      );\n    }\n  }\n\n  return {\n    ctx: Object.assign(ctx, { joinTableModelClass }),\n    prop\n  };\n}\n\nfunction parseExtras(ctx) {\n  let extraDef = ctx.mapping.join.through.extra;\n\n  if (!extraDef) {\n    return ctx;\n  }\n\n  if (Array.isArray(extraDef)) {\n    extraDef = extraDef.reduce((extraDef, col) => {\n      extraDef[col] = col;\n      return extraDef;\n    }, {});\n  }\n\n  const joinTableExtras = Object.keys(extraDef).map(key => {\n    const val = extraDef[key];\n\n    return {\n      joinTableCol: val,\n      joinTableProp: ctx.joinTableModelClass.columnNameToPropertyName(val),\n      aliasCol: key,\n      aliasProp: ctx.joinTableModelClass.columnNameToPropertyName(key)\n    };\n  });\n\n  return Object.assign(ctx, { joinTableExtras });\n}\n\nfunction parseBeforeInsert(ctx) {\n  let joinTableBeforeInsert;\n\n  if (isFunction(ctx.mapping.join.through.beforeInsert)) {\n    joinTableBeforeInsert = ctx.mapping.join.through.beforeInsert;\n  } else {\n    joinTableBeforeInsert = model => model;\n  }\n\n  return Object.assign(ctx, { joinTableBeforeInsert });\n}\n\nfunction finalizeJoinModelClass(ctx) {\n  if (ctx.joinTableModelClass.getIdColumn() === null) {\n    // We cannot know if the join table has a primary key. Therefore we set some\n    // known column as the idColumn so that inserts will work.\n    ctx.joinTableModelClass.idColumn = ctx.joinTableRelatedProp.cols;\n  }\n\n  return ctx;\n}\n\nfunction containsNonNull(arr) {\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    const val = arr[i];\n\n    if (Array.isArray(val) && containsNonNull(val)) {\n      return true;\n    } else if (val !== null && val !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  ManyToManyRelation\n};\n","'use strict';\n\nconst { ManyToManyModifyMixin } = require('./ManyToManyModifyMixin');\nconst SQLITE_BUILTIN_ROW_ID = '_rowid_';\n\n// We need to override this mixin for sqlite because sqlite doesn't support\n// multi-column where in statements with subqueries. We need to use the\n// internal _rowid_ column instead.\nconst ManyToManySqliteModifyMixin = Operation => {\n  return class extends ManyToManyModifyMixin(Operation) {\n    applyModifyFilterForRelatedTable(builder) {\n      const tableRef = builder.tableRefFor(this.relation.relatedModelClass.getTableName());\n      const rowIdRef = `${tableRef}.${SQLITE_BUILTIN_ROW_ID}`;\n      const subquery = this.modifyFilterSubquery.clone().select(rowIdRef);\n\n      return builder.whereInComposite(rowIdRef, subquery);\n    }\n\n    applyModifyFilterForJoinTable(builder) {\n      const joinTableOwnerRefs = this.relation.joinTableOwnerProp.refs(builder);\n      const tableRef = builder.tableRefFor(this.relation.getJoinModelClass(builder).getTableName());\n      const rowIdRef = `${tableRef}.${SQLITE_BUILTIN_ROW_ID}`;\n\n      const ownerIds = this.relation.ownerProp.getProps(this.owner);\n      const subquery = this.modifyFilterSubquery.clone().select(rowIdRef);\n\n      return builder\n        .whereInComposite(rowIdRef, subquery)\n        .whereComposite(joinTableOwnerRefs, ownerIds);\n    }\n  };\n};\n\nmodule.exports = {\n  ManyToManySqliteModifyMixin\n};\n","'use strict';\n\nconst { ManyToManyDeleteOperationBase } = require('./ManyToManyDeleteOperationBase');\nconst { ManyToManyMySqlModifyMixin } = require('../ManyToManyMySqlModifyMixin');\n\nclass ManyToManyDeleteMySqlOperation extends ManyToManyMySqlModifyMixin(\n  ManyToManyDeleteOperationBase\n) {}\n\nmodule.exports = {\n  ManyToManyDeleteMySqlOperation\n};\n","'use strict';\n\nconst { ManyToManyDeleteOperationBase } = require('./ManyToManyDeleteOperationBase');\nconst { ManyToManyModifyMixin } = require('../ManyToManyModifyMixin');\n\nclass ManyToManyDeleteOperation extends ManyToManyModifyMixin(ManyToManyDeleteOperationBase) {}\n\nmodule.exports = {\n  ManyToManyDeleteOperation\n};\n","'use strict';\n\nconst { DeleteOperation } = require('../../../queryBuilder/operations/DeleteOperation');\n\nclass ManyToManyDeleteOperationBase extends DeleteOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n  }\n\n  /* istanbul ignore next */\n  applyModifyFilterForRelatedTable(builder) {\n    throw new Error('not implemented');\n  }\n\n  /* istanbul ignore next */\n  applyModifyFilterForJoinTable(builder) {\n    throw new Error('not implemented');\n  }\n}\n\nmodule.exports = {\n  ManyToManyDeleteOperationBase\n};\n","'use strict';\n\nconst { ManyToManyDeleteOperationBase } = require('./ManyToManyDeleteOperationBase');\nconst { ManyToManySqliteModifyMixin } = require('../ManyToManySqliteModifyMixin');\n\nclass ManyToManyDeleteSqliteOperation extends ManyToManySqliteModifyMixin(\n  ManyToManyDeleteOperationBase\n) {}\n\nmodule.exports = {\n  ManyToManyDeleteSqliteOperation\n};\n","'use strict';\n\nconst { RelationFindOperation } = require('../../RelationFindOperation');\nconst { getTempColumn } = require('../../../utils/tmpColumnUtils');\nconst { uniqBy } = require('../../../utils/objectUtils');\n\nclass ManyToManyFindOperation extends RelationFindOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.ownerJoinColumnAlias = new Array(this.relation.joinTableOwnerProp.size);\n\n    for (let i = 0, l = this.ownerJoinColumnAlias.length; i < l; ++i) {\n      this.ownerJoinColumnAlias[i] = getTempColumn(i);\n    }\n  }\n\n  onBuild(builder) {\n    const relatedModelClass = this.relation.relatedModelClass;\n    const joinTableOwnerProp = this.relation.joinTableOwnerProp;\n    const ownerProp = this.relation.ownerProp;\n    const ids = this.owners.map(owner => ownerProp.getProps(owner));\n\n    this.relation.findQuery(builder, {\n      ownerIds: uniqBy(ids, join)\n    });\n\n    if (!builder.has(builder.constructor.SelectSelector)) {\n      const table = builder.tableRefFor(relatedModelClass.getTableName());\n\n      // If the user hasn't specified a select clause, select the related model's columns.\n      // If we don't do this we also get the join table's columns.\n      builder.select(`${table}.*`);\n\n      // Also select all extra columns.\n      for (const extra of this.relation.joinTableExtras) {\n        const joinTable = builder.tableRefFor(this.relation.joinTable);\n        builder.select(`${joinTable}.${extra.joinTableCol} as ${extra.aliasCol}`);\n      }\n    }\n\n    // We must select the owner join columns so that we know for which owner model the related\n    // models belong to after the requests.\n    for (let i = 0, l = joinTableOwnerProp.size; i < l; ++i) {\n      const joinTableOwnerRef = joinTableOwnerProp.ref(builder, i);\n      const propName = relatedModelClass.columnNameToPropertyName(this.ownerJoinColumnAlias[i]);\n\n      builder.select(joinTableOwnerRef.as(this.ownerJoinColumnAlias[i]));\n      // Mark them to be omitted later.\n      this.omitProps.push(propName);\n    }\n\n    this.selectMissingJoinColumns(builder);\n  }\n\n  onAfter2(_, related) {\n    const isOneToOne = this.relation.isOneToOne();\n\n    if (this.assignResultToOwner) {\n      const ownerProp = this.relation.ownerProp;\n      const relatedByOwnerId = new Map();\n\n      for (let i = 0, l = related.length; i < l; ++i) {\n        const rel = related[i];\n        const key = rel.$propKey(this.ownerJoinColumnAlias);\n        let arr = relatedByOwnerId.get(key);\n\n        if (!arr) {\n          arr = [];\n          relatedByOwnerId.set(key, arr);\n        }\n\n        arr.push(rel);\n      }\n\n      for (let i = 0, l = this.owners.length; i < l; ++i) {\n        const own = this.owners[i];\n        const key = ownerProp.propKey(own);\n        const related = relatedByOwnerId.get(key);\n\n        if (isOneToOne) {\n          own[this.relationProperty] = (related && related[0]) || null;\n        } else {\n          own[this.relationProperty] = related || [];\n        }\n      }\n    }\n\n    return related;\n  }\n\n  clone() {\n    const clone = super.clone();\n    clone.ownerJoinColumnAlias = this.ownerJoinColumnAlias.slice();\n    return clone;\n  }\n}\n\nfunction join(arr) {\n  return arr.join();\n}\n\nmodule.exports = {\n  ManyToManyFindOperation\n};\n","'use strict';\n\nconst { RelationInsertOperation } = require('../../RelationInsertOperation');\nconst { after } = require('../../../utils/promiseUtils');\n\nclass ManyToManyInsertOperation extends RelationInsertOperation {\n  onAdd(builder, args) {\n    const retVal = super.onAdd(builder, args);\n    this.relation.omitExtraProps(this.models);\n    return retVal;\n  }\n\n  onAfter1(builder, ret) {\n    const maybePromise = super.onAfter1(builder, ret);\n    const owner = this.owner;\n\n    return after(maybePromise, inserted => {\n      const ownerId = this.relation.ownerProp.getProps(owner);\n      const joinModelClass = this.relation.getJoinModelClass(builder.knex());\n\n      const joinModels = this.relation.createJoinModels(\n        ownerId,\n        inserted.filter(it => this.relation.relatedProp.hasProps(it))\n      );\n\n      for (let i = 0, l = joinModels.length; i < l; ++i) {\n        joinModels[i] = joinModelClass.fromJson(joinModels[i]);\n      }\n\n      if (this.assignResultToOwner) {\n        owner.$appendRelated(this.relation, inserted);\n      }\n\n      if (joinModels.length === 0) {\n        return inserted;\n      }\n\n      // Insert the join rows to the join table.\n      return joinModelClass\n        .query()\n        .childQueryOf(builder)\n        .runBefore((_, builder) =>\n          this.relation.executeJoinTableBeforeInsert(joinModels, builder.context(), null)\n        )\n        .insert(joinModels)\n        .then(() => inserted);\n    });\n  }\n}\n\nmodule.exports = {\n  ManyToManyInsertOperation\n};\n","'use strict';\n\nconst { normalizeIds } = require('../../../utils/normalizeIds');\nconst { RelateOperation } = require('../../../queryBuilder/operations/RelateOperation');\n\nclass ManyToManyRelateOperation extends RelateOperation {\n  onAdd(_, args) {\n    this.input = args[0];\n    this.ids = normalizeIds(args[0], this.relation.relatedProp);\n    return true;\n  }\n\n  queryExecutor(builder) {\n    const ownerId = this.relation.ownerProp.getProps(this.owner);\n    const joinModelClass = this.relation.getJoinModelClass(builder.knex());\n\n    const joinModels = this.relation\n      .createJoinModels(ownerId, this.ids)\n      .map(it => joinModelClass.fromJson(it));\n\n    return joinModelClass\n      .query()\n      .childQueryOf(builder)\n      .runBefore((_, builder) =>\n        this.relation.executeJoinTableBeforeInsert(joinModels, builder.context(), null)\n      )\n      .insert(joinModels)\n      .copyFrom(builder, /returning/)\n      .runAfter(models => {\n        if (Array.isArray(this.input)) {\n          return models;\n        } else {\n          return models[0];\n        }\n      });\n  }\n}\n\nmodule.exports = {\n  ManyToManyRelateOperation\n};\n","'use strict';\n\nconst { ManyToManyUnrelateOperationBase } = require('./ManyToManyUnrelateOperationBase');\nconst { ManyToManyMySqlModifyMixin } = require('../ManyToManyMySqlModifyMixin');\n\nclass ManyToManyUnrelateMySqlOperation extends ManyToManyMySqlModifyMixin(\n  ManyToManyUnrelateOperationBase\n) {\n  get modifyMainQuery() {\n    return false;\n  }\n}\n\nmodule.exports = {\n  ManyToManyUnrelateMySqlOperation\n};\n","'use strict';\n\nconst { ManyToManyUnrelateOperationBase } = require('./ManyToManyUnrelateOperationBase');\nconst { ManyToManyModifyMixin } = require('../ManyToManyModifyMixin');\n\nclass ManyToManyUnrelateOperation extends ManyToManyModifyMixin(ManyToManyUnrelateOperationBase) {\n  get modifyMainQuery() {\n    return false;\n  }\n}\n\nmodule.exports = {\n  ManyToManyUnrelateOperation\n};\n","'use strict';\n\nconst { UnrelateOperation } = require('../../../queryBuilder/operations/UnrelateOperation');\n\nclass ManyToManyUnrelateOperationBase extends UnrelateOperation {\n  queryExecutor(builder) {\n    const unrelateQuery = this.relation\n      .getJoinModelClass(builder.knex())\n      .query()\n      .childQueryOf(builder)\n      .delete();\n\n    return this.applyModifyFilterForJoinTable(unrelateQuery);\n  }\n\n  /* istanbul ignore next */\n  applyModifyFilterForRelatedTable(builder) {\n    throw new Error('not implemented');\n  }\n\n  /* istanbul ignore next */\n  applyModifyFilterForJoinTable(builder) {\n    throw new Error('not implemented');\n  }\n}\n\nmodule.exports = {\n  ManyToManyUnrelateOperationBase\n};\n","'use strict';\n\nconst { ManyToManyUnrelateOperationBase } = require('./ManyToManyUnrelateOperationBase');\nconst { ManyToManySqliteModifyMixin } = require('../ManyToManySqliteModifyMixin');\n\nclass ManyToManyUnrelateSqliteOperation extends ManyToManySqliteModifyMixin(\n  ManyToManyUnrelateOperationBase\n) {\n  get modifyMainQuery() {\n    return false;\n  }\n}\n\nmodule.exports = {\n  ManyToManyUnrelateSqliteOperation\n};\n","'use strict';\n\nconst { ManyToManyUpdateOperationBase } = require('./ManyToManyUpdateOperationBase');\nconst { ManyToManyMySqlModifyMixin } = require('../ManyToManyMySqlModifyMixin');\n\nclass ManyToManyUpdateMySqlOperation extends ManyToManyMySqlModifyMixin(\n  ManyToManyUpdateOperationBase\n) {}\n\nmodule.exports = {\n  ManyToManyUpdateMySqlOperation\n};\n","'use strict';\n\nconst { ManyToManyUpdateOperationBase } = require('./ManyToManyUpdateOperationBase');\nconst { ManyToManyModifyMixin } = require('../ManyToManyModifyMixin');\n\nclass ManyToManyUpdateOperation extends ManyToManyModifyMixin(ManyToManyUpdateOperationBase) {}\n\nmodule.exports = {\n  ManyToManyUpdateOperation\n};\n","'use strict';\n\nconst { UpdateOperation } = require('../../../queryBuilder/operations/UpdateOperation');\n\nclass ManyToManyUpdateOperationBase extends UpdateOperation {\n  constructor(name, opt) {\n    super(name, opt);\n\n    this.relation = opt.relation;\n    this.owner = opt.owner;\n\n    this.hasExtraProps = false;\n    this.joinTablePatch = {};\n    this.joinTablePatchFilterQuery = null;\n  }\n\n  onAdd(builder, args) {\n    const obj = args[0];\n\n    // Copy all extra properties to the `joinTablePatch` object.\n    for (const extra of this.relation.joinTableExtras) {\n      if (extra.aliasProp in obj) {\n        this.hasExtraProps = true;\n        this.joinTablePatch[extra.joinTableProp] = obj[extra.aliasProp];\n      }\n    }\n\n    const res = super.onAdd(builder, args);\n\n    if (this.hasExtraProps) {\n      // Make sure we don't try to insert the extra properties\n      // to the target table.\n      this.relation.omitExtraProps([this.model]);\n    }\n\n    return res;\n  }\n\n  onAfter1(builder, result) {\n    if (this.hasExtraProps) {\n      const joinTableUpdateQuery = this.relation\n        .getJoinModelClass(builder.knex())\n        .query()\n        .childQueryOf(builder)\n        .patch(this.joinTablePatch);\n\n      return this.applyModifyFilterForJoinTable(joinTableUpdateQuery).return(result);\n    } else {\n      return result;\n    }\n  }\n\n  /* istanbul ignore next */\n  applyModifyFilterForRelatedTable(builder) {\n    throw new Error('not implemented');\n  }\n\n  /* istanbul ignore next */\n  applyModifyFilterForJoinTable(builder) {\n    throw new Error('not implemented');\n  }\n\n  clone() {\n    const clone = super.clone();\n\n    clone.hasExtraProps = this.hasExtraProps;\n    clone.joinTablePatch = this.joinTablePatch;\n    clone.joinTablePatchFilterQuery = this.joinTablePatchFilterQuery;\n\n    return clone;\n  }\n}\n\nmodule.exports = {\n  ManyToManyUpdateOperationBase\n};\n","'use strict';\n\nconst { ManyToManyUpdateOperationBase } = require('./ManyToManyUpdateOperationBase');\nconst { ManyToManySqliteModifyMixin } = require('../ManyToManySqliteModifyMixin');\n\nclass ManyToManyUpdateSqliteOperation extends ManyToManySqliteModifyMixin(\n  ManyToManyUpdateOperationBase\n) {}\n\nmodule.exports = {\n  ManyToManyUpdateSqliteOperation\n};\n","'use strict';\n\nconst Bluebird = require('bluebird');\nconst { Model } = require('./model/Model');\nconst promiseUtils = require('./utils/promiseUtils');\nconst { isSubclassOf } = require('./utils/classUtils');\nconst { isFunction } = require('./utils/objectUtils');\n\nfunction transaction() {\n  // There must be at least one model class and the callback.\n  if (arguments.length < 2) {\n    return Bluebird.reject(\n      new Error(\n        'objection.transaction: provide at least one Model class to bind to the transaction or a knex instance'\n      )\n    );\n  }\n\n  let args = Array.from(arguments);\n\n  if (!isSubclassOf(args[0], Model) && isFunction(args[0].transaction)) {\n    let knex = args[0];\n    args = args.slice(1);\n\n    // If the function is a generator, wrap it using Bluebird.coroutine.\n    if (isGenerator(args[0])) {\n      args[0] = Bluebird.coroutine(args[0]);\n    }\n\n    return knex.transaction.apply(knex, args);\n  } else {\n    // The last argument should be the callback and all other Model subclasses.\n    let callback = args[args.length - 1];\n    let modelClasses = args.slice(0, args.length - 1);\n    let i;\n\n    for (i = 0; i < modelClasses.length; ++i) {\n      if (!isSubclassOf(modelClasses[i], Model)) {\n        return Bluebird.reject(\n          new Error('objection.transaction: all but the last argument should be Model subclasses')\n        );\n      }\n    }\n\n    let knex = modelClasses[0].knex();\n    for (i = 0; i < modelClasses.length; ++i) {\n      if (modelClasses[i].knex() !== knex) {\n        return Bluebird.reject(\n          new Error(\n            'objection.transaction: all Model subclasses must be bound to the same database'\n          )\n        );\n      }\n    }\n\n    // If the function is a generator, wrap it using Promise.coroutine.\n    if (isGenerator(callback)) {\n      callback = Bluebird.coroutine(callback);\n    }\n\n    return knex.transaction(trx => {\n      let args = new Array(modelClasses.length + 1);\n\n      for (let i = 0; i < modelClasses.length; ++i) {\n        args[i] = modelClasses[i].bindTransaction(trx);\n      }\n\n      args[args.length - 1] = trx;\n\n      return promiseUtils.try(() => {\n        return callback.apply(trx, args);\n      });\n    });\n  }\n}\n\ntransaction.start = function(modelClassOrKnex) {\n  let knex = modelClassOrKnex;\n\n  if (isSubclassOf(modelClassOrKnex, Model)) {\n    knex = modelClassOrKnex.knex();\n  }\n\n  if (!knex || !isFunction(knex.transaction)) {\n    return Bluebird.reject(\n      new Error(\n        'objection.transaction.start: first argument must be a model class or a knex instance'\n      )\n    );\n  }\n\n  return new Bluebird((resolve, reject) => {\n    knex\n      .transaction(trx => {\n        resolve(trx);\n      })\n      .catch(err => {\n        reject(err);\n      });\n  });\n};\n\nfunction isGenerator(fn) {\n  return fn && fn.constructor && fn.constructor.name === 'GeneratorFunction';\n}\n\nmodule.exports = {\n  transaction\n};\n","var map = {\n\t\"./assert\": \"../node_modules/objection/lib/utils/assert.js\",\n\t\"./assert.js\": \"../node_modules/objection/lib/utils/assert.js\",\n\t\"./buildUtils\": \"../node_modules/objection/lib/utils/buildUtils.js\",\n\t\"./buildUtils.js\": \"../node_modules/objection/lib/utils/buildUtils.js\",\n\t\"./classUtils\": \"../node_modules/objection/lib/utils/classUtils.js\",\n\t\"./classUtils.js\": \"../node_modules/objection/lib/utils/classUtils.js\",\n\t\"./clone\": \"../node_modules/objection/lib/utils/clone.js\",\n\t\"./clone.js\": \"../node_modules/objection/lib/utils/clone.js\",\n\t\"./createModifier\": \"../node_modules/objection/lib/utils/createModifier.js\",\n\t\"./createModifier.js\": \"../node_modules/objection/lib/utils/createModifier.js\",\n\t\"./deprecate\": \"../node_modules/objection/lib/utils/deprecate.js\",\n\t\"./deprecate.js\": \"../node_modules/objection/lib/utils/deprecate.js\",\n\t\"./identifierMapping\": \"../node_modules/objection/lib/utils/identifierMapping.js\",\n\t\"./identifierMapping.js\": \"../node_modules/objection/lib/utils/identifierMapping.js\",\n\t\"./internalPropUtils\": \"../node_modules/objection/lib/utils/internalPropUtils.js\",\n\t\"./internalPropUtils.js\": \"../node_modules/objection/lib/utils/internalPropUtils.js\",\n\t\"./knexUtils\": \"../node_modules/objection/lib/utils/knexUtils.js\",\n\t\"./knexUtils.js\": \"../node_modules/objection/lib/utils/knexUtils.js\",\n\t\"./mixin\": \"../node_modules/objection/lib/utils/mixin.js\",\n\t\"./mixin.js\": \"../node_modules/objection/lib/utils/mixin.js\",\n\t\"./normalizeIds\": \"../node_modules/objection/lib/utils/normalizeIds.js\",\n\t\"./normalizeIds.js\": \"../node_modules/objection/lib/utils/normalizeIds.js\",\n\t\"./objectUtils\": \"../node_modules/objection/lib/utils/objectUtils.js\",\n\t\"./objectUtils.js\": \"../node_modules/objection/lib/utils/objectUtils.js\",\n\t\"./parseFieldExpression\": \"../node_modules/objection/lib/utils/parseFieldExpression.js\",\n\t\"./parseFieldExpression.js\": \"../node_modules/objection/lib/utils/parseFieldExpression.js\",\n\t\"./promiseUtils\": \"../node_modules/objection/lib/utils/promiseUtils/index.js\",\n\t\"./promiseUtils/\": \"../node_modules/objection/lib/utils/promiseUtils/index.js\",\n\t\"./promiseUtils/after\": \"../node_modules/objection/lib/utils/promiseUtils/after.js\",\n\t\"./promiseUtils/after.js\": \"../node_modules/objection/lib/utils/promiseUtils/after.js\",\n\t\"./promiseUtils/afterReturn\": \"../node_modules/objection/lib/utils/promiseUtils/afterReturn.js\",\n\t\"./promiseUtils/afterReturn.js\": \"../node_modules/objection/lib/utils/promiseUtils/afterReturn.js\",\n\t\"./promiseUtils/index\": \"../node_modules/objection/lib/utils/promiseUtils/index.js\",\n\t\"./promiseUtils/index.js\": \"../node_modules/objection/lib/utils/promiseUtils/index.js\",\n\t\"./promiseUtils/isPromise\": \"../node_modules/objection/lib/utils/promiseUtils/isPromise.js\",\n\t\"./promiseUtils/isPromise.js\": \"../node_modules/objection/lib/utils/promiseUtils/isPromise.js\",\n\t\"./promiseUtils/map\": \"../node_modules/objection/lib/utils/promiseUtils/map.js\",\n\t\"./promiseUtils/map.js\": \"../node_modules/objection/lib/utils/promiseUtils/map.js\",\n\t\"./promiseUtils/mapAfterAllReturn\": \"../node_modules/objection/lib/utils/promiseUtils/mapAfterAllReturn.js\",\n\t\"./promiseUtils/mapAfterAllReturn.js\": \"../node_modules/objection/lib/utils/promiseUtils/mapAfterAllReturn.js\",\n\t\"./promiseUtils/try\": \"../node_modules/objection/lib/utils/promiseUtils/try.js\",\n\t\"./promiseUtils/try.js\": \"../node_modules/objection/lib/utils/promiseUtils/try.js\",\n\t\"./resolveModel\": \"../node_modules/objection/lib/utils/resolveModel.js\",\n\t\"./resolveModel.js\": \"../node_modules/objection/lib/utils/resolveModel.js\",\n\t\"./tmpColumnUtils\": \"../node_modules/objection/lib/utils/tmpColumnUtils.js\",\n\t\"./tmpColumnUtils.js\": \"../node_modules/objection/lib/utils/tmpColumnUtils.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"../node_modules/objection/lib/utils sync recursive ^.*$\";","'use strict';\n\nfunction assertHasId(model) {\n  if (!model.$hasId()) {\n    const modelClass = model.constructor;\n    const ids = modelClass.getIdColumnArray().join(', ');\n\n    throw new Error(\n      `one of the identifier columns [${ids}] is null or undefined. Have you specified the correct identifier column for the model '${\n        modelClass.name\n      }' using the 'idColumn' property?`\n    );\n  }\n}\n\nmodule.exports = {\n  assertHasId\n};\n","'use strict';\n\nconst { isObject, isFunction } = require('./objectUtils');\n\nfunction buildArg(arg, builder) {\n  if (!isObject(arg)) {\n    return arg;\n  }\n\n  if (isFunction(arg.toKnexRaw)) {\n    return arg.toKnexRaw(builder);\n  } else if (arg.isObjectionQueryBuilderBase === true) {\n    return arg.subqueryOf(builder).toKnexQuery();\n  } else {\n    return arg;\n  }\n}\n\nmodule.exports = {\n  buildArg\n};\n","'use strict';\n\nconst { isFunction } = require('./objectUtils');\n\nfunction isSubclassOf(Constructor, SuperConstructor) {\n  if (!isFunction(SuperConstructor)) {\n    return false;\n  }\n\n  while (isFunction(Constructor)) {\n    if (Constructor === SuperConstructor) {\n      return true;\n    }\n\n    Constructor = Object.getPrototypeOf(Constructor);\n  }\n\n  return false;\n}\n\nfunction inherit(Constructor, BaseConstructor) {\n  Constructor.prototype = Object.create(BaseConstructor.prototype);\n  Constructor.prototype.constructor = BaseConstructor;\n  Object.setPrototypeOf(Constructor, BaseConstructor);\n\n  return Constructor;\n}\n\nmodule.exports = {\n  isSubclassOf,\n  inherit\n};\n","'use strict';\n\n/**\n * @license\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash include=\"cloneDeep,clone\" exports=\"node\" --development`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n(function() {\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.5';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991;\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[\n    int8Tag\n  ] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[\n    uint8Tag\n  ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[\n    uint32Tag\n  ] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[\n    arrayBufferTag\n  ] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[\n    dateTag\n  ] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[\n    numberTag\n  ] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[\n    setTag\n  ] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[\n    dataViewTag\n  ] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[\n    float64Tag\n  ] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[\n    mapTag\n  ] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[\n    regexpTag\n  ] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[\n    uint8Tag\n  ] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  })();\n\n  /* Node.js helper references. */\n  var nodeIsMap = nodeUtil && nodeUtil.isMap,\n    nodeIsSet = nodeUtil && nodeUtil.isSet,\n    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n      length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n      length = values.length,\n      offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n      result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = root['__core-js_shared__'];\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function() {\n    var uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '');\n    return uid ? 'Symbol(src)_1.' + uid : '';\n  })();\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto.toString;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp(\n    '^' +\n      funcToString\n        .call(hasOwnProperty)\n        .replace(reRegExpChar, '\\\\$&')\n        .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') +\n      '$'\n  );\n\n  /** Built-in value references. */\n  var Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n  var defineProperty = (function() {\n    try {\n      var func = getNative(Object, 'defineProperty');\n      func({}, '', {});\n      return func;\n    } catch (e) {}\n  })();\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n  /* Built-in method references that are verified to be native. */\n  var DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n  /** Used to lookup unminified function names. */\n  var realNames = {};\n\n  /** Used to detect maps, sets, and weakmaps. */\n  var dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a `lodash` object which wraps `value` to enable implicit method\n   * chain sequences. Methods that operate on and return arrays, collections,\n   * and functions can be chained together. Methods that retrieve a single value\n   * or may return a primitive value will automatically end the chain sequence\n   * and return the unwrapped value. Otherwise, the value must be unwrapped\n   * with `_#value`.\n   *\n   * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n   * enabled using `_.chain`.\n   *\n   * The execution of chained methods is lazy, that is, it's deferred until\n   * `_#value` is implicitly or explicitly called.\n   *\n   * Lazy evaluation allows several methods to support shortcut fusion.\n   * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n   * the creation of intermediate arrays and can greatly reduce the number of\n   * iteratee executions. Sections of a chain sequence qualify for shortcut\n   * fusion if the section is applied to an array and iteratees accept only\n   * one argument. The heuristic for whether a section qualifies for shortcut\n   * fusion is subject to change.\n   *\n   * Chaining is supported in custom builds as long as the `_#value` method is\n   * directly or indirectly included in the build.\n   *\n   * In addition to lodash methods, wrappers have `Array` and `String` methods.\n   *\n   * The wrapper `Array` methods are:\n   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n   *\n   * The wrapper `String` methods are:\n   * `replace` and `split`\n   *\n   * The wrapper methods that support shortcut fusion are:\n   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n   *\n   * The chainable wrapper methods are:\n   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n   * `zipObject`, `zipObjectDeep`, and `zipWith`\n   *\n   * The wrapper methods that are **not** chainable by default are:\n   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n   * `upperFirst`, `value`, and `words`\n   *\n   * @name _\n   * @constructor\n   * @category Seq\n   * @param {*} value The value to wrap in a `lodash` instance.\n   * @returns {Object} Returns the new `lodash` wrapper instance.\n   * @example\n   *\n   * function square(n) {\n   *   return n * n;\n   * }\n   *\n   * var wrapped = _([1, 2, 3]);\n   *\n   * // Returns an unwrapped value.\n   * wrapped.reduce(_.add);\n   * // => 6\n   *\n   * // Returns a wrapped value.\n   * var squares = wrapped.map(square);\n   *\n   * _.isArray(squares);\n   * // => false\n   *\n   * _.isArray(squares.value());\n   * // => true\n   */\n  function lodash() {\n    // No operation performed.\n  }\n\n  /**\n   * The base implementation of `_.create` without support for assigning\n   * properties to the created object.\n   *\n   * @private\n   * @param {Object} proto The object to inherit from.\n   * @returns {Object} Returns the new object.\n   */\n  var baseCreate = (function() {\n    function object() {}\n    return function(proto) {\n      if (!isObject(proto)) {\n        return {};\n      }\n      if (objectCreate) {\n        return objectCreate(proto);\n      }\n      object.prototype = proto;\n      var result = new object();\n      object.prototype = undefined;\n      return result;\n    };\n  })();\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    this.size = 0;\n  }\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__;\n    if (nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED ? undefined : result;\n    }\n    return hasOwnProperty.call(data, key) ? data[key] : undefined;\n  }\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__;\n    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n  }\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n    return this;\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = hashClear;\n  Hash.prototype['delete'] = hashDelete;\n  Hash.prototype.get = hashGet;\n  Hash.prototype.has = hashHas;\n  Hash.prototype.set = hashSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n  }\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return assocIndexOf(this.__data__, key) > -1;\n  }\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = listCacheClear;\n  ListCache.prototype['delete'] = listCacheDelete;\n  ListCache.prototype.get = listCacheGet;\n  ListCache.prototype.has = listCacheHas;\n  ListCache.prototype.set = listCacheSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      hash: new Hash(),\n      map: new (Map || ListCache)(),\n      string: new Hash()\n    };\n  }\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    var result = getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return getMapData(this, key).get(key);\n  }\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return getMapData(this, key).has(key);\n  }\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    var data = getMapData(this, key),\n      size = data.size;\n\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = mapCacheClear;\n  MapCache.prototype['delete'] = mapCacheDelete;\n  MapCache.prototype.get = mapCacheGet;\n  MapCache.prototype.has = mapCacheHas;\n  MapCache.prototype.set = mapCacheSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a stack cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Stack(entries) {\n    var data = (this.__data__ = new ListCache(entries));\n    this.size = data.size;\n  }\n\n  /**\n   * Removes all key-value entries from the stack.\n   *\n   * @private\n   * @name clear\n   * @memberOf Stack\n   */\n  function stackClear() {\n    this.__data__ = new ListCache();\n    this.size = 0;\n  }\n\n  /**\n   * Removes `key` and its value from the stack.\n   *\n   * @private\n   * @name delete\n   * @memberOf Stack\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function stackDelete(key) {\n    var data = this.__data__,\n      result = data['delete'](key);\n\n    this.size = data.size;\n    return result;\n  }\n\n  /**\n   * Gets the stack value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Stack\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function stackGet(key) {\n    return this.__data__.get(key);\n  }\n\n  /**\n   * Checks if a stack value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Stack\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function stackHas(key) {\n    return this.__data__.has(key);\n  }\n\n  /**\n   * Sets the stack `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Stack\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the stack cache instance.\n   */\n  function stackSet(key, value) {\n    var data = this.__data__;\n    if (data instanceof ListCache) {\n      var pairs = data.__data__;\n      if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n        pairs.push([key, value]);\n        this.size = ++data.size;\n        return this;\n      }\n      data = this.__data__ = new MapCache(pairs);\n    }\n    data.set(key, value);\n    this.size = data.size;\n    return this;\n  }\n\n  // Add methods to `Stack`.\n  Stack.prototype.clear = stackClear;\n  Stack.prototype['delete'] = stackDelete;\n  Stack.prototype.get = stackGet;\n  Stack.prototype.has = stackHas;\n  Stack.prototype.set = stackSet;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an array of the enumerable property names of the array-like `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @param {boolean} inherited Specify returning inherited property names.\n   * @returns {Array} Returns the array of property names.\n   */\n  function arrayLikeKeys(value, inherited) {\n    var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n    for (var key in value) {\n      if (\n        (inherited || hasOwnProperty.call(value, key)) &&\n        !(\n          skipIndexes &&\n          // Safari 9 has enumerable `arguments.length` in strict mode.\n          (key == 'length' ||\n            // Node.js 0.10 has enumerable non-index properties on buffers.\n            (isBuff && (key == 'offset' || key == 'parent')) ||\n            // PhantomJS 2 has enumerable non-index properties on typed arrays.\n            (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n            // Skip index properties.\n            isIndex(key, length))\n        )\n      ) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (\n      !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))\n    ) {\n      baseAssignValue(object, key, value);\n    }\n  }\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.assign` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssign(object, source) {\n    return object && copyObject(source, keys(source), object);\n  }\n\n  /**\n   * The base implementation of `_.assignIn` without support for multiple sources\n   * or `customizer` functions.\n   *\n   * @private\n   * @param {Object} object The destination object.\n   * @param {Object} source The source object.\n   * @returns {Object} Returns `object`.\n   */\n  function baseAssignIn(object, source) {\n    return object && copyObject(source, keysIn(source), object);\n  }\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && defineProperty) {\n      defineProperty(object, key, {\n        configurable: true,\n        enumerable: true,\n        value: value,\n        writable: true\n      });\n    } else {\n      object[key] = value;\n    }\n  }\n\n  /**\n   * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n   * traversed objects.\n   *\n   * @private\n   * @param {*} value The value to clone.\n   * @param {boolean} bitmask The bitmask flags.\n   *  1 - Deep clone\n   *  2 - Flatten inherited properties\n   *  4 - Clone symbols\n   * @param {Function} [customizer] The function to customize cloning.\n   * @param {string} [key] The key of `value`.\n   * @param {Object} [object] The parent object of `value`.\n   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n   * @returns {*} Returns the cloned value.\n   */\n  function baseClone(value, bitmask, customizer, key, object, stack) {\n    var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n    if (customizer) {\n      result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n    if (result !== undefined) {\n      return result;\n    }\n    if (!isObject(value)) {\n      return value;\n    }\n    var isArr = isArray(value);\n    if (isArr) {\n      result = initCloneArray(value);\n      if (!isDeep) {\n        return copyArray(value, result);\n      }\n    } else {\n      var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n      if (isBuffer(value)) {\n        return cloneBuffer(value, isDeep);\n      }\n      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n        result = isFlat || isFunc ? {} : initCloneObject(value);\n        if (!isDeep) {\n          return isFlat\n            ? copySymbolsIn(value, baseAssignIn(result, value))\n            : copySymbols(value, baseAssign(result, value));\n        }\n      } else {\n        if (!cloneableTags[tag]) {\n          return object ? value : {};\n        }\n        result = initCloneByTag(value, tag, isDeep);\n      }\n    }\n    // Check for circular references and return its corresponding clone.\n    stack || (stack = new Stack());\n    var stacked = stack.get(value);\n    if (stacked) {\n      return stacked;\n    }\n    stack.set(value, result);\n\n    if (isSet(value)) {\n      value.forEach(function(subValue) {\n        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n      });\n\n      return result;\n    }\n\n    if (isMap(value)) {\n      value.forEach(function(subValue, key) {\n        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n\n      return result;\n    }\n\n    var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys;\n\n    var props = isArr ? undefined : keysFunc(value);\n    arrayEach(props || value, function(subValue, key) {\n      if (props) {\n        key = subValue;\n        subValue = value[key];\n      }\n      // Recursively populate clone (susceptible to call stack limits).\n      assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n   * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Function} keysFunc The function to get the keys of `object`.\n   * @param {Function} symbolsFunc The function to get the symbols of `object`.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n    var result = keysFunc(object);\n    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n  }\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return symToStringTag && symToStringTag in Object(value)\n      ? getRawTag(value)\n      : objectToString(value);\n  }\n\n  /**\n   * The base implementation of `_.isArguments`.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   */\n  function baseIsArguments(value) {\n    return isObjectLike(value) && baseGetTag(value) == argsTag;\n  }\n\n  /**\n   * The base implementation of `_.isMap` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   */\n  function baseIsMap(value) {\n    return isObjectLike(value) && getTag(value) == mapTag;\n  }\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject(value) || isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(toSource(value));\n  }\n\n  /**\n   * The base implementation of `_.isSet` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   */\n  function baseIsSet(value) {\n    return isObjectLike(value) && getTag(value) == setTag;\n  }\n\n  /**\n   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   */\n  function baseIsTypedArray(value) {\n    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n  }\n\n  /**\n   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeys(object) {\n    if (!isPrototype(object)) {\n      return nativeKeys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n      if (hasOwnProperty.call(object, key) && key != 'constructor') {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function baseKeysIn(object) {\n    if (!isObject(object)) {\n      return nativeKeysIn(object);\n    }\n    var isProto = isPrototype(object),\n      result = [];\n\n    for (var key in object) {\n      if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates a clone of  `buffer`.\n   *\n   * @private\n   * @param {Buffer} buffer The buffer to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Buffer} Returns the cloned buffer.\n   */\n  function cloneBuffer(buffer, isDeep) {\n    if (isDeep) {\n      return buffer.slice();\n    }\n    var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n    buffer.copy(result);\n    return result;\n  }\n\n  /**\n   * Creates a clone of `arrayBuffer`.\n   *\n   * @private\n   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n   * @returns {ArrayBuffer} Returns the cloned array buffer.\n   */\n  function cloneArrayBuffer(arrayBuffer) {\n    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n  }\n\n  /**\n   * Creates a clone of `dataView`.\n   *\n   * @private\n   * @param {Object} dataView The data view to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned data view.\n   */\n  function cloneDataView(dataView, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n  }\n\n  /**\n   * Creates a clone of `regexp`.\n   *\n   * @private\n   * @param {Object} regexp The regexp to clone.\n   * @returns {Object} Returns the cloned regexp.\n   */\n  function cloneRegExp(regexp) {\n    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n  }\n\n  /**\n   * Creates a clone of the `symbol` object.\n   *\n   * @private\n   * @param {Object} symbol The symbol object to clone.\n   * @returns {Object} Returns the cloned symbol object.\n   */\n  function cloneSymbol(symbol) {\n    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n  }\n\n  /**\n   * Creates a clone of `typedArray`.\n   *\n   * @private\n   * @param {Object} typedArray The typed array to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the cloned typed array.\n   */\n  function cloneTypedArray(typedArray, isDeep) {\n    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n  }\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n      length = source.length;\n\n    array || (array = Array(length));\n    while (++index < length) {\n      array[index] = source[index];\n    }\n    return array;\n  }\n\n  /**\n   * Copies properties of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy properties from.\n   * @param {Array} props The property identifiers to copy.\n   * @param {Object} [object={}] The object to copy properties to.\n   * @param {Function} [customizer] The function to customize copied values.\n   * @returns {Object} Returns `object`.\n   */\n  function copyObject(source, props, object, customizer) {\n    var isNew = !object;\n    object || (object = {});\n\n    var index = -1,\n      length = props.length;\n\n    while (++index < length) {\n      var key = props[index];\n\n      var newValue = customizer\n        ? customizer(object[key], source[key], key, object, source)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = source[key];\n      }\n      if (isNew) {\n        baseAssignValue(object, key, newValue);\n      } else {\n        assignValue(object, key, newValue);\n      }\n    }\n    return object;\n  }\n\n  /**\n   * Copies own symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbols(source, object) {\n    return copyObject(source, getSymbols(source), object);\n  }\n\n  /**\n   * Copies own and inherited symbols of `source` to `object`.\n   *\n   * @private\n   * @param {Object} source The object to copy symbols from.\n   * @param {Object} [object={}] The object to copy symbols to.\n   * @returns {Object} Returns `object`.\n   */\n  function copySymbolsIn(source, object) {\n    return copyObject(source, getSymbolsIn(source), object);\n  }\n\n  /**\n   * Creates an array of own enumerable property names and symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeys(object) {\n    return baseGetAllKeys(object, keys, getSymbols);\n  }\n\n  /**\n   * Creates an array of own and inherited enumerable property names and\n   * symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names and symbols.\n   */\n  function getAllKeysIn(object) {\n    return baseGetAllKeys(object, keysIn, getSymbolsIn);\n  }\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n  }\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = getValue(object, key);\n    return baseIsNative(value) ? value : undefined;\n  }\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n    try {\n      value[symToStringTag] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag] = tag;\n      } else {\n        delete value[symToStringTag];\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Creates an array of the own enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbols = !nativeGetSymbols\n    ? stubArray\n    : function(object) {\n        if (object == null) {\n          return [];\n        }\n        object = Object(object);\n        return arrayFilter(nativeGetSymbols(object), function(symbol) {\n          return propertyIsEnumerable.call(object, symbol);\n        });\n      };\n\n  /**\n   * Creates an array of the own and inherited enumerable symbols of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of symbols.\n   */\n  var getSymbolsIn = !nativeGetSymbols\n    ? stubArray\n    : function(object) {\n        var result = [];\n        while (object) {\n          arrayPush(result, getSymbols(object));\n          object = getPrototype(object);\n        }\n        return result;\n      };\n\n  /**\n   * Gets the `toStringTag` of `value`.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  var getTag = baseGetTag;\n\n  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n  if (\n    (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map()) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set()) != setTag) ||\n    (WeakMap && getTag(new WeakMap()) != weakMapTag)\n  ) {\n    getTag = function(value) {\n      var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n      if (ctorString) {\n        switch (ctorString) {\n          case dataViewCtorString:\n            return dataViewTag;\n          case mapCtorString:\n            return mapTag;\n          case promiseCtorString:\n            return promiseTag;\n          case setCtorString:\n            return setTag;\n          case weakMapCtorString:\n            return weakMapTag;\n        }\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Initializes an array clone.\n   *\n   * @private\n   * @param {Array} array The array to clone.\n   * @returns {Array} Returns the initialized clone.\n   */\n  function initCloneArray(array) {\n    var length = array.length,\n      result = new array.constructor(length);\n\n    // Add properties assigned by `RegExp#exec`.\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n      result.index = array.index;\n      result.input = array.input;\n    }\n    return result;\n  }\n\n  /**\n   * Initializes an object clone.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneObject(object) {\n    return typeof object.constructor == 'function' && !isPrototype(object)\n      ? baseCreate(getPrototype(object))\n      : {};\n  }\n\n  /**\n   * Initializes an object clone based on its `toStringTag`.\n   *\n   * **Note:** This function only supports cloning values with tags of\n   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {string} tag The `toStringTag` of the object to clone.\n   * @param {boolean} [isDeep] Specify a deep clone.\n   * @returns {Object} Returns the initialized clone.\n   */\n  function initCloneByTag(object, tag, isDeep) {\n    var Ctor = object.constructor;\n    switch (tag) {\n      case arrayBufferTag:\n        return cloneArrayBuffer(object);\n\n      case boolTag:\n      case dateTag:\n        return new Ctor(+object);\n\n      case dataViewTag:\n        return cloneDataView(object, isDeep);\n\n      case float32Tag:\n      case float64Tag:\n      case int8Tag:\n      case int16Tag:\n      case int32Tag:\n      case uint8Tag:\n      case uint8ClampedTag:\n      case uint16Tag:\n      case uint32Tag:\n        return cloneTypedArray(object, isDeep);\n\n      case mapTag:\n        return new Ctor();\n\n      case numberTag:\n      case stringTag:\n        return new Ctor(object);\n\n      case regexpTag:\n        return cloneRegExp(object);\n\n      case setTag:\n        return new Ctor();\n\n      case symbolTag:\n        return cloneSymbol(object);\n    }\n  }\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n\n    return (\n      !!length &&\n      (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&\n      (value > -1 && value % 1 == 0 && value < length)\n    );\n  }\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value;\n    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'\n      ? value !== '__proto__'\n      : value === null;\n  }\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && maskSrcKey in func;\n  }\n\n  /**\n   * Checks if `value` is likely a prototype object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n   */\n  function isPrototype(value) {\n    var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n    return value === proto;\n  }\n\n  /**\n   * This function is like\n   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * except that it includes inherited enumerable properties.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   */\n  function nativeKeysIn(object) {\n    var result = [];\n    if (object != null) {\n      for (var key in Object(object)) {\n        result.push(key);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString.call(func);\n      } catch (e) {}\n      try {\n        return func + '';\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates a shallow clone of `value`.\n   *\n   * **Note:** This method is loosely based on the\n   * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n   * and supports cloning arrays, array buffers, booleans, date objects, maps,\n   * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n   * arrays. The own enumerable properties of `arguments` objects are cloned\n   * as plain objects. An empty object is returned for uncloneable values such\n   * as error objects, functions, DOM nodes, and WeakMaps.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to clone.\n   * @returns {*} Returns the cloned value.\n   * @see _.cloneDeep\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var shallow = _.clone(objects);\n   * console.log(shallow[0] === objects[0]);\n   * // => true\n   */\n  function clone(value) {\n    return baseClone(value, CLONE_SYMBOLS_FLAG);\n  }\n\n  /**\n   * This method is like `_.clone` except that it recursively clones `value`.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.0.0\n   * @category Lang\n   * @param {*} value The value to recursively clone.\n   * @returns {*} Returns the deep cloned value.\n   * @see _.clone\n   * @example\n   *\n   * var objects = [{ 'a': 1 }, { 'b': 2 }];\n   *\n   * var deep = _.cloneDeep(objects);\n   * console.log(deep[0] === objects[0]);\n   * // => false\n   */\n  function cloneDeep(value) {\n    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n  }\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other);\n  }\n\n  /**\n   * Checks if `value` is likely an `arguments` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n   *  else `false`.\n   * @example\n   *\n   * _.isArguments(function() { return arguments; }());\n   * // => true\n   *\n   * _.isArguments([1, 2, 3]);\n   * // => false\n   */\n  var isArguments = baseIsArguments(\n    (function() {\n      return arguments;\n    })()\n  )\n    ? baseIsArguments\n    : function(value) {\n        return (\n          isObjectLike(value) &&\n          hasOwnProperty.call(value, 'callee') &&\n          !propertyIsEnumerable.call(value, 'callee')\n        );\n      };\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  /**\n   * Checks if `value` is array-like. A value is considered array-like if it's\n   * not a function and has a `value.length` that's an integer greater than or\n   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n   * @example\n   *\n   * _.isArrayLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isArrayLike(document.body.children);\n   * // => true\n   *\n   * _.isArrayLike('abc');\n   * // => true\n   *\n   * _.isArrayLike(_.noop);\n   * // => false\n   */\n  function isArrayLike(value) {\n    return value != null && isLength(value.length) && !isFunction(value);\n  }\n\n  /**\n   * Checks if `value` is a buffer.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n   * @example\n   *\n   * _.isBuffer(new Buffer(2));\n   * // => true\n   *\n   * _.isBuffer(new Uint8Array(2));\n   * // => false\n   */\n  var isBuffer = nativeIsBuffer || stubFalse;\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  /**\n   * Checks if `value` is a valid array-like length.\n   *\n   * **Note:** This method is loosely based on\n   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n   * @example\n   *\n   * _.isLength(3);\n   * // => true\n   *\n   * _.isLength(Number.MIN_VALUE);\n   * // => false\n   *\n   * _.isLength(Infinity);\n   * // => false\n   *\n   * _.isLength('3');\n   * // => false\n   */\n  function isLength(value) {\n    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n  }\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n\n  /**\n   * Checks if `value` is classified as a `Map` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n   * @example\n   *\n   * _.isMap(new Map);\n   * // => true\n   *\n   * _.isMap(new WeakMap);\n   * // => false\n   */\n  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n  /**\n   * Checks if `value` is classified as a `Set` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.3.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n   * @example\n   *\n   * _.isSet(new Set);\n   * // => true\n   *\n   * _.isSet(new WeakSet);\n   * // => false\n   */\n  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n  /**\n   * Checks if `value` is classified as a typed array.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n   * @example\n   *\n   * _.isTypedArray(new Uint8Array);\n   * // => true\n   *\n   * _.isTypedArray([]);\n   * // => false\n   */\n  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * Creates an array of the own enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects. See the\n   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n   * for more details.\n   *\n   * @static\n   * @since 0.1.0\n   * @memberOf _\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keys(new Foo);\n   * // => ['a', 'b'] (iteration order is not guaranteed)\n   *\n   * _.keys('hi');\n   * // => ['0', '1']\n   */\n  function keys(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n  }\n\n  /**\n   * Creates an array of the own and inherited enumerable property names of `object`.\n   *\n   * **Note:** Non-object values are coerced to objects.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.0.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @returns {Array} Returns the array of property names.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   *   this.b = 2;\n   * }\n   *\n   * Foo.prototype.c = 3;\n   *\n   * _.keysIn(new Foo);\n   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n   */\n  function keysIn(object) {\n    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * This method returns a new empty array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {Array} Returns the new empty array.\n   * @example\n   *\n   * var arrays = _.times(2, _.stubArray);\n   *\n   * console.log(arrays);\n   * // => [[], []]\n   *\n   * console.log(arrays[0] === arrays[1]);\n   * // => false\n   */\n  function stubArray() {\n    return [];\n  }\n\n  /**\n   * This method returns `false`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.13.0\n   * @category Util\n   * @returns {boolean} Returns `false`.\n   * @example\n   *\n   * _.times(2, _.stubFalse);\n   * // => [false, false]\n   */\n  function stubFalse() {\n    return false;\n  }\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return wrapped values in chain sequences.\n  lodash.keys = keys;\n  lodash.keysIn = keysIn;\n\n  /*------------------------------------------------------------------------*/\n\n  // Add methods that return unwrapped values in chain sequences.\n  lodash.clone = clone;\n  lodash.cloneDeep = cloneDeep;\n  lodash.eq = eq;\n  lodash.isArguments = isArguments;\n  lodash.isArray = isArray;\n  lodash.isArrayLike = isArrayLike;\n  lodash.isBuffer = isBuffer;\n  lodash.isFunction = isFunction;\n  lodash.isLength = isLength;\n  lodash.isMap = isMap;\n  lodash.isObject = isObject;\n  lodash.isObjectLike = isObjectLike;\n  lodash.isSet = isSet;\n  lodash.isTypedArray = isTypedArray;\n  lodash.stubArray = stubArray;\n  lodash.stubFalse = stubFalse;\n\n  /*------------------------------------------------------------------------*/\n\n  /**\n   * The semantic version number.\n   *\n   * @static\n   * @memberOf _\n   * @type {string}\n   */\n  lodash.VERSION = VERSION;\n\n  /*--------------------------------------------------------------------------*/\n\n  if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = lodash)._ = lodash;\n    // Export for CommonJS support.\n    freeExports._ = lodash;\n  }\n}.call(this));\n","'use strict';\n\nconst { asArray, isString, isFunction, isPlainObject } = require('./objectUtils');\n\nfunction createModifier({ modelClass, modifier, modifiers, args }) {\n  modifiers = modifiers || {};\n  args = args || [];\n\n  const modelModifiers = modelClass ? modelClass.getModifiers() : {};\n\n  const modifierFunctions = asArray(modifier).map(modifier => {\n    let modify = null;\n\n    if (isString(modifier)) {\n      modify = modifiers[modifier] || modelModifiers[modifier];\n      // Modifiers can be pointers to other modifiers. Call this function recursively.\n      if (modify) {\n        return createModifier({ modelClass, modifier: modify, modifiers });\n      }\n    } else if (isFunction(modifier)) {\n      modify = modifier;\n    } else if (isPlainObject(modifier)) {\n      modify = builder => builder.where(modifier);\n    } else if (Array.isArray(modifier)) {\n      return createModifier({ modelClass, modifier, modifiers });\n    }\n\n    if (!modify) {\n      modify = builder => modelClass.modifierNotFound(builder, modifier);\n    }\n\n    return modify;\n  });\n\n  return builder => modifierFunctions.forEach(modifier => modifier(builder, ...args));\n}\n\nmodule.exports = {\n  createModifier\n};\n","'use strict';\n\nconst LOGGED_DEPRECATIONS = new Set();\n\nfunction deprecate(message) {\n  // Only log deprecation messages once.\n  if (!LOGGED_DEPRECATIONS.has(message)) {\n    LOGGED_DEPRECATIONS.add(message);\n    console.warn(message);\n  }\n}\n\nmodule.exports = {\n  deprecate\n};\n","'use strict';\n\nconst { isObject } = require('./objectUtils');\n\n// Super fast memoize for single argument functions.\nfunction memoize(func) {\n  const cache = new Map();\n\n  return input => {\n    let output = cache.get(input);\n\n    if (output === undefined) {\n      output = func(input);\n      cache.set(input, output);\n    }\n\n    return output;\n  };\n}\n\n// camelCase to snake_case converter that also works with non-ascii characters\n// This is needed especially so that aliases containing the `:` character,\n// objection uses internally, work.\nfunction snakeCase(str, { upperCase = false, underscoreBeforeDigits = false } = {}) {\n  if (str.length === 0) {\n    return str;\n  }\n\n  const upper = str.toUpperCase();\n  const lower = str.toLowerCase();\n\n  let out = lower[0];\n\n  for (let i = 1, l = str.length; i < l; ++i) {\n    const char = str[i];\n    const prevChar = str[i - 1];\n\n    const upperChar = upper[i];\n    const prevUpperChar = upper[i - 1];\n\n    const lowerChar = lower[i];\n    const prevLowerChar = lower[i - 1];\n\n    // If underScoreBeforeDigits is true then, well, insert an underscore\n    // before digits :). Only the first digit gets an underscore if\n    // there are multiple.\n    if (underscoreBeforeDigits && isDigit(char) && !isDigit(prevChar)) {\n      out += '_' + char;\n      continue;\n    }\n\n    // Test if `char` is an upper-case character and that the character\n    // actually has different upper and lower case versions.\n    if (char === upperChar && upperChar !== lowerChar) {\n      // Multiple consecutive upper case characters shouldn't add underscores.\n      // For example \"fooBAR\" should be converted to \"foo_bar\".\n      if (prevChar === prevUpperChar && prevUpperChar !== prevLowerChar) {\n        out += lowerChar;\n      } else {\n        out += '_' + lowerChar;\n      }\n    } else {\n      out += char;\n    }\n  }\n\n  if (upperCase) {\n    return out.toUpperCase();\n  } else {\n    return out;\n  }\n}\n\n// snake_case to camelCase converter that simply reverses\n// the actions done by `snakeCase` function.\nfunction camelCase(str, { upperCase = false } = {}) {\n  if (str.length === 0) {\n    return str;\n  }\n\n  if (upperCase && isAllUpperCaseSnakeCase(str)) {\n    // Only convert to lower case if the string is all upper\n    // case snake_case. This allowes camelCase strings to go\n    // through without changing.\n    str = str.toLowerCase();\n  }\n\n  let out = str[0];\n\n  for (let i = 1, l = str.length; i < l; ++i) {\n    const char = str[i];\n    const prevChar = str[i - 1];\n\n    if (char !== '_') {\n      if (prevChar === '_') {\n        out += char.toUpperCase();\n      } else {\n        out += char;\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction isAllUpperCaseSnakeCase(str) {\n  for (let i = 1, l = str.length; i < l; ++i) {\n    const char = str[i];\n\n    if (char !== '_' && char !== char.toUpperCase()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDigit(char) {\n  return char >= '0' && char <= '9';\n}\n\n// Returns a function that splits the inputs string into pieces using `separator`,\n// only calls `mapper` for the last part and concatenates the string back together.\n// If no separators are found, `mapper` is called for the entire string.\nfunction mapLastPart(mapper, separator) {\n  return str => {\n    const idx = str.lastIndexOf(separator);\n    const mapped = mapper(str.slice(idx + separator.length));\n    return str.slice(0, idx + separator.length) + mapped;\n  };\n}\n\n// Returns a function that takes an object as an input and maps the object's keys\n// using `mapper`. If the input is not an object, the input is returned unchanged.\nfunction keyMapper(mapper) {\n  return obj => {\n    if (!isObject(obj) || Array.isArray(obj)) {\n      return obj;\n    }\n\n    const keys = Object.keys(obj);\n    const out = {};\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      const key = keys[i];\n      out[mapper(key)] = obj[key];\n    }\n\n    return out;\n  };\n}\n\nfunction snakeCaseMappers(opt = {}) {\n  return {\n    parse: keyMapper(memoize(str => camelCase(str, opt))),\n    format: keyMapper(memoize(str => snakeCase(str, opt)))\n  };\n}\n\nfunction knexIdentifierMappers({ parse, format, idSeparator = ':' } = {}) {\n  const formatId = memoize(mapLastPart(format, idSeparator));\n  const parseId = memoize(mapLastPart(parse, idSeparator));\n  const parseKeys = keyMapper(parseId);\n\n  return {\n    wrapIdentifier(identifier, origWrap) {\n      return origWrap(formatId(identifier));\n    },\n\n    postProcessResponse(result) {\n      if (Array.isArray(result)) {\n        const output = new Array(result.length);\n\n        for (let i = 0, l = result.length; i < l; ++i) {\n          output[i] = parseKeys(result[i]);\n        }\n\n        return output;\n      } else {\n        return parseKeys(result);\n      }\n    }\n  };\n}\n\nfunction knexSnakeCaseMappers(opt = {}) {\n  return knexIdentifierMappers({\n    parse: str => camelCase(str, opt),\n    format: str => snakeCase(str, opt)\n  });\n}\n\nfunction knexIdentifierMapping(colToProp) {\n  const propToCol = Object.keys(colToProp).reduce((propToCol, column) => {\n    propToCol[colToProp[column]] = column;\n    return propToCol;\n  }, {});\n\n  return knexIdentifierMappers({\n    parse: column => colToProp[column] || column,\n    format: prop => propToCol[prop] || prop\n  });\n}\n\nmodule.exports = {\n  snakeCase,\n  camelCase,\n  snakeCaseMappers,\n  knexSnakeCaseMappers,\n  knexIdentifierMappers,\n  knexIdentifierMapping,\n\n  camelCaseKeys: keyMapper(memoize(camelCase)),\n  snakeCaseKeys: keyMapper(memoize(snakeCase))\n};\n","'use strict';\n\nconst INTERNAL_PROP_PREFIX = '$';\n\nfunction isInternalProp(propName) {\n  return propName[0] === INTERNAL_PROP_PREFIX;\n}\n\nmodule.exports = {\n  isInternalProp\n};\n","'use strict';\n\nconst { isObject, isFunction } = require('../utils/objectUtils');\n\nfunction getDialect(knex) {\n  const type = typeof knex;\n\n  return (\n    (knex !== null &&\n      (type === 'object' || type === 'function') &&\n      knex.client &&\n      knex.client.dialect) ||\n    null\n  );\n}\n\nfunction isPostgres(knex) {\n  return getDialect(knex) === 'postgresql';\n}\n\nfunction isOracle(knex) {\n  const dialect = getDialect(knex);\n  return dialect === 'oracle' || dialect === 'oracledb';\n}\n\nfunction isMySql(knex) {\n  const dialect = getDialect(knex);\n  return dialect === 'mysql' || dialect === 'mysql2';\n}\n\nfunction isSqlite(knex) {\n  return getDialect(knex) === 'sqlite3';\n}\n\nfunction isMsSql(knex) {\n  return getDialect(knex) === 'mssql';\n}\n\nfunction isKnexQueryBuilder(value) {\n  return hasConstructor(value, 'Builder') && 'client' in value;\n}\n\nfunction isKnexJoinBuilder(value) {\n  return hasConstructor(value, 'JoinClause') && 'joinType' in value;\n}\n\nfunction isKnexRaw(value) {\n  return hasConstructor(value, 'Raw') && 'client' in value;\n}\n\nfunction isKnexTransaction(knex) {\n  return !!getDialect(knex) && isFunction(knex.commit) && isFunction(knex.rollback);\n}\n\nfunction hasConstructor(value, constructorName) {\n  return (\n    isObject(value) && isFunction(value.constructor) && value.constructor.name === constructorName\n  );\n}\n\nmodule.exports = {\n  getDialect,\n  isPostgres,\n  isMySql,\n  isSqlite,\n  isMsSql,\n  isOracle,\n  isKnexQueryBuilder,\n  isKnexJoinBuilder,\n  isKnexRaw,\n  isKnexTransaction\n};\n","'use strict';\n\nconst { flatten } = require('./objectUtils');\n\nfunction mixin() {\n  const args = flatten(arguments);\n  const mixins = args.slice(1);\n\n  return mixins.reduce((Class, mixinFunc) => {\n    return mixinFunc(Class);\n  }, args[0]);\n}\n\nfunction compose() {\n  const mixins = flatten(arguments);\n\n  return function(Class) {\n    return mixin(Class, mixins);\n  };\n}\n\nmodule.exports = {\n  compose,\n  mixin\n};\n","'use strict';\n\nconst { isObject } = require('../utils/objectUtils');\n\n// ids is of type RelationProperty.\nfunction normalizeIds(ids, prop, opt) {\n  opt = opt || {};\n\n  let isComposite = prop.size > 1;\n  let ret;\n\n  if (isComposite) {\n    // For composite ids these are okay:\n    //\n    // 1. [1, 'foo', 4]\n    // 2. {a: 1, b: 'foo', c: 4}\n    // 3. [[1, 'foo', 4], [4, 'bar', 1]]\n    // 4. [{a: 1, b: 'foo', c: 4}, {a: 4, b: 'bar', c: 1}]\n    //\n    if (Array.isArray(ids)) {\n      if (Array.isArray(ids[0])) {\n        ret = new Array(ids.length);\n\n        // 3.\n        for (let i = 0, l = ids.length; i < l; ++i) {\n          ret[i] = convertIdArrayToObject(ids[i], prop);\n        }\n      } else if (isObject(ids[0])) {\n        ret = new Array(ids.length);\n\n        // 4.\n        for (let i = 0, l = ids.length; i < l; ++i) {\n          ret[i] = ensureObject(ids[i], prop);\n        }\n      } else {\n        // 1.\n        ret = [convertIdArrayToObject(ids, prop)];\n      }\n    } else if (isObject(ids)) {\n      // 2.\n      ret = [ids];\n    } else {\n      throw new Error(`invalid composite key ${JSON.stringify(ids)}`);\n    }\n  } else {\n    // For non-composite ids, these are okay:\n    //\n    // 1. 1\n    // 2. {id: 1}\n    // 3. [1, 'foo', 4]\n    // 4. [{id: 1}, {id: 'foo'}, {id: 4}]\n    //\n    if (Array.isArray(ids)) {\n      if (isObject(ids[0])) {\n        ret = new Array(ids.length);\n\n        // 4.\n        for (let i = 0, l = ids.length; i < l; ++i) {\n          ret[i] = ensureObject(ids[i]);\n        }\n      } else {\n        ret = new Array(ids.length);\n\n        // 3.\n        for (let i = 0, l = ids.length; i < l; ++i) {\n          ret[i] = {};\n          prop.setProp(ret[i], 0, ids[i]);\n        }\n      }\n    } else if (isObject(ids)) {\n      // 2.\n      ret = [ids];\n    } else {\n      // 1.\n      const obj = {};\n      prop.setProp(obj, 0, ids);\n      ret = [obj];\n    }\n  }\n\n  checkProperties(ret, prop);\n\n  if (opt.arrayOutput) {\n    return normalizedToArray(ret, prop);\n  } else {\n    return ret;\n  }\n}\n\nfunction convertIdArrayToObject(ids, prop) {\n  if (!Array.isArray(ids)) {\n    throw new Error(`invalid composite key ${JSON.stringify(ids)}`);\n  }\n\n  if (ids.length != prop.size) {\n    throw new Error(`composite identifier ${JSON.stringify(ids)} should have ${prop.size} values`);\n  }\n\n  const obj = {};\n\n  for (let i = 0; i < ids.length; ++i) {\n    prop.setProp(obj, i, ids[i]);\n  }\n\n  return obj;\n}\n\nfunction ensureObject(ids) {\n  if (isObject(ids)) {\n    return ids;\n  } else {\n    throw new Error(`invalid composite key ${JSON.stringify(ids)}`);\n  }\n}\n\nfunction checkProperties(ret, prop) {\n  for (let i = 0, l = ret.length; i < l; ++i) {\n    const obj = ret[i];\n\n    for (let j = 0, lp = prop.size; j < lp; ++j) {\n      const val = prop.getProp(obj, j);\n\n      if (typeof val === 'undefined') {\n        throw new Error(\n          `expected id ${JSON.stringify(obj)} to have property ${prop.propDescription(j)}`\n        );\n      }\n    }\n  }\n}\n\nfunction normalizedToArray(ret, prop) {\n  const arr = new Array(ret.length);\n\n  for (let i = 0, l = ret.length; i < l; ++i) {\n    arr[i] = prop.getProps(ret[i]);\n  }\n\n  return arr;\n}\n\nmodule.exports = {\n  normalizeIds\n};\n","'use strict';\n\nconst { clone, cloneDeep } = require('./clone');\nconst SMALL_ARRAY_SIZE = 10;\n\nfunction isEmpty(item) {\n  if (Array.isArray(item)) {\n    return item.length === 0;\n  } else if (isObject(item)) {\n    return Object.keys(item).length === 0;\n  } else {\n    return true;\n  }\n}\n\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n// Quick and dirty check if an object is a plain object and not\n// for example an instance of some class.\nfunction isPlainObject(value) {\n  return (\n    isObject(value) &&\n    (!value.constructor || value.constructor === Object) &&\n    (!value.toString || value.toString === Object.prototype.toString)\n  );\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n\nfunction asArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction asSingle(value) {\n  return Array.isArray(value) ? value[0] : value;\n}\n\nfunction uniqBy(items, keyGetter = null) {\n  const map = new Map();\n\n  for (let i = 0, l = items.length; i < l; ++i) {\n    const item = items[i];\n    const key = keyGetter !== null ? keyGetter(item) : item;\n\n    map.set(key, item);\n  }\n\n  return Array.from(map.values());\n}\n\nfunction groupBy(items, keyGetter = null) {\n  const groups = new Map();\n\n  for (const item of items) {\n    const key = keyGetter !== null ? keyGetter(item) : item;\n    let group = groups.get(key);\n\n    if (!group) {\n      group = [];\n      groups.set(key, group);\n    }\n\n    group.push(item);\n  }\n\n  return groups;\n}\n\nfunction omit(obj, keysToOmit) {\n  keysToOmit = asArray(keysToOmit);\n\n  const keys = Object.keys(obj);\n  const out = {};\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    const key = keys[i];\n\n    if (!keysToOmit.includes(key)) {\n      out[key] = obj[key];\n    }\n  }\n\n  return out;\n}\n\nfunction difference(arr1, arr2) {\n  const arr2Set = new Set(arr2);\n  const diff = [];\n\n  for (let i = 0; i < arr1.length; ++i) {\n    const value = arr1[i];\n\n    if (!arr2Set.has(value)) {\n      diff.push(value);\n    }\n  }\n\n  return diff;\n}\n\nfunction union(arr1, arr2) {\n  if (arr1.length < SMALL_ARRAY_SIZE && arr2.length < SMALL_ARRAY_SIZE) {\n    return unionSmall(arr1, arr2);\n  } else {\n    return unionGeneric(arr1, arr2);\n  }\n}\n\nfunction unionSmall(arr1, arr2) {\n  const all = arr1.slice();\n\n  for (let i = 0, l = arr2.length; i < l; ++i) {\n    const item = arr2[i];\n\n    if (all.indexOf(item) === -1) {\n      all.push(item);\n    }\n  }\n\n  return all;\n}\n\nfunction unionGeneric(arr1, arr2) {\n  const all = new Set();\n\n  for (let i = 0; i < arr1.length; ++i) {\n    all.add(arr1[i]);\n  }\n\n  for (let i = 0; i < arr2.length; ++i) {\n    all.add(arr2[i]);\n  }\n\n  return Array.from(all);\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction upperFirst(str) {\n  return str[0].toUpperCase() + str.substring(1);\n}\n\nfunction values(obj) {\n  if (isObject(obj)) {\n    const keys = Object.keys(obj);\n    const values = new Array(keys.length);\n\n    for (let i = 0, l = keys.length; i < l; ++i) {\n      values[i] = obj[keys[i]];\n    }\n\n    return values;\n  } else {\n    return [];\n  }\n}\n\nfunction once(func) {\n  let called = false;\n  let value = undefined;\n\n  return function() {\n    if (called === false) {\n      called = true;\n      value = func.apply(this, arguments);\n    }\n\n    return value;\n  };\n}\n\nfunction flatten(arrays) {\n  const out = [];\n  let outIdx = 0;\n\n  for (let i = 0, l = arrays.length; i < l; ++i) {\n    const value = arrays[i];\n\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        out.push(value[j]);\n      }\n    } else {\n      out.push(value);\n    }\n  }\n\n  return out;\n}\n\nfunction get(obj, path) {\n  for (let i = 0, l = path.length; i < l; ++i) {\n    const key = path[i];\n\n    if (!isObject(obj)) {\n      return undefined;\n    }\n\n    obj = obj[key];\n  }\n\n  return obj;\n}\n\nfunction set(obj, path, value) {\n  const inputObj = obj;\n\n  for (let i = 0, l = path.length - 1; i < l; ++i) {\n    const key = path[i];\n    let child = obj[key];\n\n    if (!isObject(child)) {\n      const nextKey = path[i + 1];\n\n      if (isNaN(nextKey)) {\n        child = {};\n      } else {\n        child = [];\n      }\n\n      obj[key] = child;\n    }\n\n    obj = child;\n  }\n\n  if (path.length > 0 && isObject(obj)) {\n    obj[path[path.length - 1]] = value;\n  }\n\n  return inputObj;\n}\n\nfunction zipObject(keys, values) {\n  const out = {};\n\n  for (let i = 0, l = keys.length; i < l; ++i) {\n    out[keys[i]] = values[i];\n  }\n\n  return out;\n}\n\nfunction chunk(arr, chunkSize) {\n  const out = [];\n\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    const item = arr[i];\n\n    if (out.length === 0 || out[out.length - 1].length === chunkSize) {\n      out.push([]);\n    }\n\n    out[out.length - 1].push(item);\n  }\n\n  return out;\n}\n\nfunction jsonEquals(val1, val2) {\n  return jsonEqualsBase(val1, val2, compareStrict);\n}\n\nfunction jsonEqualsBase(val1, val2, compare) {\n  if (val1 === val2) {\n    return true;\n  }\n\n  return jsonEqualsSlowPath(val1, val2, compare);\n}\n\nfunction jsonEqualsSlowPath(val1, val2, compare) {\n  const type1 = typeof val1;\n  const type2 = typeof val2;\n\n  const isNonNullObject1 = type1 === 'object' && !compare(val1, null);\n  const isNonNullObject2 = type2 === 'object' && !compare(val2, null);\n\n  if (isNonNullObject1 && isNonNullObject2) {\n    const isArray1 = Array.isArray(val1);\n    const isArray2 = Array.isArray(val2);\n\n    if (isArray1 && isArray2) {\n      return jsonEqualsArray(val1, val2, compare);\n    } else if (!isArray1 && !isArray2) {\n      return jsonEqualsObject(val1, val2, compare);\n    } else {\n      return false;\n    }\n  } else if (isNonNullObject1 !== isNonNullObject2) {\n    return false;\n  } else {\n    return compare(val1, val2);\n  }\n}\n\nfunction jsonEqualsArray(arr1, arr2, compare) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0, l = arr1.length; i < l; ++i) {\n    if (!jsonEqualsBase(arr1[i], arr2[i], compare)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction jsonEqualsObject(obj1, obj2, compare) {\n  if (obj1.constructor === Date && obj2.constructor === Date) {\n    return equalsDate(obj1, obj2);\n  }\n\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n\n  for (let i = 0, l = keys1.length; i < l; ++i) {\n    const key = keys1[i];\n\n    if (!jsonEqualsBase(obj1[key], obj2[key], compare)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction equalsDate(date1, date2) {\n  return date1.getTime() === date2.getTime();\n}\n\nfunction compareStrict(val1, val2) {\n  return val1 === val2;\n}\n\nmodule.exports = {\n  isEmpty,\n  isString,\n  isRegExp,\n  isObject,\n  isNumber,\n  isFunction,\n  jsonEquals,\n  isPlainObject,\n  difference,\n  upperFirst,\n  zipObject,\n  cloneDeep,\n  asSingle,\n  asArray,\n  flatten,\n  groupBy,\n  uniqBy,\n  values,\n  union,\n  chunk,\n  clone,\n  omit,\n  once,\n  last,\n  get,\n  set\n};\n","'use strict';\n\nconst jsonFieldExpressionParser = require('../queryBuilder/parsers/jsonFieldExpressionParser');\nconst cache = new Map();\n\nfunction parseFieldExpression(expr) {\n  let parsedExpr = cache.get(expr);\n\n  if (parsedExpr !== undefined) {\n    return parsedExpr;\n  } else {\n    parsedExpr = jsonFieldExpressionParser.parse(expr);\n    parsedExpr = preprocessParsedExpression(parsedExpr);\n\n    // We don't take a copy of the parsedExpr each time we\n    // use if from cache. Instead to make sure it's never\n    // mutated we deep-freeze it.\n    parsedExpr = freezeParsedExpr(parsedExpr);\n\n    cache.set(expr, parsedExpr);\n    return parsedExpr;\n  }\n}\n\nfunction preprocessParsedExpression(parsedExpr) {\n  const columnParts = parsedExpr.columnName.split('.').map(part => part.trim());\n  parsedExpr.column = columnParts[columnParts.length - 1];\n\n  if (columnParts.length >= 2) {\n    parsedExpr.table = columnParts.slice(0, columnParts.length - 1).join('.');\n  } else {\n    parsedExpr.table = null;\n  }\n\n  return parsedExpr;\n}\n\nfunction freezeParsedExpr(parsedExpr) {\n  for (const access of parsedExpr.access) {\n    Object.freeze(access);\n  }\n\n  Object.freeze(parsedExpr.access);\n  Object.freeze(parsedExpr);\n\n  return parsedExpr;\n}\n\nmodule.exports = {\n  parseFieldExpression\n};\n","'use strict';\n\nconst { isPromise } = require('./isPromise');\n\n// Call `func` after `obj` has been resolved. Call `func` synchronously if\n// `obj` is not a promise for performance reasons.\nfunction after(obj, func) {\n  if (isPromise(obj)) {\n    return obj.then(func);\n  } else {\n    return func(obj);\n  }\n}\n\nmodule.exports = {\n  after\n};\n","'use strict';\n\nconst { isPromise } = require('./isPromise');\n\n// Return `returnValue` after `obj` has been resolved. Return `returnValue`\n// synchronously if `obj` is not a promise for performance reasons.\nfunction afterReturn(obj, returnValue) {\n  if (isPromise(obj)) {\n    return obj.then(() => returnValue);\n  } else {\n    return returnValue;\n  }\n}\n\nmodule.exports = {\n  afterReturn\n};\n","'use strict';\n\nconst { isPromise } = require('./isPromise');\nconst { after } = require('./after');\nconst { afterReturn } = require('./afterReturn');\nconst { mapAfterAllReturn } = require('./mapAfterAllReturn');\nconst { promiseMap } = require('./map');\nconst { promiseTry } = require('./try');\n\nmodule.exports = {\n  isPromise,\n  after,\n  afterReturn,\n  mapAfterAllReturn,\n  map: promiseMap,\n  try: promiseTry\n};\n","'use strict';\n\nconst { isObject, isFunction } = require('../objectUtils');\n\nfunction isPromise(obj) {\n  return isObject(obj) && isFunction(obj.then);\n}\n\nmodule.exports = {\n  isPromise\n};\n","'use strict';\n\nconst { isPromise } = require('./isPromise');\n\n// Works like Bluebird.map.\nfunction promiseMap(items, mapper, opt) {\n  switch (items.length) {\n    case 0:\n      return mapZero();\n    case 1:\n      return mapOne(items, mapper);\n    default:\n      return mapMany(items, mapper, opt);\n  }\n}\n\nfunction mapZero() {\n  return Promise.resolve([]);\n}\n\nfunction mapOne(items, mapper) {\n  try {\n    const maybePromise = mapper(items[0], 0);\n\n    if (isPromise(maybePromise)) {\n      return maybePromise.then(wrapArray);\n    } else {\n      return Promise.resolve(wrapArray(maybePromise));\n    }\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nfunction wrapArray(item) {\n  return [item];\n}\n\nfunction mapMany(items, mapper, opt = {}) {\n  return new Promise((resolve, reject) => {\n    const concurrency = opt.concurrency || Number.MAX_SAFE_INTEGER;\n\n    const ctx = {\n      reject,\n      resolve,\n      rejected: false,\n      index: 0,\n      numFinished: 0,\n      results: new Array(items.length),\n      items,\n      mapper\n    };\n\n    while (ctx.index < concurrency && ctx.index < items.length && !ctx.rejected) {\n      executeNext(ctx);\n    }\n  });\n}\n\nfunction executeNext(ctx) {\n  try {\n    if (ctx.rejected) {\n      return;\n    }\n\n    const index = ctx.index++;\n    const item = ctx.items[index];\n    const maybePromise = ctx.mapper(item, index);\n\n    if (isPromise(maybePromise)) {\n      maybePromise.then(result => afterExecute(ctx, result, index)).catch(err => onError(ctx, err));\n    } else {\n      process.nextTick(() => afterExecute(ctx, maybePromise, index));\n    }\n\n    return null;\n  } catch (err) {\n    onError(ctx, err);\n  }\n}\n\nfunction afterExecute(ctx, result, index) {\n  if (ctx.rejected) {\n    return null;\n  }\n\n  ctx.results[index] = result;\n  ctx.numFinished++;\n\n  if (ctx.numFinished === ctx.items.length) {\n    ctx.resolve(ctx.results);\n  }\n\n  if (ctx.index < ctx.items.length) {\n    executeNext(ctx);\n  }\n\n  return null;\n}\n\nfunction onError(ctx, err) {\n  ctx.rejected = true;\n  ctx.reject(err);\n}\n\nmodule.exports = {\n  promiseMap\n};\n","'use strict';\n\nconst { isPromise } = require('./isPromise');\n\n// Map `arr` with `mapper` and after that return `returnValue`. If none of\n// the mapped values is a promise, return synchronously for performance\n// reasons.\nfunction mapAfterAllReturn(arr, mapper, returnValue) {\n  const results = new Array(arr.length);\n  let containsPromise = false;\n\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    results[i] = mapper(arr[i]);\n\n    if (isPromise(results[i])) {\n      containsPromise = true;\n    }\n  }\n\n  if (containsPromise) {\n    return Promise.all(results).then(() => returnValue);\n  } else {\n    return returnValue;\n  }\n}\n\nmodule.exports = {\n  mapAfterAllReturn\n};\n","'use strict';\n\nconst { isPromise } = require('./isPromise');\n\n// Works like Bluebird.try.\nfunction promiseTry(callback) {\n  try {\n    const maybePromise = callback();\n\n    if (isPromise(maybePromise)) {\n      return maybePromise;\n    } else {\n      return Promise.resolve(maybePromise);\n    }\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nmodule.exports = {\n  promiseTry\n};\n","'use strict';\n\nconst path = require('path');\nconst { once, isString, isFunction } = require('../utils/objectUtils');\nconst { isSubclassOf } = require('../utils/classUtils');\n\nconst getModel = once(() => require('../model/Model').Model);\nclass ResolveError extends Error {}\n\nfunction resolveModel(modelRef, modelPaths, errorPrefix) {\n  try {\n    if (isString(modelRef)) {\n      if (isAbsolutePath(modelRef)) {\n        return requireModel(modelRef);\n      } else if (modelPaths) {\n        return requireUsingModelPaths(modelRef, modelPaths);\n      }\n    } else {\n      if (isFunction(modelRef) && !isSubclassOf(modelRef, getModel())) {\n        modelRef = modelRef();\n      }\n\n      if (!isSubclassOf(modelRef, getModel())) {\n        throw new ResolveError(\n          `is not a subclass of Model or a file path to a module that exports one. You may be dealing with a require loop. See the documentation section about require loops.`\n        );\n      }\n\n      return modelRef;\n    }\n  } catch (err) {\n    if (err instanceof ResolveError) {\n      throw new Error(`${errorPrefix}: ${err.message}`);\n    } else {\n      throw err;\n    }\n  }\n}\n\nfunction requireUsingModelPaths(modelRef, modelPaths) {\n  let firstError = null;\n\n  for (const modelPath of modelPaths) {\n    try {\n      return requireModel(path.join(modelPath, modelRef));\n    } catch (err) {\n      if (firstError === null) {\n        firstError = err;\n      }\n    }\n  }\n\n  if (firstError) {\n    throw firstError;\n  } else {\n    throw new ResolveError(`could not resolve ${modelRef} using modelPaths`);\n  }\n}\n\nfunction requireModel(modelPath) {\n  const Model = getModel();\n  /**\n   * Wrap path string in template literal to prevent\n   * warnings about Objection.JS being an expression\n   * in webpack builds.\n   * @link https://github.com/webpack/webpack/issues/196\n   */\n  let mod = require(`${path.resolve(modelPath)}`);\n  let modelClass = null;\n\n  if (isSubclassOf(mod, Model)) {\n    modelClass = mod;\n  } else if (isSubclassOf(mod.default, Model)) {\n    // Babel 6 style of exposing default export.\n    modelClass = mod.default;\n  } else {\n    Object.keys(mod).forEach(exportName => {\n      const exp = mod[exportName];\n\n      if (isSubclassOf(exp, Model)) {\n        if (modelClass !== null) {\n          throw new ResolveError(\n            `path ${modelPath} exports multiple models. Don't know which one to choose.`\n          );\n        }\n\n        modelClass = exp;\n      }\n    });\n  }\n\n  if (!isSubclassOf(modelClass, Model)) {\n    throw new ResolveError(`${modelPath} is an invalid file path to a model class`);\n  }\n\n  return modelClass;\n}\n\nfunction isAbsolutePath(pth) {\n  return path.normalize(pth + '/') === path.normalize(path.resolve(pth) + '/');\n}\n\nmodule.exports = {\n  resolveModel\n};\n","'use strict';\n\nconst OWNER_JOIN_COLUMN_ALIAS_PREFIX = 'objectiontmpjoin';\n\nfunction getTempColumn(index) {\n  return `${OWNER_JOIN_COLUMN_ALIAS_PREFIX}${index}`;\n}\n\nfunction isTempColumn(col) {\n  return col.startsWith(OWNER_JOIN_COLUMN_ALIAS_PREFIX);\n}\n\nmodule.exports = {\n  getTempColumn,\n  isTempColumn\n};\n","export const Login = `displayName\n        clientId\n        profilePicturePath\n        sessionToken\n        roleIds`\n\nexport const User = `id\n        client_id\n        username\n        pwd\n        name_last\n        name_first\n        is_enabled\n        is_verified\n        must_change_pwd\n        pwd_expiration\n        email\n        phone\n        profile_picture_path\n        default_timezone\n        default_language\n        user_salt\n        default_date_format\n        address\n        created\n        modified`\n","import { ApolloServer } from 'apollo-server-lambda'\nimport typeDefs from './typeDefs'\nimport resolvers from './resolvers'\nimport playground from './playground'\nimport Knex from 'knex'\nimport { Model } from 'objection'\nrequire('dotenv').config()\n\nconst db = Knex({\n  client: 'pg',\n  connection: {\n    host: process.env.DB_HOST,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    database: process.env.ADVITO_DB_DATABASE\n  }\n})\nModel.knex(db)\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: async ({ event }) => {\n    const sessionToken = event.headers.sessiontoken || ''\n    return { db }\n    // const user = await authenticateUser(sessionToken, advitoDb)\n    // return { user, db }\n  },\n  // schemaDirectives: {\n  //   auth: requireAuthDirective\n  // },\n  playground\n})\n\nexport const graphqlHandler = server.createHandler({\n  cors: {\n    origin: true,\n    credentials: true\n  }\n})\n","import { Model } from 'objection'\n\nexport class AdvitoUser extends Model {\n  static get tableName () {\n    return 'advito_user'\n  }\n\n  fullName () {\n    return this.name_first + ' ' + this.name_last\n  }\n\n  static get relationMappings () {\n    return { advito_user_role_link: {\n      relation: Model.HasManyRelation,\n      modelClass: AdvitoUserRoleLink,\n      join: {\n        from: 'advito_user.id',\n        to: 'advito_user_role_link.advito_user_id'\n      }\n    },\n    advito_user_session: {\n      relation: Model.HasManyRelation,\n      modelClass: AdvitoUserSession,\n      join: {\n        from: 'advito_user.id',\n        to: 'advito_user_session.advito_user_id'\n      }\n    } }\n  }\n}\n\nexport class AdvitoUserRoleLink extends Model {\n  static get tableName () {\n    return 'advito_user_role_link'\n  }\n}\n\nexport class AdvitoUserSession extends Model {\n  static get tableName () {\n    return 'advito_user_session'\n  }\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import user from './user'\n\nexport default {\n  tabs: [\n    user.Query,\n    user.Mutation\n  ]\n}\n","import { User, Login } from '../constants'\nexport default {\n  Query: {\n    name: 'User Queries',\n    endpoint: '',\n    headers: { sessiontoken: 'MY^PR3TTYP0NY' },\n    query: `\n    {\n      getUser {\n        ${User}\n      }\n    }`\n  },\n  Mutation: {\n    name: 'User Mutations',\n    endpoint: '',\n    headers: { sessiontoken: 'MY^PR3TTYP0NY' },\n    query: `\n    mutation {\n      login(username: \"\", password: \"\") {\n        ${Login}\n      }\n      logout(sessionToken: \"\")\n    }`\n  }\n}\n","import { GraphQLScalarType } from 'graphql'\nimport { Kind } from 'graphql/language'\nimport user from './user'\nimport merge from 'lodash.merge'\n\nexport default {\n  ...merge(\n    user\n  ),\n  Date: new GraphQLScalarType({\n    name: 'Date',\n    description: 'Date custom scalar type',\n    parseValue (value) {\n      return new Date(value)\n    },\n    serialize (value) {\n      return new Date(value).getTime()\n    },\n    parseLiteral (ast) {\n      if (ast.kind === Kind.INT) {\n        return parseInt(ast.value, 10)\n      }\n      return null\n    }\n  })\n}\n","import { AuthenticationError } from 'apollo-server-lambda'\nimport { AdvitoUser, AdvitoUserSession } from '../models'\nimport { saltHash } from '../util'\nimport crypto from 'crypto'\n\nexport default {\n  Query: {\n    getUser: async (_, __) => AdvitoUser.query().findById(711)\n  },\n  Mutation: {\n    login: async (_, { username, password }) => {\n      const user = await AdvitoUser.query().where('username', username).first()\n      if (!user) throw new AuthenticationError('User not found')\n      if (!user.is_enabled) throw new AuthenticationError('User is not enabled')\n      const { pwd: dbPassword, user_salt: userSalt } = user\n      const { passwordHashed } = saltHash(password, userSalt)\n      if (dbPassword !== passwordHashed) throw new AuthenticationError('Password is incorrect`')\n\n      const roleIds = await user.$relatedQuery('advito_user_role_link').map(role => role.advito_role_id)\n\n      const session = await user.$relatedQuery('advito_user_session').where('session_end', null).first()\n      const sessionToken = crypto.randomBytes(16).toString('base64')\n      const expirationDate = new Date()\n      expirationDate.setHours(expirationDate.getHours() + 1)\n      if (session) await user.$relatedQuery('advito_user_session').patch({ session_end: new Date() }).where('session_end', null)\n      await user.$relatedQuery('advito_user_session').insert({\n        advito_user_id: user.id,\n        session_token: sessionToken,\n        session_start: new Date(),\n        session_end: null,\n        session_duration_sec: 3600,\n        session_type: null,\n        session_expiration: new Date(expirationDate),\n        session_note: null,\n        created: new Date(),\n        modified: new Date()\n      })\n\n      return {\n        displayName: user.fullName(),\n        clientId: user.client_id,\n        profilePicturePath: user.profile_picture_path,\n        sessionToken,\n        roleIds\n      }\n    },\n    logout: async (_, { sessionToken }) => {\n      const session = await AdvitoUserSession.query().where('session_token', sessionToken).where('session_end', null).first()\n      if (!session) throw new AuthenticationError('User session not found')\n      await AdvitoUserSession.query().patch({ session_end: new Date() }).where('session_token', sessionToken).where('session_end', null)\n    }\n  }\n}\n","import { gql } from 'apollo-server-lambda'\nimport user from './user'\n\nexport default gql`\n  scalar Date\n  ${user}\n  type Query {\n    _empty: String\n  }\n  type Mutation {\n    _empty: String\n  }\n`\n","export default `\ntype User {\n  id: String,\n  client_id: String,\n  username: String,\n  pwd: String,\n  name_last: String,\n  name_first: String,\n  is_enabled: Boolean,\n  is_verified: Boolean,\n  must_change_pwd: Boolean,\n  pwd_expiration: Date,\n  email: String,\n  phone: String,\n  profile_picture_path: String,\n  default_timezone: String,\n  default_language: String,\n  user_salt: String,\n  default_date_format: String,\n  address: String,\n  created: String,\n  modified: String\n}\ntype Login {\n  displayName: String,\n  clientId: Int,\n  profilePicturePath: String,\n  sessionToken: String,\n  roleIds: [Int]\n}\n\nextend type Query {\n  getUser: User\n}\nextend type Mutation {\n  login(username: String!, password: String!): Login\n  logout(sessionToken: String!): Int\n}\n`\n","import crypto from 'crypto'\n\nexport const saltHash = (password, salt = null) => {\n  const saltHashed = salt || crypto.randomBytes(16).toString('base64')\n  const passwordHashed = crypto.createHash('sha256')\n    .update(password)\n    .update(saltHashed, 'base64')\n    .digest('base64')\n  return {\n    saltHashed,\n    passwordHashed\n  }\n}\n","module.exports = require(\"ajv\");","module.exports = require(\"apollo-server-lambda\");","module.exports = require(\"bluebird\");","module.exports = require(\"crypto\");","module.exports = require(\"dotenv\");","module.exports = require(\"graphql\");","module.exports = require(\"graphql/language\");","module.exports = require(\"knex\");","module.exports = require(\"lodash\");","module.exports = require(\"path\");","module.exports = require(\"source-map-support/register\");"],"sourceRoot":""}